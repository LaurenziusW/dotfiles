#!/usr/bin/env bash
# ==============================================================================
# UKE Profile Applicator v7.0 - Hardware Config Generator
# ==============================================================================
# Reads ~/.local/state/uke/machine.profile and generates hardware-specific
# "ghost files" that are sourced by the main configs but NOT version controlled.
#
# Generated files:
#   - ~/.config/hypr/generated_hardware.conf
#   - ~/.config/yabai/generated_hardware.conf  
#   - ~/.config/wezterm/generated_hardware.lua
#
# Usage: apply_profile.sh [--dry-run]
#        uke apply [--dry-run]
# ==============================================================================
set -euo pipefail

# ==============================================================================
# Path Resolution
# ==============================================================================
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
export UKE_ROOT="${SCRIPT_DIR%/scripts}"

# Source core if available
if [[ -f "$UKE_ROOT/lib/core.sh" ]]; then
    source "$UKE_ROOT/lib/core.sh"
else
    # Minimal definitions
    UKE_STATE="${XDG_STATE_HOME:-$HOME/.local/state}/uke"
    UKE_PROFILE_FILE="$UKE_STATE/machine.profile"
    is_macos() { [[ "$(uname -s)" == "Darwin" ]]; }
    is_linux() { [[ "$(uname -s)" == "Linux" ]]; }
fi

# ==============================================================================
# Configuration
# ==============================================================================
PROFILE_DIR="${UKE_STATE:-$HOME/.local/state/uke}"
PROFILE_FILE="${PROFILE_DIR}/machine.profile"

# Output directories
HYPR_DIR="${HOME}/.config/hypr"
YABAI_DIR="${HOME}/.config/yabai"
WEZTERM_DIR="${HOME}/.config/wezterm"

# Dry run mode
DRY_RUN="${1:-}"

# ==============================================================================
# Colors (use existing from core.sh or define new)
# ==============================================================================
# Don't use readonly to avoid conflicts with core.sh
if [[ -z "${C_RED:-}" ]]; then
    if [[ -t 1 ]]; then
        C_RED=$'\e[31m'
        C_GREEN=$'\e[32m'
        C_YELLOW=$'\e[33m'
        C_BLUE=$'\e[34m'
        C_DIM=$'\e[2m'
        C_BOLD=$'\e[1m'
        C_RESET=$'\e[0m'
    else
        C_RED='' C_GREEN='' C_YELLOW='' C_BLUE=''
        C_DIM='' C_BOLD='' C_RESET=''
    fi
fi

# ==============================================================================
# Logging
# ==============================================================================
ok()   { printf "%s✓%s %s\n" "${C_GREEN}" "${C_RESET}" "$*"; }
warn() { printf "%s!%s %s\n" "${C_YELLOW}" "${C_RESET}" "$*"; }
fail() { printf "%s✗%s %s\n" "${C_RED}" "${C_RESET}" "$*" >&2; }
info() { printf "%s→%s %s\n" "${C_BLUE}" "${C_RESET}" "$*"; }

# ==============================================================================
# Generated File Header
# ==============================================================================
gen_header() {
    local format="$1"
    
    case "$format" in
        conf)
            printf '%s\n' \
                "# ==============================================================================" \
                "# DO NOT EDIT - GENERATED HARDWARE CONFIG (Ghost File)" \
                "# ==============================================================================" \
                "# Generated by: uke apply (apply_profile.sh)" \
                "# Source: ~/.local/state/uke/machine.profile" \
                "# Timestamp: $(date -Iseconds)" \
                "#" \
                "# This file contains machine-specific settings based on your hardware profile." \
                "# To modify, run: uke profile" \
                "# ==============================================================================" \
                ""
            ;;
        lua)
            printf '%s\n' \
                "-- ==============================================================================" \
                "-- DO NOT EDIT - GENERATED HARDWARE CONFIG (Ghost File)" \
                "-- ==============================================================================" \
                "-- Generated by: uke apply (apply_profile.sh)" \
                "-- Source: ~/.local/state/uke/machine.profile" \
                "-- Timestamp: $(date -Iseconds)" \
                "--" \
                "-- To modify, run: uke profile" \
                "-- ==============================================================================" \
                ""
            ;;
    esac
}

# ==============================================================================
# Safe File Writing
# ==============================================================================
write_file() {
    local dest="$1"
    local content
    content=$(cat)
    
    if [[ "${DRY_RUN}" == "--dry-run" ]]; then
        info "[DRY RUN] Would write: ${dest}"
        printf "%s\n" "${content}"
        echo ""
        return 0
    fi
    
    mkdir -p "$(dirname "${dest}")"
    
    local temp_file
    temp_file=$(mktemp)
    printf "%s\n" "${content}" > "${temp_file}"
    mv "${temp_file}" "${dest}"
    
    ok "Generated: ${dest}"
}

# ==============================================================================
# Load Profile
# ==============================================================================
load_profile() {
    if [[ ! -f "${PROFILE_FILE}" ]]; then
        fail "Profile not found: ${PROFILE_FILE}"
        info "Run 'uke profile' to create one"
        exit 1
    fi
    
    # shellcheck source=/dev/null
    source "${PROFILE_FILE}"
    
    # Validate required variables
    local required_vars=(UKE_OS UKE_FORM_FACTOR UKE_MONITORS UKE_GPU UKE_KEYBOARD)
    local var
    for var in "${required_vars[@]}"; do
        if [[ -z "${!var:-}" ]]; then
            fail "Missing required variable: ${var}"
            exit 1
        fi
    done
}

# ==============================================================================
# Form Factor → Settings Mapping
# ==============================================================================
get_font_size() {
    case "${UKE_FORM_FACTOR}" in
        desktop)    echo "11.0" ;;
        laptop_14)  echo "12.5" ;;
        laptop_10)  echo "10.0" ;;
        *)          echo "11.0" ;;
    esac
}

get_gaps() {
    case "${UKE_FORM_FACTOR}" in
        desktop)    echo "3:6:2" ;;   # gaps_in:gaps_out:border
        laptop_14)  echo "2:4:2" ;;
        laptop_10)  echo "1:2:1" ;;
        *)          echo "2:4:2" ;;
    esac
}

get_padding() {
    case "${UKE_FORM_FACTOR}" in
        desktop)    echo "6" ;;
        laptop_14)  echo "4" ;;
        laptop_10)  echo "2" ;;
        *)          echo "4" ;;
    esac
}

# ==============================================================================
# Generate Hyprland Hardware Config
# ==============================================================================
gen_hyprland() {
    if [[ "${UKE_OS}" != "arch" ]] && [[ "${UKE_OS}" != "linux" ]]; then
        info "Skipping Hyprland config (OS=${UKE_OS})"
        return 0
    fi
    
    local gaps padding
    IFS=':' read -r gaps_in gaps_out border_size <<< "$(get_gaps)"
    padding=$(get_padding)
    
    {
        gen_header "conf"
        
        echo "# GPU Configuration (${UKE_GPU})"
        case "${UKE_GPU}" in
            nvidia)
                cat << 'NVIDIA'
env = LIBVA_DRIVER_NAME,nvidia
env = XDG_SESSION_TYPE,wayland
env = GBM_BACKEND,nvidia-drm
env = __GLX_VENDOR_LIBRARY_NAME,nvidia
env = WLR_NO_HARDWARE_CURSORS,1
env = WLR_DRM_NO_ATOMIC,1

cursor {
    no_hardware_cursors = true
}
NVIDIA
                ;;
            amd)
                cat << 'AMD'
env = LIBVA_DRIVER_NAME,radeonsi
# AMD GPU - generally good Wayland support
AMD
                ;;
            *)
                echo "# Integrated GPU - no special settings needed"
                ;;
        esac
        echo ""
        
        echo "# Form Factor Configuration (${UKE_FORM_FACTOR})"
        cat << EOF
general {
    gaps_in = ${gaps_in}
    gaps_out = ${gaps_out}
    border_size = ${border_size}
}
EOF
        echo ""
        
        echo "# Monitor Configuration (${UKE_MONITORS} monitors)"
        case "${UKE_MONITORS}" in
            1)
                echo "# Single monitor - using defaults"
                ;;
            2)
                cat << 'DUAL'
# Dual monitor workspace assignment
# Adjust monitor names to match your setup (use: hyprctl monitors)
workspace = 1, monitor:eDP-1, default:true
workspace = 2, monitor:eDP-1
workspace = 3, monitor:eDP-1
workspace = 4, monitor:eDP-1
workspace = 5, monitor:eDP-1
workspace = 6, monitor:HDMI-A-1, default:true
workspace = 7, monitor:HDMI-A-1
workspace = 8, monitor:HDMI-A-1
workspace = 9, monitor:HDMI-A-1
workspace = 10, monitor:HDMI-A-1
DUAL
                ;;
            3)
                cat << 'TRIPLE'
# Triple monitor workspace assignment
# Adjust monitor names to match your setup (use: hyprctl monitors)
workspace = 1, monitor:eDP-1, default:true
workspace = 2, monitor:eDP-1
workspace = 3, monitor:eDP-1
workspace = 4, monitor:DP-1, default:true
workspace = 5, monitor:DP-1
workspace = 6, monitor:DP-1
workspace = 7, monitor:HDMI-A-1, default:true
workspace = 8, monitor:HDMI-A-1
workspace = 9, monitor:HDMI-A-1
workspace = 10, monitor:HDMI-A-1
TRIPLE
                ;;
        esac
        echo ""
        
        echo "# Keyboard Configuration (${UKE_KEYBOARD})"
        if [[ "${UKE_KEYBOARD}" == "mac" ]]; then
            cat << 'MACKB'
input {
    kb_options = altwin:swap_lalt_lwin
}
MACKB
        else
            echo "# Standard PC keyboard layout"
        fi
        
    } | write_file "${HYPR_DIR}/generated_hardware.conf"
}

# ==============================================================================
# Generate Yabai Hardware Config
# ==============================================================================
gen_yabai() {
    if [[ "${UKE_OS}" != "macos" ]]; then
        return 0
    fi
    
    local padding
    padding=$(get_padding)
    
    {
        gen_header "conf"
        
        echo "# Form Factor Configuration (${UKE_FORM_FACTOR})"
        cat << EOF
yabai -m config top_padding    ${padding}
yabai -m config bottom_padding ${padding}
yabai -m config left_padding   ${padding}
yabai -m config right_padding  ${padding}
yabai -m config window_gap     ${padding}
EOF
        echo ""
        
        echo "# Monitor Configuration (${UKE_MONITORS} monitors)"
        if [[ "${UKE_MONITORS}" != "1" ]]; then
            echo "# Multi-monitor mode - workspaces distributed across displays"
        else
            echo "# Single monitor mode"
        fi
        
    } | write_file "${YABAI_DIR}/generated_hardware.conf"
}

# ==============================================================================
# Generate WezTerm Hardware Config
# ==============================================================================
gen_wezterm() {
    local font_size front_end
    font_size=$(get_font_size)
    
    case "${UKE_GPU}" in
        nvidia) front_end="WebGpu" ;;
        *)      front_end="OpenGL" ;;
    esac
    
    {
        gen_header "lua"
        
        cat << EOF
local M = {}

-- Profile: ${UKE_FORM_FACTOR}
M.font_size = ${font_size}

-- OS Detection
M.os = "${UKE_OS}"
M.is_macos = M.os == "macos"
M.is_linux = M.os == "arch" or M.os == "linux"

-- Keyboard layout
M.keyboard = "${UKE_KEYBOARD}"

-- GPU settings
M.gpu = "${UKE_GPU}"
M.front_end = "${front_end}"

-- Monitor count
M.monitors = ${UKE_MONITORS}

return M
EOF
    } | write_file "${WEZTERM_DIR}/generated_hardware.lua"
}

# ==============================================================================
# Summary
# ==============================================================================
print_summary() {
    local font_size gaps
    font_size=$(get_font_size)
    IFS=':' read -r gaps_in gaps_out border_size <<< "$(get_gaps)"
    
    echo ""
    printf "%s━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━%s\n" "${C_DIM}" "${C_RESET}"
    printf "%sHardware Profile Summary:%s\n" "${C_BOLD}" "${C_RESET}"
    echo "  OS:          ${UKE_OS}"
    echo "  Form Factor: ${UKE_FORM_FACTOR}"
    echo "  Monitors:    ${UKE_MONITORS}"
    echo "  GPU:         ${UKE_GPU}"
    echo "  Keyboard:    ${UKE_KEYBOARD}"
    echo ""
    printf "%sComputed Settings:%s\n" "${C_BOLD}" "${C_RESET}"
    echo "  Font Size:   ${font_size}pt"
    echo "  Gaps:        in=${gaps_in} out=${gaps_out} border=${border_size}"
    printf "%s━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━%s\n" "${C_DIM}" "${C_RESET}"
}

# ==============================================================================
# Main
# ==============================================================================
main() {
    if [[ "${DRY_RUN}" == "--dry-run" ]]; then
        info "DRY RUN MODE - No files will be written"
        echo ""
    fi
    
    info "Loading profile from ${PROFILE_FILE}..."
    load_profile
    
    info "Generating hardware-specific configs (Ghost Files)..."
    echo ""
    
    # Generate all configs
    # [FIX] Removed gen_alacritty to prevent permission errors
    gen_hyprland
    gen_yabai
    gen_wezterm
    
    print_summary
    
    echo ""
    if [[ "${DRY_RUN}" != "--dry-run" ]]; then
        if [[ "${UKE_OS}" == "arch" ]] || [[ "${UKE_OS}" == "linux" ]]; then
            info "Reload Hyprland: hyprctl reload"
        else
            # [FIX] Service autostart logic: Start if not running, otherwise reload
            # Uses direct flags instead of 'brew services' which can fail
            if ! pgrep -x "yabai" >/dev/null; then
                info "Starting yabai..."
                yabai --start-service 2>/dev/null || true
            else
                info "Reloading yabai..."
                yabai --restart-service 2>/dev/null || true
            fi

            if ! pgrep -x "skhd" >/dev/null; then
                info "Starting skhd..."
                skhd --start-service 2>/dev/null || true
            else
                skhd --restart-service 2>/dev/null || true
            fi
        fi
    fi
}

main "$@"
