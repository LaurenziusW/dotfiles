
================================================================================
DIRECTORY STRUCTURE
================================================================================
uke
â”œâ”€â”€ .DS_Store
â”œâ”€â”€ .gitignore
â”œâ”€â”€ bin
â”‚Â Â  â”œâ”€â”€ uke
â”‚Â Â  â”œâ”€â”€ uke-autostart
â”‚Â Â  â”œâ”€â”€ uke-backup
â”‚Â Â  â”œâ”€â”€ uke-bunch
â”‚Â Â  â”œâ”€â”€ uke-debug
â”‚Â Â  â”œâ”€â”€ uke-doctor
â”‚Â Â  â”œâ”€â”€ uke-fix
â”‚Â Â  â”œâ”€â”€ uke-gather
â”‚Â Â  â”œâ”€â”€ uke-launch
â”‚Â Â  â”œâ”€â”€ uke-logs
â”‚Â Â  â”œâ”€â”€ uke-logs-script.sh
â”‚Â Â  â”œâ”€â”€ uke-scratchpad
â”‚Â Â  â”œâ”€â”€ uke-services
â”‚Â Â  â”œâ”€â”€ uke-session
â”‚Â Â  â”œâ”€â”€ uke-setup
â”‚Â Â  â”œâ”€â”€ uke-snapshot
â”‚Â Â  â”œâ”€â”€ uke-sticky
â”‚Â Â  â””â”€â”€ uke-update
â”œâ”€â”€ bunches
â”‚Â Â  â”œâ”€â”€ coding.sh
â”‚Â Â  â”œâ”€â”€ email.sh
â”‚Â Â  â”œâ”€â”€ guitar.sh
â”‚Â Â  â”œâ”€â”€ lib-os-detect.sh
â”‚Â Â  â”œâ”€â”€ reading.sh
â”‚Â Â  â””â”€â”€ study.sh
â”œâ”€â”€ config
â”‚Â Â  â””â”€â”€ registry.yaml
â”œâ”€â”€ docs
â”‚Â Â  â”œâ”€â”€ MACOS-SIP.md
â”‚Â Â  â”œâ”€â”€ PHILOSOPHY.md
â”‚Â Â  â””â”€â”€ README.md
â”œâ”€â”€ gen
â”‚Â Â  â”œâ”€â”€ .gitkeep
â”‚Â Â  â”œâ”€â”€ hyprland
â”‚Â Â  â”œâ”€â”€ skhd
â”‚Â Â  â”‚Â Â  â””â”€â”€ skhdrc
â”‚Â Â  â””â”€â”€ yabai
â”‚Â Â      â””â”€â”€ yabairc
â”œâ”€â”€ lib
â”‚Â Â  â”œâ”€â”€ core.sh
â”‚Â Â  â”œâ”€â”€ gen.sh
â”‚Â Â  â””â”€â”€ wm.sh
â”œâ”€â”€ scripts
â”‚Â Â  â”œâ”€â”€ apply_profile.sh
â”‚Â Â  â”œâ”€â”€ arch-check.sh
â”‚Â Â  â”œâ”€â”€ install.sh
â”‚Â Â  â”œâ”€â”€ keyd-setup.sh
â”‚Â Â  â”œâ”€â”€ manage_profile.sh
â”‚Â Â  â”œâ”€â”€ pacman-hooks
â”‚Â Â  â”‚Â Â  â””â”€â”€ uke-snapshot.hook
â”‚Â Â  â”œâ”€â”€ uke-detect.sh
â”‚Â Â  â””â”€â”€ uke-wipe.sh
â”œâ”€â”€ stow
â”‚Â Â  â”œâ”€â”€ .DS_Store
â”‚Â Â  â”œâ”€â”€ keyd
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ .config
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ .DS_Store
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ keyd
â”‚Â Â  â”‚Â Â  â”‚Â Â      â””â”€â”€ default.conf
â”‚Â Â  â”‚Â Â  â””â”€â”€ .DS_Store
â”‚Â Â  â”œâ”€â”€ nvim
â”‚Â Â  â”‚Â Â  â””â”€â”€ .config
â”‚Â Â  â”‚Â Â      â””â”€â”€ nvim
â”‚Â Â  â”‚Â Â          â””â”€â”€ init.lua
â”‚Â Â  â”œâ”€â”€ tmux
â”‚Â Â  â”‚Â Â  â””â”€â”€ .tmux.conf
â”‚Â Â  â”œâ”€â”€ wezterm
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ .config
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ .DS_Store
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ wezterm
â”‚Â Â  â”‚Â Â  â”‚Â Â      â””â”€â”€ wezterm.lua
â”‚Â Â  â”‚Â Â  â””â”€â”€ .DS_Store
â”‚Â Â  â”œâ”€â”€ zathura
â”‚Â Â  â”‚Â Â  â””â”€â”€ .config
â”‚Â Â  â”‚Â Â      â””â”€â”€ zathura
â”‚Â Â  â”‚Â Â          â””â”€â”€ zathurarc
â”‚Â Â  â””â”€â”€ zsh
â”‚Â Â      â”œâ”€â”€ .zprofile
â”‚Â Â      â””â”€â”€ .zshrc
â””â”€â”€ templates
    â””â”€â”€ .gitkeep

28 directories, 57 files



################################################################################
FILE PATH: uke/bunches/guitar.sh
################################################################################

#!/usr/bin/env bash
# ==============================================================================
# BUNCH: Guitar
# Description: Guitar practice environment
# ==============================================================================

source "$(dirname "$0")/lib-os-detect.sh"

BUNCH_NAME="guitar"
PRIMARY_SPACE=7

echo "ðŸš€ Starting bunch: $BUNCH_NAME"

# Switch to media workspace
$WM_FOCUS_SPACE $PRIMARY_SPACE

# Launch applications
launch_app "spotify"
sleep 1
launch_app "browser"

echo "âœ… Bunch '$BUNCH_NAME' ready!"
echo "   â†’ Workspace: $PRIMARY_SPACE (Media)"



################################################################################
FILE PATH: uke/bunches/email.sh
################################################################################

#!/usr/bin/env bash
# ==============================================================================
# BUNCH: Email
# Description: Communication and admin environment
# ==============================================================================

source "$(dirname "$0")/lib-os-detect.sh"

BUNCH_NAME="email"
PRIMARY_SPACE=9

echo "ðŸš€ Starting bunch: $BUNCH_NAME"

# Switch to communication workspace
$WM_FOCUS_SPACE $PRIMARY_SPACE

# Launch applications
launch_app "mail"
sleep 1
launch_app "slack"
sleep 1
launch_app "browser"

echo "âœ… Bunch '$BUNCH_NAME' ready!"
echo "   â†’ Workspace: $PRIMARY_SPACE (Communication)"



################################################################################
FILE PATH: uke/bunches/study.sh
################################################################################

#!/usr/bin/env bash
# ==============================================================================
# BUNCH: Study - Note-taking and Research
# ==============================================================================
source "$(dirname "$0")/lib-os-detect.sh"

BUNCH_NAME="study"
PRIMARY_SPACE=2

echo "ðŸš€ Starting bunch: $BUNCH_NAME"

$WM_FOCUS_SPACE $PRIMARY_SPACE

launch_app "obsidian"
sleep 1
launch_app "browser"
sleep 1
launch_app "terminal"
sleep 0.5
launch_app "pdf"

notify "UKE Bunch" "$BUNCH_NAME environment ready"
echo "âœ… Bunch '$BUNCH_NAME' ready â†’ Workspace $PRIMARY_SPACE"



################################################################################
FILE PATH: uke/bunches/coding.sh
################################################################################

#!/usr/bin/env bash
# ==============================================================================
# BUNCH: Coding - Development Environment
# ==============================================================================
source "$(dirname "$0")/lib-os-detect.sh"

BUNCH_NAME="coding"
PRIMARY_SPACE=3

echo "ðŸš€ Starting bunch: $BUNCH_NAME"

$WM_FOCUS_SPACE $PRIMARY_SPACE

launch_app "terminal"
sleep 1
launch_app "code"
sleep 1
launch_app "browser"

notify "UKE Bunch" "$BUNCH_NAME environment ready"
echo "âœ… Bunch '$BUNCH_NAME' ready â†’ Workspace $PRIMARY_SPACE"



################################################################################
FILE PATH: uke/bunches/lib-os-detect.sh
################################################################################

#!/usr/bin/env bash
# ==============================================================================
# UKE OS Detection Library v7.0
# ==============================================================================
# Provides cross-platform helpers for bunches and scripts
# Source this in any bunch script: source "$(dirname "$0")/lib-os-detect.sh"
# ==============================================================================

# ==============================================================================
# OS Detection
# ==============================================================================
detect_os() {
    case "$(uname -s)" in
        Darwin*) echo "macos" ;;
        Linux*)  echo "linux" ;;
        *)       echo "unknown" ;;
    esac
}

OS_TYPE=$(detect_os)

# ==============================================================================
# Window Manager Commands
# ==============================================================================
setup_os_commands() {
    if [ "$OS_TYPE" = "macos" ]; then
        WM_FOCUS_SPACE="yabai -m space --focus"
        WM_SEND_WINDOW="yabai -m window --space"
        WM_QUERY_SPACE="yabai -m query --spaces --space"
    else
        WM_FOCUS_SPACE="hyprctl dispatch workspace"
        WM_SEND_WINDOW="hyprctl dispatch movetoworkspace"
        WM_QUERY_SPACE="hyprctl activeworkspace"
    fi
    export WM_FOCUS_SPACE WM_SEND_WINDOW WM_QUERY_SPACE
}

# ==============================================================================
# App Name Mapping
# ==============================================================================
get_app_command() {
    local app_key="$1"
    
    case "$app_key" in
        browser|brave)
            [ "$OS_TYPE" = "macos" ] && echo "Brave Browser" || echo "brave" ;;
        safari)
            [ "$OS_TYPE" = "macos" ] && echo "Safari" || echo "" ;;
        firefox)
            echo "firefox" ;;
        notes|obsidian)
            [ "$OS_TYPE" = "macos" ] && echo "Obsidian" || echo "obsidian" ;;
        terminal|wezterm)
            [ "$OS_TYPE" = "macos" ] && echo "WezTerm" || echo "wezterm" ;;
        code|vscode)
            [ "$OS_TYPE" = "macos" ] && echo "Visual Studio Code" || echo "code" ;;
        music|spotify)
            [ "$OS_TYPE" = "macos" ] && echo "Spotify" || echo "spotify" ;;
        pdf|preview)
            [ "$OS_TYPE" = "macos" ] && echo "Preview" || echo "zathura" ;;
        slack)
            [ "$OS_TYPE" = "macos" ] && echo "Slack" || echo "slack" ;;
        discord)
            [ "$OS_TYPE" = "macos" ] && echo "Discord" || echo "discord" ;;
        mail)
            [ "$OS_TYPE" = "macos" ] && echo "Mail" || echo "thunderbird" ;;
        *)
            echo "$app_key" ;;
    esac
}

# ==============================================================================
# App Launcher
# ==============================================================================
launch_app() {
    local app_key="$1"
    local app_name
    app_name=$(get_app_command "$app_key")
    
    if [ -z "$app_name" ]; then
        echo "âš ï¸  App '$app_key' not available on $OS_TYPE"
        return 1
    fi
    
    if [ "$OS_TYPE" = "macos" ]; then
        open -a "$app_name" 2>/dev/null &
    else
        local cmd="${app_name,,}"
        if command -v "$cmd" &>/dev/null; then
            "$cmd" &>/dev/null &
        elif command -v "$app_name" &>/dev/null; then
            "$app_name" &>/dev/null &
        else
            echo "âš ï¸  Could not launch: $app_name"
            return 1
        fi
    fi
    
    echo "âœ“ Launched: $app_name"
}

# ==============================================================================
# Notification Helper
# ==============================================================================
notify() {
    local title="$1"
    local message="${2:-}"
    
    if [ "$OS_TYPE" = "macos" ]; then
        osascript -e "display notification \"$message\" with title \"$title\"" 2>/dev/null || true
    else
        command -v notify-send &>/dev/null && notify-send "$title" "$message" 2>/dev/null || true
    fi
}

# Auto-setup
setup_os_commands



################################################################################
FILE PATH: uke/bunches/reading.sh
################################################################################

#!/usr/bin/env bash
# ==============================================================================
# BUNCH: Reading
# Description: Focused reading environment
# ==============================================================================

source "$(dirname "$0")/lib-os-detect.sh"

BUNCH_NAME="reading"
PRIMARY_SPACE=5

echo "ðŸš€ Starting bunch: $BUNCH_NAME"

# Switch to documents workspace
$WM_FOCUS_SPACE $PRIMARY_SPACE

# Launch applications
launch_app "pdf"
sleep 1
launch_app "obsidian"

echo "âœ… Bunch '$BUNCH_NAME' ready!"
echo "   â†’ Workspace: $PRIMARY_SPACE (Documents)"



################################################################################
FILE PATH: uke/bin/uke-debug
################################################################################

#!/usr/bin/env bash
# ==============================================================================
# UKE Debug - Diagnostics
# ==============================================================================
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
export UKE_ROOT="${SCRIPT_DIR%/bin}"
source "$UKE_ROOT/lib/core.sh"
source "$UKE_ROOT/lib/wm.sh"

dump_system() {
    cat << EOF
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    UKE Debug Report                               â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Generated: $(date)

SYSTEM
â”€â”€â”€â”€â”€â”€
  OS:       $(uname -s) $(uname -r)
  Platform: $UKE_OS
  Shell:    $SHELL
  User:     $USER
  Home:     $HOME

UKE
â”€â”€â”€â”€
  Version:  $UKE_VERSION
  Root:     $UKE_ROOT
  Config:   $UKE_CONFIG
  Gen:      $UKE_GEN

DEPENDENCIES
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
EOF

    for cmd in stow jq git yabai skhd hyprctl borders; do
        if command -v $cmd &>/dev/null; then
            printf "  âœ“ %-12s %s\n" "$cmd:" "$(command -v $cmd)"
        else
            printf "  âœ— %-12s %s\n" "$cmd:" "not found"
        fi
    done

    cat << EOF

WINDOW MANAGER
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  Running:   $(wm_running && echo "yes" || echo "no")
  Workspace: $(wm_current_workspace 2>/dev/null || echo "unknown")

FILES
â”€â”€â”€â”€â”€
  Registry: $(ls -lh "$UKE_CONFIG/registry.yaml" 2>/dev/null | awk '{print $5, $6, $7, $8}' || echo "missing")
EOF

    if is_macos; then
        echo "  skhdrc:   $(ls -lh "$UKE_GEN/skhd/skhdrc" 2>/dev/null | awk '{print $5, $6, $7, $8}' || echo "missing")"
        echo "  yabairc:  $(ls -lh "$UKE_GEN/yabai/yabairc" 2>/dev/null | awk '{print $5, $6, $7, $8}' || echo "missing")"
    else
        echo "  hyprland: $(ls -lh "$UKE_GEN/hyprland/hyprland.conf" 2>/dev/null | awk '{print $5, $6, $7, $8}' || echo "missing")"
    fi

    cat << EOF

RECENT LOGS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
EOF
    tail -n 15 "$UKE_LOG_FILE" 2>/dev/null || echo "  No logs available"
    
    echo ""
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
}

trace_key() {
    local key="$1"
    log_info "Tracing keybinding: $key"
    
    echo ""
    echo "In generated skhd config:"
    grep -n "$key" "$UKE_GEN/skhd/skhdrc" 2>/dev/null || echo "  Not found"
}

case "${1:-dump}" in
    dump)  dump_system ;;
    trace) trace_key "${2:-h}" ;;
    *)     echo "Usage: uke-debug [dump|trace <key>]" ;;
esac



################################################################################
FILE PATH: uke/bin/uke-backup
################################################################################

#!/usr/bin/env bash
# ==============================================================================
# UKE Backup v7.2 - Comprehensive System State Backup
# ==============================================================================
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
export UKE_ROOT="${SCRIPT_DIR%/bin}"
source "$UKE_ROOT/lib/core.sh"

BACKUP_DIR="${XDG_DATA_HOME:-$HOME/.local/share}/uke/backups"

create_backup() {
    local full="${1:-false}"
    local timestamp=$(date +%Y-%m-%d_%H%M%S)
    local backup_path="$BACKUP_DIR/$timestamp"
    
    mkdir -p "$backup_path"/{config,gen,ghost,stow,packages}
    
    echo ""
    printf "%sâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—%s\n" "$C_CYAN" "$C_RESET"
    printf "%sâ•‘%s        UKE Backup                    %sâ•‘%s\n" "$C_CYAN" "$C_BOLD" "$C_CYAN" "$C_RESET"
    printf "%sâ•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•%s\n" "$C_CYAN" "$C_RESET"
    echo ""
    info "Creating backup: $timestamp"
    echo ""
    
    # Always: UKE configs
    [[ -f "$UKE_ROOT/config/registry.yaml" ]] && cp "$UKE_ROOT/config/registry.yaml" "$backup_path/config/"
    [[ -f "$UKE_STATE/machine.profile" ]] && cp "$UKE_STATE/machine.profile" "$backup_path/config/"
    ok "Config files"
    
    # Always: Generated configs
    cp -r "$UKE_ROOT/gen"/* "$backup_path/gen/" 2>/dev/null || true
    ok "Generated configs"
    
    # Always: Ghost files
    for f in "$HOME/.config"/*/generated_*; do
        [[ -f "$f" ]] && cp "$f" "$backup_path/ghost/" 2>/dev/null
    done
    ok "Ghost files"
    
    if [[ "$full" == "true" ]]; then
        # Full: Stow packages
        cp -r "$UKE_ROOT/stow"/* "$backup_path/stow/" 2>/dev/null || true
        ok "Stow packages"
        
        # Full: Package lists
        pacman -Qe > "$backup_path/packages/official.txt" 2>/dev/null || true
        pacman -Qm > "$backup_path/packages/aur.txt" 2>/dev/null || true
        systemctl list-unit-files --state=enabled > "$backup_path/packages/services.txt" 2>/dev/null || true
        ok "Package lists"
    fi
    
    # Create manifest
    cat > "$backup_path/manifest.yaml" << EOF
version: "$UKE_VERSION"
timestamp: "$timestamp"
full: $full
hostname: "$(hostname)"
user: "$USER"
EOF
    
    # Update latest symlink
    rm -f "$BACKUP_DIR/latest"
    ln -sf "$timestamp" "$BACKUP_DIR/latest"
    
    echo ""
    ok "Backup created: $backup_path"
    echo "  Size: $(du -sh "$backup_path" | cut -f1)"
}

list_backups() {
    echo ""
    printf "%s=== Available Backups ===%s\n" "$C_BOLD" "$C_RESET"
    echo ""
    
    if [[ ! -d "$BACKUP_DIR" ]]; then
        warn "No backups found"
        return
    fi
    
    for dir in "$BACKUP_DIR"/*/; do
        [[ -d "$dir" ]] || continue
        local name=$(basename "$dir")
        [[ "$name" == "latest" ]] && continue
        
        local size=$(du -sh "$dir" 2>/dev/null | cut -f1)
        local full="config"
        [[ -d "$dir/packages" ]] && [[ -f "$dir/packages/official.txt" ]] && full="full"
        
        if [[ -L "$BACKUP_DIR/latest" ]] && [[ "$(readlink "$BACKUP_DIR/latest")" == "$name" ]]; then
            printf "  %sâ†’%s %-20s %s (%s)\n" "$C_GREEN" "$C_RESET" "$name" "$size" "$full"
        else
            printf "    %-20s %s (%s)\n" "$name" "$size" "$full"
        fi
    done
}

restore_backup() {
    local name="$1"
    local backup_path="$BACKUP_DIR/$name"
    
    if [[ ! -d "$backup_path" ]]; then
        fail "Backup not found: $name"
        exit 1
    fi
    
    echo ""
    printf "%sâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—%s\n" "$C_YELLOW" "$C_RESET"
    printf "%sâ•‘%s        UKE Restore                   %sâ•‘%s\n" "$C_YELLOW" "$C_BOLD" "$C_YELLOW" "$C_RESET"
    printf "%sâ•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•%s\n" "$C_YELLOW" "$C_RESET"
    echo ""
    
    info "Restoring from: $name"
    cat "$backup_path/manifest.yaml" 2>/dev/null || true
    echo ""
    
    read -p "Continue? [y/N] " -n 1 -r
    echo ""
    [[ ! $REPLY =~ ^[Yy]$ ]] && exit 0
    
    # Backup current state first
    info "Backing up current state..."
    create_backup false
    
    # Restore configs
    info "Restoring configs..."
    [[ -f "$backup_path/config/registry.yaml" ]] && cp "$backup_path/config/registry.yaml" "$UKE_ROOT/config/"
    [[ -f "$backup_path/config/machine.profile" ]] && cp "$backup_path/config/machine.profile" "$UKE_STATE/"
    
    # Restore ghost files
    for f in "$backup_path/ghost"/*; do
        [[ -f "$f" ]] || continue
        local fname=$(basename "$f")
        local target_dir=$(echo "$fname" | sed 's/_generated.*//')
        mkdir -p "$HOME/.config/$target_dir"
        cp "$f" "$HOME/.config/$target_dir/generated_${fname#*_generated}"
    done
    
    # Regenerate
    info "Regenerating configs..."
    "$UKE_ROOT/lib/gen.sh" all
    
    ok "Restore complete!"
    info "Run 'uke reload' to apply changes"
}

show_diff() {
    local name="$1"
    local backup_path="$BACKUP_DIR/$name"
    
    if [[ ! -d "$backup_path" ]]; then
        fail "Backup not found: $name"
        exit 1
    fi
    
    echo ""
    printf "%s=== Diff: Current vs %s ===%s\n" "$C_BOLD" "$name" "$C_RESET"
    
    if [[ -f "$backup_path/config/registry.yaml" ]] && [[ -f "$UKE_ROOT/config/registry.yaml" ]]; then
        diff --color=auto "$backup_path/config/registry.yaml" "$UKE_ROOT/config/registry.yaml" || true
    fi
}

case "${1:-}" in
    ""|create)    create_backup false ;;
    --full)       create_backup true ;;
    --config-only) create_backup false ;;
    --list|list)  list_backups ;;
    --restore)    restore_backup "${2:-latest}" ;;
    --diff)       show_diff "${2:-latest}" ;;
    -h|--help)
        echo "Usage: uke-backup [option]"
        echo "Options:"
        echo "  (none)      Create config backup"
        echo "  --full      Include package lists"
        echo "  --list      List available backups"
        echo "  --restore   Restore from backup"
        echo "  --diff      Show diff with backup"
        ;;
    *)            fail "Unknown option: $1" ;;
esac



################################################################################
FILE PATH: uke/bin/uke-scratchpad
################################################################################

#!/usr/bin/env bash
# ==============================================================================
# UKE Scratchpad - Dropdown/Toggle Windows
# ==============================================================================
# Toggles scratchpad windows - special floating windows that appear on demand.
#
# Usage: uke-scratchpad <name>
# Names: terminal, notes, music, calc
# ==============================================================================
set -euo pipefail

# [FIX] Bash Version Auto-Detection & Reload
# macOS ships with Bash 3.2. This script requires Bash 4.0+ (associative arrays).
if [ -z "${BASH_VERSINFO}" ] || [ "${BASH_VERSINFO[0]}" -lt 4 ]; then
    if [ -x /opt/homebrew/bin/bash ]; then
        exec /opt/homebrew/bin/bash "$0" "$@"
    elif [ -x /usr/local/bin/bash ]; then
        exec /usr/local/bin/bash "$0" "$@"
    else
        echo "Error: Bash 4.0+ required (found ${BASH_VERSION})."
        echo "Please install bash via homebrew: brew install bash"
        exit 1
    fi
fi

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
export UKE_ROOT="${SCRIPT_DIR%/bin}"

source "$UKE_ROOT/lib/core.sh"

NAME="${1:-terminal}"

# ==============================================================================
# Scratchpad Configuration
# ==============================================================================
declare -A SCRATCH_APP
declare -A SCRATCH_CLASS

# macOS app names
SCRATCH_APP[terminal_macos]="WezTerm"
SCRATCH_APP[notes_macos]="Obsidian"
SCRATCH_APP[music_macos]="Spotify"
SCRATCH_APP[calc_macos]="Calculator"

# Linux app names
SCRATCH_APP[terminal_linux]="wezterm"
SCRATCH_APP[notes_linux]="obsidian"
SCRATCH_APP[music_linux]="spotify"
SCRATCH_APP[calc_linux]="gnome-calculator"

# Window classes for matching (Linux)
SCRATCH_CLASS[terminal]="wezterm"
SCRATCH_CLASS[notes]="obsidian"
SCRATCH_CLASS[music]="spotify"
SCRATCH_CLASS[calc]="gnome-calculator"

# ==============================================================================
# Get App for Platform
# ==============================================================================
get_scratch_app() {
    local name="$1"
    local key
    is_macos && key="${name}_macos" || key="${name}_linux"
    echo "${SCRATCH_APP[$key]:-}"
}

# ==============================================================================
# macOS Scratchpad (using yabai)
# ==============================================================================
scratchpad_macos() {
    local name="$1"
    local app
    app=$(get_scratch_app "$name")
    
    if [[ -z "$app" ]]; then
        log_fatal "Unknown scratchpad: $name"
    fi
    
    # Check if app window exists
    local window_id
    window_id=$(yabai -m query --windows | jq -r ".[] | select(.app == \"$app\") | .id" | head -1)
    
    if [[ -n "$window_id" ]]; then
        # Window exists - check if focused
        local focused
        focused=$(yabai -m query --windows --window | jq -r '.id' 2>/dev/null || echo "")
        
        if [[ "$focused" == "$window_id" ]]; then
            # Already focused - hide it (send to scratchpad space or minimize)
            yabai -m window "$window_id" --space 11 2>/dev/null || yabai -m window "$window_id" --minimize
            log_info "Hidden: $app"
        else
            # Not focused - bring to current space and focus
            yabai -m window "$window_id" --space mouse
            yabai -m window "$window_id" --focus
            yabai -m window "$window_id" --toggle float 2>/dev/null || true
            log_info "Focused: $app"
        fi
    else
        # Window doesn't exist - launch app
        open -a "$app"
        log_info "Launched: $app"
        
        # Wait and configure
        sleep 0.5
        window_id=$(yabai -m query --windows | jq -r ".[] | select(.app == \"$app\") | .id" | head -1)
        if [[ -n "$window_id" ]]; then
            yabai -m window "$window_id" --toggle float
            # Center and resize based on scratchpad type
            case "$name" in
                terminal)
                    yabai -m window "$window_id" --resize abs:1200:400
                    yabai -m window "$window_id" --move abs:100:50
                    ;;
                notes)
                    yabai -m window "$window_id" --resize abs:1000:800
                    yabai -m window "$window_id" --grid 8:8:1:1:6:6
                    ;;
                music)
                    yabai -m window "$window_id" --resize abs:800:600
                    yabai -m window "$window_id" --grid 8:8:2:2:4:4
                    ;;
                calc)
                    yabai -m window "$window_id" --grid 8:8:3:3:2:2
                    ;;
            esac
        fi
    fi
}

# ==============================================================================
# Linux Scratchpad (using Hyprland special workspaces)
# ==============================================================================
scratchpad_linux() {
    local name="$1"
    local app class
    app=$(get_scratch_app "$name")
    class="${SCRATCH_CLASS[$name]:-}"
    
    if [[ -z "$app" ]]; then
        log_fatal "Unknown scratchpad: $name"
    fi
    
    # Use Hyprland special workspaces
    local special_ws="special:$name"
    
    # Check if window exists in special workspace
    local window_count
    window_count=$(hyprctl clients -j | jq "[.[] | select(.workspace.name == \"$special_ws\")] | length")
    
    if [[ "$window_count" -gt 0 ]]; then
        # Toggle visibility
        hyprctl dispatch togglespecialworkspace "$name"
    else
        # Launch app into special workspace
        hyprctl dispatch exec "[workspace $special_ws] $app"
        sleep 0.3
        hyprctl dispatch togglespecialworkspace "$name"
    fi
    
    log_info "Toggled scratchpad: $name"
}

# ==============================================================================
# Main
# ==============================================================================
case "$NAME" in
    terminal|notes|music|calc)
        is_macos && scratchpad_macos "$NAME" || scratchpad_linux "$NAME"
        ;;
    list)
        echo "Available scratchpads: terminal, notes, music, calc"
        ;;
    *)
        log_fatal "Unknown scratchpad: $NAME (use: terminal|notes|music|calc)"
        ;;
esac



################################################################################
FILE PATH: uke/bin/uke-logs
################################################################################

#!/usr/bin/env bash
# ==============================================================================
# UKE Logs - Live log viewer for all components
# ==============================================================================
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
export UKE_ROOT="${SCRIPT_DIR%/bin}"
source "$UKE_ROOT/lib/core.sh"

show_help() {
    cat << 'EOF'
UKE Logs - Live log viewer

Usage: uke-logs [component]

Components:
  uke       UKE internal logs
  yabai     Yabai window manager (macOS)
  skhd      skhd hotkey daemon (macOS)
  hyprland  Hyprland compositor (Linux)
  all       All logs combined (requires multitail)

Examples:
  uke-logs uke          # Tail UKE logs
  uke-logs yabai        # Tail yabai logs
  uke-logs all          # Combined view
EOF
}

tail_log() {
    local name="$1" path="$2"
    [[ -f "$path" ]] || { echo "No $name log at $path"; return 1; }
    echo "Tailing: $path (Ctrl+C to stop)"
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    tail -f "$path"
}

tail_all() {
    if command -v multitail &>/dev/null; then
        local logs=()
        [[ -f "$HOME/.local/state/uke/uke.log" ]] && logs+=("$HOME/.local/state/uke/uke.log")
        if is_macos; then
            local y=$(ls /tmp/yabai_*.err.log 2>/dev/null | head -1)
            local s=$(ls /tmp/skhd_*.err.log 2>/dev/null | head -1)
            [[ -f "$y" ]] && logs+=("$y")
            [[ -f "$s" ]] && logs+=("$s")
        else
            [[ -f "$HOME/.local/share/hyprland/hyprland.log" ]] && logs+=("$HOME/.local/share/hyprland/hyprland.log")
        fi
        multitail "${logs[@]}"
    else
        echo "Install 'multitail' for combined view:"
        echo "  macOS: brew install multitail"
        echo "  Linux: sudo pacman -S multitail"
        echo ""
        echo "Or tail individually: uke-logs uke|yabai|skhd|hyprland"
    fi
}

case "${1:-help}" in
    uke)      tail_log "UKE" "$HOME/.local/state/uke/uke.log" ;;
    yabai)    tail_log "yabai" "$(ls /tmp/yabai_*.err.log 2>/dev/null | head -1)" ;;
    skhd)     tail_log "skhd" "$(ls /tmp/skhd_*.err.log 2>/dev/null | head -1)" ;;
    hyprland) tail_log "Hyprland" "$HOME/.local/share/hyprland/hyprland.log" ;;
    all)      tail_all ;;
    help|--help|-h) show_help ;;
    *)        echo "Unknown: $1"; show_help; exit 1 ;;
esac



################################################################################
FILE PATH: uke/bin/uke-autostart
################################################################################

#!/usr/bin/env bash
# ==============================================================================
# UKE Auto-start v7.1 - Hyprland Launcher with Fallback
# ==============================================================================
# Starts Hyprland with proper error handling and fallback to terminal.
# This script is called from .zprofile on TTY1 login.
#
# Features:
#   - Pre-flight checks for Hyprland
#   - Hardware config generation if missing
#   - Crash recovery with terminal fallback
#   - Logging for troubleshooting
#
# Usage:
#   uke-autostart          # Normal start
#   uke-autostart --debug  # Start with extra logging
#   uke-autostart --skip   # Skip to terminal
# ==============================================================================
set -uo pipefail
# [FIX] Removed -e (errexit) to prevent unexpected exits causing login loop
# Errors are handled explicitly in the script

# ==============================================================================
# Configuration
# ==============================================================================
LOG_FILE="${XDG_STATE_HOME:-$HOME/.local/state}/uke/autostart.log"
CRASH_COUNT_FILE="${XDG_STATE_HOME:-$HOME/.local/state}/uke/crash_count"
MAX_CRASHES=3
CRASH_RESET_HOURS=1

UKE_ROOT="${UKE_ROOT:-$HOME/dotfiles/uke}"

# Colors (for terminal output before Hyprland)
RED=$'\e[31m' GREEN=$'\e[32m' YELLOW=$'\e[33m' BLUE=$'\e[34m'
BOLD=$'\e[1m' DIM=$'\e[2m' RESET=$'\e[0m'

# ==============================================================================
# Logging
# ==============================================================================
log() {
    local level="$1"
    shift
    local msg="[$(date '+%Y-%m-%d %H:%M:%S')] [$level] $*"
    echo "$msg" >> "$LOG_FILE"
    [[ "$level" == "ERROR" ]] && echo "${RED}$msg${RESET}" >&2
    [[ "$level" == "INFO" ]] && echo "${BLUE}$msg${RESET}"
    [[ "$level" == "WARN" ]] && echo "${YELLOW}$msg${RESET}"
}

# ==============================================================================
# Pre-flight Checks
# ==============================================================================
preflight_checks() {
    log "INFO" "Running pre-flight checks..."
    
    # Check if Hyprland is installed
    if ! command -v Hyprland &>/dev/null; then
        log "ERROR" "Hyprland not found! Install with: sudo pacman -S hyprland"
        return 1
    fi
    
    # Check for required directories
    mkdir -p "$HOME/.config/hypr"
    mkdir -p "${XDG_STATE_HOME:-$HOME/.local/state}/uke"
    
    # Check for Hyprland config
    if [[ ! -f "$HOME/.config/hypr/hyprland.conf" ]]; then
        log "WARN" "Hyprland config not found, checking UKE..."
        
        if [[ -f "$UKE_ROOT/gen/hyprland/hyprland.conf" ]]; then
            ln -sf "$UKE_ROOT/gen/hyprland/hyprland.conf" "$HOME/.config/hypr/hyprland.conf"
            log "INFO" "Linked UKE hyprland.conf"
        else
            log "ERROR" "No Hyprland config found! Run: uke gen"
            return 1
        fi
    fi
    
    # Check/create hardware ghost file
    if [[ ! -f "$HOME/.config/hypr/generated_hardware.conf" ]]; then
        log "WARN" "Hardware config missing, creating placeholder..."
        cat > "$HOME/.config/hypr/generated_hardware.conf" << 'EOF'
# Placeholder - run 'uke profile' then 'uke apply' to generate real config
general {
    gaps_in = 2
    gaps_out = 4
    border_size = 2
}
EOF
        log "INFO" "Created placeholder hardware config"
    fi
    
    log "INFO" "Pre-flight checks passed"
    return 0
}

# ==============================================================================
# Crash Counter
# ==============================================================================
check_crash_count() {
    local count=0
    local last_crash=0
    
    if [[ -f "$CRASH_COUNT_FILE" ]]; then
        read -r count last_crash < "$CRASH_COUNT_FILE" 2>/dev/null || true
        
        # Reset counter if enough time has passed
        local now=$(date +%s)
        local hours_ago=$((now - 3600 * CRASH_RESET_HOURS))
        
        if [[ "$last_crash" -lt "$hours_ago" ]]; then
            count=0
            log "INFO" "Crash counter reset (more than $CRASH_RESET_HOURS hour since last crash)"
        fi
    fi
    
    echo "$count"
}

increment_crash_count() {
    local count
    count=$(check_crash_count)
    count=$((count + 1))
    echo "$count $(date +%s)" > "$CRASH_COUNT_FILE"
    log "WARN" "Crash count: $count"
    echo "$count"
}

reset_crash_count() {
    echo "0 $(date +%s)" > "$CRASH_COUNT_FILE"
}

# ==============================================================================
# Terminal Fallback - ALWAYS starts a shell, never exits
# ==============================================================================
fallback_terminal() {
    local reason="${1:-Unknown error}"
    
    clear
    echo ""
    echo "${RED}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${RESET}"
    echo "${RED}â•‘${RESET}${BOLD}           UKE Hyprland Auto-start Failed                    ${RESET}${RED}â•‘${RESET}"
    echo "${RED}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${RESET}"
    echo ""
    echo "${YELLOW}Reason:${RESET} $reason"
    echo ""
    echo "${BLUE}Options:${RESET}"
    echo "  1. Try starting Hyprland manually:  ${DIM}Hyprland${RESET}"
    echo "  2. Check logs:                      ${DIM}cat $LOG_FILE${RESET}"
    echo "  3. Run diagnostics:                 ${DIM}uke doctor${RESET}"
    echo "  4. Reset crash counter:             ${DIM}rm $CRASH_COUNT_FILE${RESET}"
    echo "  5. Regenerate configs:              ${DIM}uke gen && uke apply${RESET}"
    echo "  6. Disable autostart:               ${DIM}touch ~/.no-hyprland${RESET}"
    echo ""
    echo "${DIM}You are now in a terminal. Type 'exit' to logout.${RESET}"
    echo ""
    
    log "INFO" "Dropped to fallback terminal"
    
    # [FIX] Try multiple shells, NEVER exit without starting something
    if [[ -n "${SHELL:-}" ]] && [[ -x "$SHELL" ]]; then
        exec "$SHELL"
    elif [[ -x /bin/zsh ]]; then
        exec /bin/zsh
    elif [[ -x /bin/bash ]]; then
        exec /bin/bash
    else
        exec /bin/sh
    fi
    
    # This should never be reached, but just in case
    /bin/sh
}

# ==============================================================================
# Start Hyprland
# ==============================================================================
start_hyprland() {
    local debug_mode="${1:-false}"
    
    log "INFO" "Starting Hyprland..."
    
    # Set environment variables
    export XDG_CURRENT_DESKTOP=Hyprland
    export XDG_SESSION_TYPE=wayland
    export XDG_SESSION_DESKTOP=Hyprland
    
    # QT Wayland
    export QT_QPA_PLATFORM=wayland
    export QT_WAYLAND_DISABLE_WINDOWDECORATION=1
    
    # GTK
    export GDK_BACKEND=wayland
    export MOZ_ENABLE_WAYLAND=1
    
    # Cursor
    export XCURSOR_SIZE=24
    
    if [[ "$debug_mode" == "true" ]]; then
        log "INFO" "Debug mode enabled"
        Hyprland 2>&1 | tee -a "$LOG_FILE"
        local exit_code=$?
    else
        Hyprland >> "$LOG_FILE" 2>&1
        local exit_code=$?
    fi
    
    return $exit_code
}

# ==============================================================================
# Main
# ==============================================================================
main() {
    local mode="${1:-normal}"
    
    # [FIX] Check for escape hatch first
    if [[ -f "$HOME/.no-hyprland" ]]; then
        echo "Hyprland autostart disabled (~/.no-hyprland exists)"
        echo "Remove the file to re-enable: rm ~/.no-hyprland"
        return 0  # Return, don't exit - let shell continue
    fi
    
    # Create log directory
    mkdir -p "$(dirname "$LOG_FILE")" 2>/dev/null || true
    
    log "INFO" "=== UKE Auto-start initiated ==="
    log "INFO" "Mode: $mode"
    
    # Handle skip mode
    if [[ "$mode" == "--skip" ]]; then
        fallback_terminal "Skipped by user request"
        # fallback_terminal uses exec, but just in case:
        return 0
    fi
    
    # Check crash count
    local crashes
    crashes=$(check_crash_count)
    
    if [[ "$crashes" -ge "$MAX_CRASHES" ]]; then
        log "ERROR" "Too many crashes ($crashes >= $MAX_CRASHES)"
        fallback_terminal "Too many consecutive crashes. Hyprland may be misconfigured."
        return 0  # Never exit 1
    fi
    
    # Run pre-flight checks
    if ! preflight_checks; then
        fallback_terminal "Pre-flight checks failed"
        return 0  # Never exit 1
    fi
    
    # Attempt to start Hyprland
    local debug_mode=false
    [[ "$mode" == "--debug" ]] && debug_mode=true
    
    if start_hyprland "$debug_mode"; then
        # Clean exit
        log "INFO" "Hyprland exited cleanly"
        reset_crash_count
    else
        # Crashed
        local new_count
        new_count=$(increment_crash_count)
        log "ERROR" "Hyprland crashed (exit code: $?)"
        
        if [[ "$new_count" -ge "$MAX_CRASHES" ]]; then
            fallback_terminal "Hyprland crashed $new_count times consecutively"
        else
            log "INFO" "Attempting restart ($new_count/$MAX_CRASHES)..."
            sleep 2
            main "$mode"  # Restart recursively, don't use exec
        fi
    fi
}

# [FIX] Trap errors to prevent logout
trap 'fallback_terminal "Unexpected error"' ERR

main "$@"



################################################################################
FILE PATH: uke/bin/uke-snapshot
################################################################################

#!/usr/bin/env bash
# ==============================================================================
# UKE Snapshot v7.2 - System Snapshot & Rollback
# ==============================================================================
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
export UKE_ROOT="${SCRIPT_DIR%/bin}"
source "$UKE_ROOT/lib/core.sh"

# Detect backend
detect_backend() {
    if findmnt -n -o FSTYPE / 2>/dev/null | grep -q btrfs; then
        if command -v snapper &>/dev/null; then
            echo "snapper"
        else
            echo "btrfs"
        fi
    elif command -v timeshift &>/dev/null; then
        echo "timeshift"
    else
        echo "uke-backup"
    fi
}

BACKEND=$(detect_backend)

create_snapshot() {
    local desc="${1:-UKE snapshot}"
    
    echo ""
    printf "%sâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—%s\n" "$C_CYAN" "$C_RESET"
    printf "%sâ•‘%s        UKE Snapshot                  %sâ•‘%s\n" "$C_CYAN" "$C_BOLD" "$C_CYAN" "$C_RESET"
    printf "%sâ•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•%s\n" "$C_CYAN" "$C_RESET"
    echo ""
    info "Backend: $BACKEND"
    info "Description: $desc"
    echo ""
    
    case "$BACKEND" in
        snapper)
            sudo snapper create -d "$desc" -c timeline
            ok "Snapper snapshot created"
            ;;
        btrfs)
            local snap_dir="/.snapshots/uke-$(date +%Y%m%d-%H%M%S)"
            sudo btrfs subvolume snapshot / "$snap_dir"
            echo "$desc" | sudo tee "$snap_dir/.description" >/dev/null
            ok "Btrfs snapshot: $snap_dir"
            ;;
        timeshift)
            sudo timeshift --create --comments "$desc" --scripted
            ok "Timeshift snapshot created"
            ;;
        uke-backup)
            info "No btrfs/snapper/timeshift - using uke-backup"
            "$UKE_ROOT/bin/uke-backup" --full
            ;;
    esac
}

list_snapshots() {
    echo ""
    printf "%s=== System Snapshots (%s) ===%s\n" "$C_BOLD" "$BACKEND" "$C_RESET"
    echo ""
    
    case "$BACKEND" in
        snapper)
            snapper list
            ;;
        btrfs)
            if [[ -d /.snapshots ]]; then
                ls -la /.snapshots/ 2>/dev/null | grep uke- || warn "No UKE snapshots"
            else
                warn "No snapshots directory"
            fi
            ;;
        timeshift)
            sudo timeshift --list
            ;;
        uke-backup)
            "$UKE_ROOT/bin/uke-backup" --list
            ;;
    esac
}

restore_snapshot() {
    local id="$1"
    
    warn "Snapshot restore requires manual intervention for safety"
    echo ""
    
    case "$BACKEND" in
        snapper)
            info "To restore snapper snapshot $id:"
            echo "  sudo snapper rollback $id"
            echo "  reboot"
            ;;
        btrfs)
            info "To restore btrfs snapshot:"
            echo "  1. Boot from live USB"
            echo "  2. Mount btrfs: mount /dev/sdX /mnt"
            echo "  3. mv /mnt/@ /mnt/@.broken"
            echo "  4. btrfs subvol snapshot /mnt/.snapshots/$id /mnt/@"
            echo "  5. reboot"
            ;;
        timeshift)
            info "To restore timeshift snapshot:"
            echo "  sudo timeshift --restore --snapshot '$id'"
            ;;
        uke-backup)
            "$UKE_ROOT/bin/uke-backup" --restore "$id"
            ;;
    esac
}

delete_snapshot() {
    local id="$1"
    
    case "$BACKEND" in
        snapper)
            sudo snapper delete "$id"
            ok "Deleted snapshot $id"
            ;;
        btrfs)
            sudo btrfs subvolume delete "/.snapshots/$id"
            ok "Deleted snapshot $id"
            ;;
        timeshift)
            sudo timeshift --delete --snapshot "$id"
            ok "Deleted snapshot $id"
            ;;
        uke-backup)
            rm -rf "${XDG_DATA_HOME:-$HOME/.local/share}/uke/backups/$id"
            ok "Deleted backup $id"
            ;;
    esac
}

auto_snapshot() {
    # For pacman hook - quiet mode
    create_snapshot "Pre-update $(date +%Y-%m-%d)" >/dev/null 2>&1
}

case "${1:-}" in
    create)       create_snapshot "${2:-Manual snapshot}" ;;
    list)         list_snapshots ;;
    restore)      restore_snapshot "${2:?Snapshot ID required}" ;;
    delete)       delete_snapshot "${2:?Snapshot ID required}" ;;
    auto)         auto_snapshot ;;
    backend)      echo "$BACKEND" ;;
    -h|--help)
        echo "Usage: uke-snapshot [command]"
        echo "Commands:"
        echo "  create [desc]   Create snapshot"
        echo "  list            List snapshots"
        echo "  restore <id>    Restore snapshot"
        echo "  delete <id>     Delete snapshot"
        echo "  auto            Auto-snapshot (for hooks)"
        echo "  backend         Show detected backend"
        echo ""
        echo "Detected backend: $BACKEND"
        ;;
    *)
        if [[ -n "$1" ]]; then
            # Assume it's a description
            create_snapshot "$1"
        else
            list_snapshots
        fi
        ;;
esac



################################################################################
FILE PATH: uke/bin/uke-fix
################################################################################

#!/usr/bin/env bash
# ==============================================================================
# UKE Fix v7.2 - Quick Fixes for Common Issues
# ==============================================================================
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
export UKE_ROOT="${SCRIPT_DIR%/bin}"
source "$UKE_ROOT/lib/core.sh"

fix_audio() {
    info "Restarting audio stack..."
    systemctl --user restart pipewire pipewire-pulse wireplumber 2>/dev/null
    sleep 1
    if pactl info &>/dev/null; then
        ok "Audio restored"
    else
        fail "Audio still not working. Try: systemctl --user status pipewire"
    fi
}

fix_display() {
    info "Reloading Hyprland..."
    if [[ -n "${HYPRLAND_INSTANCE_SIGNATURE:-}" ]]; then
        hyprctl reload
        ok "Hyprland reloaded"
    else
        warn "Hyprland not running"
    fi
}

fix_keys() {
    info "Restarting keyd..."
    sudo systemctl restart keyd
    ok "keyd restarted"
}

fix_network() {
    info "Restarting NetworkManager..."
    sudo systemctl restart NetworkManager
    sleep 2
    if nmcli general status &>/dev/null; then
        ok "Network restored"
    else
        warn "Network may need more time"
    fi
}

fix_bluetooth() {
    info "Restarting Bluetooth..."
    sudo systemctl restart bluetooth
    ok "Bluetooth restarted"
}

fix_waybar() {
    info "Restarting Waybar..."
    pkill -x waybar 2>/dev/null || true
    sleep 0.5
    waybar &>/dev/null &
    disown
    ok "Waybar restarted"
}

fix_clipboard() {
    info "Fixing clipboard..."
    pkill -x wl-copy 2>/dev/null || true
    pkill -x wl-paste 2>/dev/null || true
    cliphist wipe 2>/dev/null || true
    ok "Clipboard cleared"
}

fix_cache() {
    info "Cleaning system caches..."
    
    # Package cache
    if command -v paccache &>/dev/null; then
        sudo paccache -rk2 2>/dev/null
        ok "Package cache cleaned"
    fi
    
    # Journal logs (keep last 100MB)
    sudo journalctl --vacuum-size=100M 2>/dev/null
    ok "Journal logs trimmed"
    
    # User cache (be careful)
    local cache_size=$(du -sh ~/.cache 2>/dev/null | cut -f1)
    info "User cache: $cache_size (not auto-cleaned for safety)"
}

fix_permissions() {
    info "Fixing common permission issues..."
    
    # Fix ~/.local/bin permissions
    chmod -R u+x ~/.local/bin 2>/dev/null || true
    
    # Fix UKE permissions
    chmod -R u+x "$UKE_ROOT/bin" 2>/dev/null || true
    chmod -R u+x "$UKE_ROOT/scripts" 2>/dev/null || true
    
    ok "Permissions fixed"
}

fix_all() {
    echo ""
    printf "%sâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—%s\n" "$C_CYAN" "$C_RESET"
    printf "%sâ•‘%s        UKE Quick Fix                 %sâ•‘%s\n" "$C_CYAN" "$C_BOLD" "$C_CYAN" "$C_RESET"
    printf "%sâ•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•%s\n" "$C_CYAN" "$C_RESET"
    echo ""
    
    fix_audio
    fix_keys
    fix_waybar
    fix_display
    fix_permissions
    
    echo ""
    ok "All fixes applied"
}

auto_detect() {
    echo ""
    printf "%sâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—%s\n" "$C_CYAN" "$C_RESET"
    printf "%sâ•‘%s     UKE Auto-Detect & Fix            %sâ•‘%s\n" "$C_CYAN" "$C_BOLD" "$C_CYAN" "$C_RESET"
    printf "%sâ•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•%s\n" "$C_CYAN" "$C_RESET"
    echo ""
    
    local fixed=0
    
    # Check audio
    if ! pactl info &>/dev/null; then
        warn "Audio not working"
        fix_audio
        ((fixed++))
    else
        ok "Audio OK"
    fi
    
    # Check keyd
    if ! systemctl is-active keyd &>/dev/null; then
        warn "keyd not running"
        fix_keys
        ((fixed++))
    else
        ok "keyd OK"
    fi
    
    # Check waybar
    if ! pgrep -x waybar &>/dev/null; then
        warn "Waybar not running"
        fix_waybar
        ((fixed++))
    else
        ok "Waybar OK"
    fi
    
    # Check network
    if ! nmcli general status &>/dev/null; then
        warn "Network issues detected"
        fix_network
        ((fixed++))
    else
        ok "Network OK"
    fi
    
    # Check disk space
    local free=$(df -BG / | awk 'NR==2 {print $4}' | tr -d 'G')
    if [[ $free -lt 5 ]]; then
        warn "Low disk space: ${free}GB"
        info "Run: uke-fix --cache or uke-update --clean"
    else
        ok "Disk space OK (${free}GB free)"
    fi
    
    echo ""
    if [[ $fixed -eq 0 ]]; then
        ok "No issues detected!"
    else
        ok "Fixed $fixed issue(s)"
    fi
}

case "${1:-}" in
    "")           auto_detect ;;
    --audio)      fix_audio ;;
    --display)    fix_display ;;
    --keys)       fix_keys ;;
    --network)    fix_network ;;
    --bluetooth)  fix_bluetooth ;;
    --waybar)     fix_waybar ;;
    --clipboard)  fix_clipboard ;;
    --cache)      fix_cache ;;
    --permissions) fix_permissions ;;
    --all)        fix_all ;;
    -h|--help)
        echo "Usage: uke-fix [option]"
        echo "Options:"
        echo "  (none)       Auto-detect and fix issues"
        echo "  --audio      Restart PipeWire audio stack"
        echo "  --display    Reload Hyprland"
        echo "  --keys       Restart keyd"
        echo "  --network    Restart NetworkManager"
        echo "  --bluetooth  Restart Bluetooth"
        echo "  --waybar     Restart Waybar"
        echo "  --clipboard  Clear clipboard"
        echo "  --cache      Clean system caches"
        echo "  --permissions Fix script permissions"
        echo "  --all        Fix everything"
        ;;
    *)            fail "Unknown option: $1" ;;
esac



################################################################################
FILE PATH: uke/bin/uke-logs-script.sh
################################################################################

#!/usr/bin/env bash
# ==============================================================================
# uke-logs - UKE Diagnostic Logger
# ==============================================================================
# Sammelt alle Fehler und Logs fÃ¼r Debugging
#
# Verwendung: uke logs
# Speichert alle Logs in: ~/.local/state/uke/logs-$(date +%s)/
#
# Wird aufgerufen von: bin/uke-logs (symlink)
# ==============================================================================

set -e

script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$script_dir/../lib/core.sh"

log_dir="$UKE_STATE/logs-$(date +%s)"
mkdir -p "$log_dir"

log_info "ðŸ” Collecting UKE diagnostics..."
log_info "ðŸ“ Logs will be saved to: $log_dir"

# =============================================================================
# 1. SYSTEM INFO
# =============================================================================
log_info "Collecting system info..."
{
    echo "=== System Info ==="
    uname -a
    echo ""
    echo "=== OS Release ==="
    cat /etc/os-release 2>/dev/null || echo "N/A"
    echo ""
    echo "=== UKE Environment ==="
    env | grep -i uke || echo "No UKE vars set"
    echo ""
    echo "=== UKE Directories ==="
    echo "UKE_ROOT: $UKE_ROOT"
    echo "UKE_CONFIG: $UKE_CONFIG"
    echo "UKE_GEN: $UKE_GEN"
    echo "UKE_STATE: $UKE_STATE"
} > "$log_dir/01-system.log"

# =============================================================================
# 2. HYPRLAND
# =============================================================================
log_info "Collecting Hyprland diagnostics..."
{
    echo "=== Hyprland Version ==="
    hyprland --version 2>/dev/null || echo "Hyprland not found"
    
    echo ""
    echo "=== Config Paths ==="
    echo "XDG_CONFIG_HOME: ${XDG_CONFIG_HOME:-not set}"
    ls -la ~/.config/hypr/hyprland.conf 2>/dev/null || echo "~/.config/hypr/hyprland.conf not found"
    
    echo ""
    echo "=== Generated Config (first 60 lines) ==="
    head -n 60 ~/.config/hypr/hyprland.conf 2>/dev/null || echo "Not found"
    
    echo ""
    echo "=== Hyprland Journal Logs (last 100 lines) ==="
    journalctl --user-unit hyprland.service --no-pager -n 100 2>/dev/null || \
    journalctl --user --since "1 hour ago" --no-pager | grep -i hypr | tail -100 || \
    echo "Journalctl not available"
    
    echo ""
    echo "=== Active Workspace ==="
    hyprctl activeworkspace 2>/dev/null || echo "Hyprland not running"
    
    echo ""
    echo "=== Config Validation (syntax check) ==="
    if command -v hyprctl &>/dev/null && pgrep -x hyprland >/dev/null 2>&1; then
        echo "Hyprland is running - config is valid"
    else
        echo "Hyprland not running - cannot validate live"
    fi
} > "$log_dir/02-hyprland.log"

# =============================================================================
# 3. WEZTERM
# =============================================================================
log_info "Collecting WezTerm diagnostics..."
{
    echo "=== WezTerm Version ==="
    wezterm --version 2>/dev/null || echo "WezTerm not installed"
    
    echo ""
    echo "=== Config Path ==="
    ls -la ~/.config/wezterm/wezterm.lua 2>/dev/null || echo "Not found"
    
    echo ""
    echo "=== Lua Syntax Check ==="
    if command -v lua &>/dev/null; then
        lua -c ~/.config/wezterm/wezterm.lua 2>&1 && echo "âœ“ Lua syntax is valid" || echo "âœ— Lua syntax error found"
    else
        echo "Lua not installed - cannot validate"
    fi
    
    echo ""
    echo "=== WezTerm Process ==="
    ps aux | grep -i wezterm | grep -v grep || echo "WezTerm not running"
    
    echo ""
    echo "=== WezTerm Config (first 50 lines) ==="
    head -n 50 ~/.config/wezterm/wezterm.lua 2>/dev/null || echo "Not found"
    
    echo ""
    echo "=== WezTerm Logs ==="
    find ~/.local/share/wezterm -name "*.log" -mmin -120 -exec tail -20 {} \; 2>/dev/null || echo "No recent logs found"
} > "$log_dir/03-wezterm.log"

# =============================================================================
# 4. ZSH
# =============================================================================
log_info "Collecting Zsh diagnostics..."
{
    echo "=== Zsh Version ==="
    zsh --version
    
    echo ""
    echo "=== Config Paths ==="
    ls -la ~/.zshrc ~/.zprofile 2>/dev/null || echo "Not found"
    
    echo ""
    echo "=== Zsh Startup Test (trace first 50 lines) ==="
    timeout 5 zsh -x ~/.zshrc 2>&1 | head -50 || echo "Timeout or error"
    
    echo ""
    echo "=== Zsh History ==="
    ls -lah ~/.zsh_history 2>/dev/null || echo "Not found"
    
    echo ""
    echo "=== Plugin Status ==="
    echo "fzf: $(command -v fzf &>/dev/null && echo 'âœ“ Found' || echo 'âœ— NOT FOUND')"
    echo "zoxide: $(command -v zoxide &>/dev/null && echo 'âœ“ Found' || echo 'âœ— NOT FOUND')"
    echo "starship: $(command -v starship &>/dev/null && echo 'âœ“ Found' || echo 'âœ— NOT FOUND')"
    echo "exa/eza: $(command -v eza &>/dev/null && echo 'âœ“ eza' || (command -v exa &>/dev/null && echo 'âœ“ exa') || echo 'âœ— NOT FOUND')"
} > "$log_dir/04-zsh.log"

# =============================================================================
# 5. UKE PROJECT
# =============================================================================
log_info "Collecting UKE project diagnostics..."
{
    echo "=== UKE Root ==="
    echo "UKE_ROOT=$UKE_ROOT"
    echo "Exists: $(test -d "$UKE_ROOT" && echo 'YES' || echo 'NO')"
    
    echo ""
    echo "=== UKE Directory Tree (2 levels) ==="
    if command -v tree &>/dev/null; then
        tree -L 2 "$UKE_ROOT" 2>/dev/null || find "$UKE_ROOT" -maxdepth 2 -type f | head -30
    else
        find "$UKE_ROOT" -maxdepth 2 -type f | head -30
    fi
    
    echo ""
    echo "=== Registry.yaml (first 60 lines) ==="
    head -n 60 "$UKE_CONFIG/registry.yaml" 2>/dev/null || echo "Not found at: $UKE_CONFIG/registry.yaml"
    
    echo ""
    echo "=== Generated Files (recent) ==="
    find "$UKE_GEN" -type f -printf '%T@ %p\n' 2>/dev/null | sort -rn | head -15 || echo "No gen files"
    
    echo ""
    echo "=== Git Status ==="
    cd "$UKE_ROOT" && git status --short 2>/dev/null || echo "Not a git repo or git not available"
} > "$log_dir/05-uke.log"

# =============================================================================
# 6. SYSTEMD USER SERVICES
# =============================================================================
log_info "Collecting systemd logs..."
{
    echo "=== User Service Status ==="
    systemctl --user status 2>&1 | head -10
    
    echo ""
    echo "=== Recent Journal Entries (last 2 hours) ==="
    journalctl --user --since "2 hours ago" --no-pager -n 50 2>/dev/null || echo "N/A"
    
    echo ""
    echo "=== Failed Units ==="
    systemctl --user list-units --failed --no-pager 2>/dev/null || echo "N/A"
} > "$log_dir/06-systemd.log"

# =============================================================================
# 7. ENVIRONMENT & PATH
# =============================================================================
log_info "Collecting environment variables..."
{
    echo "=== PATH ==="
    echo "$PATH" | tr ':' '\n' | nl
    
    echo ""
    echo "=== Key Environment Variables ==="
    env | grep -E "EDITOR|SHELL|LANG|LC_|XDG_|UKE_" | sort
    
    echo ""
    echo "=== Locale ==="
    locale
} > "$log_dir/07-environment.log"

# =============================================================================
# 8. FILE PERMISSIONS
# =============================================================================
log_info "Checking file permissions..."
{
    echo "=== .config Ownership ==="
    ls -ld ~/.config
    
    echo ""
    echo "=== UKE State Directory ==="
    ls -lad "$UKE_STATE"
    
    echo ""
    echo "=== Config File Permissions ==="
    echo "WezTerm:"
    ls -la ~/.config/wezterm/wezterm.lua 2>/dev/null || echo "  Not found"
    
    echo ""
    echo "Hyprland:"
    ls -la ~/.config/hypr/hyprland.conf 2>/dev/null || echo "  Not found"
    
    echo ""
    echo "Zsh:"
    ls -la ~/.zshrc 2>/dev/null || echo "  Not found"
} > "$log_dir/08-permissions.log"

# =============================================================================
# SUMMARY
# =============================================================================
echo ""
log_ok "Diagnostics complete!"
echo ""
echo "ðŸ“Š Generated files in: $log_dir"
ls -lh "$log_dir"/*.log

echo ""
echo "ðŸ’¾ Quick review:"
for f in "$log_dir"/*.log; do
    echo ""
    echo "--- $(basename "$f") (first 3 lines) ---"
    head -3 "$f"
done

echo ""
echo "ðŸš€ To download via SCP:"
echo "   scp -r $log_dir user@your-mac:/tmp/"
echo ""
echo "ðŸ“‹ Full command to view specific log:"
echo "   cat $log_dir/02-hyprland.log"
echo "   cat $log_dir/03-wezterm.log"
echo "   cat $log_dir/04-zsh.log"



################################################################################
FILE PATH: uke/bin/uke-bunch
################################################################################

#!/usr/bin/env bash
# ==============================================================================
# UKE Bunch - Environment Preset Runner
# ==============================================================================
# Runs a "bunch" - a preset environment that launches specific apps.
#
# Usage: uke-bunch <n>
# Example: uke-bunch coding
# ==============================================================================
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
export UKE_ROOT="${SCRIPT_DIR%/bin}"

source "$UKE_ROOT/lib/core.sh"

BUNCH_NAME="${1:-}"
BUNCH_DIR="$UKE_ROOT/bunches"

# ==============================================================================
# List Available Bunches
# ==============================================================================
list_bunches() {
    echo "Available bunches:"
    for f in "$BUNCH_DIR"/*.sh; do
        [[ -f "$f" ]] || continue
        local name
        name=$(basename "$f" .sh)
        [[ "$name" == "lib-os-detect" ]] && continue
        
        # Try to extract description
        local desc
        desc=$(grep -m1 "^# BUNCH:" "$f" 2>/dev/null | sed 's/# BUNCH: [^-]*- //' || echo "")
        printf "  %-12s %s\n" "$name" "$desc"
    done
}

# ==============================================================================
# Run Bunch
# ==============================================================================
run_bunch() {
    local name="$1"
    local script="$BUNCH_DIR/${name}.sh"
    
    if [[ ! -f "$script" ]]; then
        log_error "Bunch not found: $name"
        echo ""
        list_bunches
        exit 1
    fi
    
    log_info "Running bunch: $name"
    bash "$script"
}

# ==============================================================================
# Main
# ==============================================================================
if [[ -z "$BUNCH_NAME" ]]; then
    list_bunches
    exit 0
fi

case "$BUNCH_NAME" in
    list|--list|-l)
        list_bunches
        ;;
    help|--help|-h)
        echo "Usage: uke-bunch <name>"
        echo ""
        list_bunches
        ;;
    *)
        run_bunch "$BUNCH_NAME"
        ;;
esac



################################################################################
FILE PATH: uke/bin/uke-session
################################################################################

#!/usr/bin/env bash
# ==============================================================================
# UKE Session - Window Layout Save/Restore
# ==============================================================================
# Saves and restores window positions and workspace assignments.
#
# Usage: uke-session <command> [name]
#   save <n>     Save current layout
#   restore <n>  Restore saved layout  
#   list            List saved sessions
#   delete <n>   Delete a session
# ==============================================================================
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
export UKE_ROOT="${SCRIPT_DIR%/bin}"

source "$UKE_ROOT/lib/core.sh"

SESSION_DIR="${XDG_STATE_HOME:-$HOME/.local/state}/uke/sessions"
mkdir -p "$SESSION_DIR"

CMD="${1:-help}"
NAME="${2:-default}"

# ==============================================================================
# macOS Session Functions
# ==============================================================================
save_session_macos() {
    local name="$1"
    local file="$SESSION_DIR/${name}.json"
    
    log_info "Saving session: $name"
    
    yabai -m query --windows | jq '[.[] | {
        app: .app,
        title: .title,
        space: .space,
        frame: .frame,
        floating: ."is-floating"
    }]' > "$file"
    
    ok "Session saved: $file"
}

restore_session_macos() {
    local name="$1"
    local file="$SESSION_DIR/${name}.json"
    
    if [[ ! -f "$file" ]]; then
        log_fatal "Session not found: $name"
    fi
    
    log_info "Restoring session: $name"
    
    # Read session and restore each window
    local count=0
    while read -r app space; do
        # Find window by app name
        local win_id
        win_id=$(yabai -m query --windows | jq -r ".[] | select(.app == \"$app\") | .id" | head -1)
        
        if [[ -n "$win_id" ]]; then
            yabai -m window "$win_id" --space "$space" 2>/dev/null || true
            ((count++))
        fi
    done < <(jq -r '.[] | "\(.app) \(.space)"' "$file")
    
    ok "Restored $count windows"
}

# ==============================================================================
# Linux Session Functions
# ==============================================================================
save_session_linux() {
    local name="$1"
    local file="$SESSION_DIR/${name}.json"
    
    log_info "Saving session: $name"
    
    hyprctl clients -j | jq '[.[] | {
        class: .class,
        title: .title,
        workspace: .workspace.id,
        position: {x: .at[0], y: .at[1]},
        size: {w: .size[0], h: .size[1]},
        floating: .floating
    }]' > "$file"
    
    ok "Session saved: $file"
}

restore_session_linux() {
    local name="$1"
    local file="$SESSION_DIR/${name}.json"
    
    if [[ ! -f "$file" ]]; then
        log_fatal "Session not found: $name"
    fi
    
    log_info "Restoring session: $name"
    
    local count=0
    while read -r class workspace; do
        # Find window by class
        local addr
        addr=$(hyprctl clients -j | jq -r ".[] | select(.class == \"$class\") | .address" | head -1)
        
        if [[ -n "$addr" ]]; then
            hyprctl dispatch movetoworkspacesilent "$workspace,address:$addr" 2>/dev/null || true
            ((count++))
        fi
    done < <(jq -r '.[] | "\(.class) \(.workspace)"' "$file")
    
    ok "Restored $count windows"
}

# ==============================================================================
# Common Functions
# ==============================================================================
list_sessions() {
    echo "Saved sessions:"
    for f in "$SESSION_DIR"/*.json; do
        [[ -f "$f" ]] || continue
        local name size date
        name=$(basename "$f" .json)
        size=$(jq 'length' "$f" 2>/dev/null || echo "?")
        date=$(stat -c %y "$f" 2>/dev/null | cut -d. -f1 || stat -f %Sm "$f" 2>/dev/null || echo "?")
        printf "  %-15s %3s windows  %s\n" "$name" "$size" "$date"
    done
}

delete_session() {
    local name="$1"
    local file="$SESSION_DIR/${name}.json"
    
    if [[ -f "$file" ]]; then
        rm "$file"
        ok "Deleted session: $name"
    else
        warn "Session not found: $name"
    fi
}

# ==============================================================================
# Main
# ==============================================================================
case "$CMD" in
    save)
        is_macos && save_session_macos "$NAME" || save_session_linux "$NAME"
        ;;
    restore)
        is_macos && restore_session_macos "$NAME" || restore_session_linux "$NAME"
        ;;
    list|ls)
        list_sessions
        ;;
    delete|rm)
        delete_session "$NAME"
        ;;
    help|--help|-h)
        cat << EOF
UKE Session Manager

Usage: uke-session <command> [name]

Commands:
  save <n>     Save current window layout
  restore <n>  Restore a saved layout
  list            List all saved sessions
  delete <n>   Delete a session

Examples:
  uke-session save work
  uke-session restore work
  uke-session list
EOF
        ;;
    *)
        log_fatal "Unknown command: $CMD (use: save|restore|list|delete)"
        ;;
esac



################################################################################
FILE PATH: uke/bin/uke-doctor
################################################################################

#!/usr/bin/env bash
# ==============================================================================
# UKE Doctor - Health Check and Diagnostics
# ==============================================================================
# Performs comprehensive health checks on the UKE installation.
#
# Usage: uke-doctor [--fix]
# ==============================================================================
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
export UKE_ROOT="${SCRIPT_DIR%/bin}"

source "$UKE_ROOT/lib/core.sh"

FIX_MODE="${1:-}"
ERRORS=0
WARNINGS=0

# ==============================================================================
# Check Functions
# ==============================================================================
check() {
    local name="$1"
    local result="$2"
    local fix_hint="${3:-}"
    
    if [[ "$result" == "ok" ]]; then
        ok "$name"
        return 0
    elif [[ "$result" == "warn" ]]; then
        warn "$name"
        [[ -n "$fix_hint" ]] && echo "    â†’ $fix_hint"
        ((WARNINGS++))
        return 0
    else
        fail "$name"
        [[ -n "$fix_hint" ]] && echo "    â†’ $fix_hint"
        ((ERRORS++))
        return 1
    fi
}

# ==============================================================================
# Core Checks
# ==============================================================================
check_core() {
    echo ""
    printf "%s=== Core Installation ===%s\n" "$C_BOLD" "$C_RESET"
    
    # UKE root exists
    [[ -d "$UKE_ROOT" ]] && check "UKE_ROOT exists" "ok" || check "UKE_ROOT exists" "fail" "Clone UKE repo to ~/dotfiles/uke"
    
    # Core libraries
    [[ -f "$UKE_ROOT/lib/core.sh" ]] && check "lib/core.sh" "ok" || check "lib/core.sh" "fail"
    [[ -f "$UKE_ROOT/lib/wm.sh" ]] && check "lib/wm.sh" "ok" || check "lib/wm.sh" "fail"
    [[ -f "$UKE_ROOT/lib/gen.sh" ]] && check "lib/gen.sh" "ok" || check "lib/gen.sh" "fail"
    
    # Main CLI
    [[ -x "$UKE_ROOT/bin/uke" ]] && check "bin/uke executable" "ok" || check "bin/uke executable" "fail" "chmod +x bin/uke"
    
    # Registry
    [[ -f "$UKE_CONFIG/registry.yaml" ]] && check "registry.yaml" "ok" || check "registry.yaml" "fail" "Create config/registry.yaml"
}

# ==============================================================================
# Dependencies
# ==============================================================================
check_deps() {
    echo ""
    printf "%s=== Dependencies ===%s\n" "$C_BOLD" "$C_RESET"
    
    # Required
    command -v bash &>/dev/null && check "bash" "ok" || check "bash" "fail"
    command -v jq &>/dev/null && check "jq" "ok" || check "jq" "fail" "Install: brew/pacman install jq"
    command -v stow &>/dev/null && check "stow" "ok" || check "stow" "warn" "Install for dotfiles: brew/pacman install stow"
    
    # Optional but recommended
    command -v yq &>/dev/null && check "yq (YAML parser)" "ok" || check "yq (YAML parser)" "warn" "Install for dynamic generation: brew/pacman install yq"
    
    # Platform specific
    if is_macos; then
        command -v yabai &>/dev/null && check "yabai" "ok" || check "yabai" "fail" "Install: brew install koekeishiya/formulae/yabai"
        command -v skhd &>/dev/null && check "skhd" "ok" || check "skhd" "fail" "Install: brew install koekeishiya/formulae/skhd"
    else
        command -v hyprctl &>/dev/null && check "hyprland" "ok" || check "hyprland" "fail" "Install: pacman -S hyprland"
    fi
}

# ==============================================================================
# Hardware Profile
# ==============================================================================
check_profile() {
    echo ""
    printf "%s=== Hardware Profile ===%s\n" "$C_BOLD" "$C_RESET"
    
    if [[ -f "$UKE_PROFILE_FILE" ]]; then
        check "machine.profile exists" "ok"
        
        # Validate profile content
        source "$UKE_PROFILE_FILE"
        
        [[ -n "${UKE_OS:-}" ]] && check "  UKE_OS=$UKE_OS" "ok" || check "  UKE_OS" "fail"
        [[ -n "${UKE_FORM_FACTOR:-}" ]] && check "  UKE_FORM_FACTOR=$UKE_FORM_FACTOR" "ok" || check "  UKE_FORM_FACTOR" "fail"
        [[ -n "${UKE_MONITORS:-}" ]] && check "  UKE_MONITORS=$UKE_MONITORS" "ok" || check "  UKE_MONITORS" "fail"
        [[ -n "${UKE_GPU:-}" ]] && check "  UKE_GPU=$UKE_GPU" "ok" || check "  UKE_GPU" "fail"
        [[ -n "${UKE_KEYBOARD:-}" ]] && check "  UKE_KEYBOARD=$UKE_KEYBOARD" "ok" || check "  UKE_KEYBOARD" "fail"
    else
        check "machine.profile exists" "warn" "Run: uke profile"
    fi
}

# ==============================================================================
# Ghost Files
# ==============================================================================
check_ghost_files() {
    echo ""
    printf "%s=== Ghost Files (Generated Hardware Configs) ===%s\n" "$C_BOLD" "$C_RESET"
    
    if is_macos; then
        [[ -f "$HOME/.config/yabai/generated_hardware.conf" ]] && \
            check "yabai ghost file" "ok" || \
            check "yabai ghost file" "warn" "Run: uke apply"
    else
        [[ -f "$HOME/.config/hypr/generated_hardware.conf" ]] && \
            check "hyprland ghost file" "ok" || \
            check "hyprland ghost file" "warn" "Run: uke apply"
    fi
    
    [[ -f "$HOME/.config/alacritty/generated_font.toml" ]] && \
        check "alacritty ghost file" "ok" || \
        check "alacritty ghost file" "warn" "Run: uke apply"
    
    [[ -f "$HOME/.config/wezterm/generated_hardware.lua" ]] && \
        check "wezterm ghost file" "ok" || \
        check "wezterm ghost file" "warn" "Run: uke apply"
}

# ==============================================================================
# Generated Configs
# ==============================================================================
check_generated() {
    echo ""
    printf "%s=== Generated Configs ===%s\n" "$C_BOLD" "$C_RESET"
    
    if is_macos; then
        [[ -f "$UKE_GEN/skhd/skhdrc" ]] && check "skhd config" "ok" || check "skhd config" "warn" "Run: uke gen"
        [[ -f "$UKE_GEN/yabai/yabairc" ]] && check "yabai config" "ok" || check "yabai config" "warn" "Run: uke gen"
    else
        [[ -f "$UKE_GEN/hyprland/hyprland.conf" ]] && check "hyprland config" "ok" || check "hyprland config" "warn" "Run: uke gen"
    fi
}

# ==============================================================================
# Symlinks
# ==============================================================================
check_symlinks() {
    echo ""
    printf "%s=== Symlinks ===%s\n" "$C_BOLD" "$C_RESET"
    
    # Check if uke is in PATH
    if command -v uke &>/dev/null; then
        check "uke in PATH" "ok"
    else
        check "uke in PATH" "warn" "Add ~/.local/bin to PATH or run installer"
    fi
    
    # Check config symlinks
    if is_macos; then
        [[ -L "$HOME/.config/skhd/skhdrc" ]] || [[ -f "$HOME/.config/skhd/skhdrc" ]] && \
            check "skhd config linked" "ok" || \
            check "skhd config linked" "warn" "Run: uke install --link"
    else
        [[ -L "$HOME/.config/hypr/hyprland.conf" ]] || [[ -f "$HOME/.config/hypr/hyprland.conf" ]] && \
            check "hyprland config linked" "ok" || \
            check "hyprland config linked" "warn" "Run: uke install --link"
    fi
}

# ==============================================================================
# Service Status
# ==============================================================================
check_services() {
    echo ""
    printf "%s=== Services ===%s\n" "$C_BOLD" "$C_RESET"
    
    if is_linux; then
        systemctl is-active keyd &>/dev/null && check "keyd service" "ok" || check "keyd service" "warn" "sudo systemctl start keyd"
        systemctl --user is-active pipewire &>/dev/null && check "pipewire" "ok" || check "pipewire" "warn" "Audio may not work"
    fi
}

# ==============================================================================
# Update Status
# ==============================================================================
check_updates() {
    echo ""
    printf "%s=== Updates ===%s\n" "$C_BOLD" "$C_RESET"
    
    if command -v checkupdates &>/dev/null; then
        local count=$(checkupdates 2>/dev/null | wc -l)
        if [[ $count -gt 0 ]]; then
            check "$count update(s) available" "warn" "Run: uke-update"
        else
            check "System up to date" "ok"
        fi
    fi
}

# ==============================================================================
# Window Manager Status
# ==============================================================================
check_wm() {
    echo ""
    printf "%s=== Window Manager ===%s\n" "$C_BOLD" "$C_RESET"
    
    if is_macos; then
        pgrep -q yabai && check "yabai running" "ok" || check "yabai running" "warn" "Start: yabai --start-service"
        pgrep -q skhd && check "skhd running" "ok" || check "skhd running" "warn" "Start: skhd --start-service"
    else
        [[ -n "${HYPRLAND_INSTANCE_SIGNATURE:-}" ]] && check "hyprland running" "ok" || check "hyprland running" "warn" "Start Hyprland"
    fi
}

# ==============================================================================
# Summary
# ==============================================================================
print_summary() {
    echo ""
    printf "%sâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”%s\n" "$C_DIM" "$C_RESET"
    echo ""
    
    if [[ $ERRORS -eq 0 ]] && [[ $WARNINGS -eq 0 ]]; then
        printf "%sâœ“ All checks passed!%s\n" "$C_GREEN$C_BOLD" "$C_RESET"
    elif [[ $ERRORS -eq 0 ]]; then
        printf "%s! %d warning(s), 0 errors%s\n" "$C_YELLOW$C_BOLD" "$WARNINGS" "$C_RESET"
    else
        printf "%sâœ— %d error(s), %d warning(s)%s\n" "$C_RED$C_BOLD" "$ERRORS" "$WARNINGS" "$C_RESET"
    fi
    
    echo ""
    echo "Quick fixes:"
    echo "  uke profile          # Configure hardware"
    echo "  uke apply            # Generate ghost files"
    echo "  uke gen && uke reload   # Regenerate and apply"
}

# ==============================================================================
# Main
# ==============================================================================
echo ""
printf "%sâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—%s\n" "$C_CYAN" "$C_RESET"
printf "%sâ•‘%s       UKE Doctor v$UKE_VERSION             %sâ•‘%s\n" "$C_CYAN" "$C_BOLD" "$C_CYAN" "$C_RESET"
printf "%sâ•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•%s\n" "$C_CYAN" "$C_RESET"

check_core
check_deps
check_profile
check_ghost_files
check_generated
check_symlinks
check_services
check_updates
check_wm
print_summary

exit $ERRORS



################################################################################
FILE PATH: uke/bin/uke-launch
################################################################################

#!/usr/bin/env bash
# ==============================================================================
# UKE Launch v7.2 - Smart App & File Launcher
# ==============================================================================

# [FIX] Bash Version Auto-Detection & Reload
# macOS ships with Bash 3.2. This script requires Bash 4.0+ (associative arrays).
if [ -z "${BASH_VERSINFO}" ] || [ "${BASH_VERSINFO[0]}" -lt 4 ]; then
    if [ -x /opt/homebrew/bin/bash ]; then
        exec /opt/homebrew/bin/bash "$0" "$@"
    elif [ -x /usr/local/bin/bash ]; then
        exec /usr/local/bin/bash "$0" "$@"
    else
        echo "Error: Bash 4.0+ required (found ${BASH_VERSION})."
        echo "Please install bash via homebrew: brew install bash"
        exit 1
    fi
fi

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
export UKE_ROOT="${SCRIPT_DIR%/bin}"
source "$UKE_ROOT/lib/core.sh"

# App mappings (fallback if not in registry)
declare -A LINUX_APPS=(
    [browser]="brave"
    [terminal]="wezterm"
    [editor]="nvim"
    [files]="thunar"
    [pdf]="zathura"
    [notes]="obsidian"
    [music]="spotify"
    [mail]="thunderbird"
)

declare -A MACOS_APPS=(
    [browser]="Safari"
    [terminal]="WezTerm"
    [editor]="nvim"
    [files]="Finder"
    [pdf]="Preview"
    [notes]="Obsidian"
    [music]="Spotify"
    [mail]="Mail"
)

# File type handlers
launch_file() {
    local file="$1"
    
    if [[ ! -f "$file" ]]; then
        fail "File not found: $file"
        return 1
    fi
    
    local ext="${file##*.}"
    ext="${ext,,}"  # lowercase
    
    case "$ext" in
        pdf)
            if is_macos; then
                open -a Preview "$file"
            else
                zathura "$file" &>/dev/null &
            fi
            ;;
        epub|djvu|ps)
            if is_macos; then
                open "$file"
            else
                zathura "$file" &>/dev/null &
            fi
            ;;
        png|jpg|jpeg|gif|webp|svg)
            if is_macos; then
                open -a Preview "$file"
            else
                imv "$file" &>/dev/null & || feh "$file" &>/dev/null &
            fi
            ;;
        mp3|flac|wav|ogg|m4a)
            if is_macos; then
                open -a Music "$file"
            else
                mpv --no-video "$file" &>/dev/null &
            fi
            ;;
        mp4|mkv|avi|webm|mov)
            if is_macos; then
                open -a "QuickTime Player" "$file"
            else
                mpv "$file" &>/dev/null &
            fi
            ;;
        txt|md|markdown)
            ${EDITOR:-nvim} "$file"
            ;;
        *)
            # Default: use system handler
            if is_macos; then
                open "$file"
            else
                xdg-open "$file" &>/dev/null &
            fi
            ;;
    esac
    
    ok "Opened: $file"
}

# App launcher
launch_app() {
    local app="$1"
    shift
    local args=("$@")
    
    # Get platform-specific app name
    local app_name
    if is_macos; then
        app_name="${MACOS_APPS[$app]:-$app}"
        open -a "$app_name" "${args[@]}" 2>/dev/null || {
            fail "App not found: $app_name"
            return 1
        }
    else
        app_name="${LINUX_APPS[$app]:-$app}"
        "$app_name" "${args[@]}" &>/dev/null &
        disown 2>/dev/null || true
    fi
    
    ok "Launched: $app_name"
}

# URL handler
launch_url() {
    local url="$1"
    
    if is_macos; then
        open "$url"
    else
        xdg-open "$url" &>/dev/null &
    fi
    
    ok "Opened: $url"
}

# Main
case "${1:-}" in
    -h|--help)
        echo "Usage: uke-launch <app|file|url> [args...]"
        echo ""
        echo "Apps: browser, terminal, editor, files, pdf, notes, music, mail"
        echo "Files: Automatically detected by extension"
        echo "URLs: Opened in default browser"
        echo ""
        echo "Examples:"
        echo "  uke-launch browser"
        echo "  uke-launch ~/docs/paper.pdf"
        echo "  uke-launch https://archlinux.org"
        ;;
    "")
        fail "No target specified. Use --help for usage."
        exit 1
        ;;
    *)
        target="$1"
        shift
        
        # Check if it's a URL
        if [[ "$target" =~ ^https?:// ]]; then
            launch_url "$target"
        # Check if it's a file
        elif [[ -f "$target" ]]; then
            launch_file "$target"
        # Assume it's an app
        else
            launch_app "$target" "$@"
        fi
        ;;
esac



################################################################################
FILE PATH: uke/bin/uke-setup
################################################################################

#!/usr/bin/env bash
# ==============================================================================
# UKE Setup v7.2 - First-Boot Wizard
# ==============================================================================
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
export UKE_ROOT="${SCRIPT_DIR%/bin}"

# Minimal colors (core.sh may not be ready)
RED=$'\e[31m' GREEN=$'\e[32m' YELLOW=$'\e[33m' BLUE=$'\e[34m'
CYAN=$'\e[36m' BOLD=$'\e[1m' DIM=$'\e[2m' RESET=$'\e[0m'

# [FIX] Logging functions redirect to stderr so they don't corrupt captured output
ok()   { printf "%sâœ“%s %s\n" "$GREEN" "$RESET" "$*" >&2; }
fail() { printf "%sâœ—%s %s\n" "$RED" "$RESET" "$*" >&2; }
info() { printf "%sâ†’%s %s\n" "$BLUE" "$RESET" "$*" >&2; }
warn() { printf "%s!%s %s\n" "$YELLOW" "$RESET" "$*" >&2; }

STATE_FILE="${XDG_CONFIG_HOME:-$HOME/.config}/uke/setup-state"
HEADLESS="${HEADLESS:-false}"

# ==============================================================================
# State Management
# ==============================================================================
save_state() {
    mkdir -p "$(dirname "$STATE_FILE")"
    cat > "$STATE_FILE" << EOF
SETUP_STEP=$CURRENT_STEP
SETUP_STARTED="${SETUP_STARTED:-$(date -Iseconds)}"
EOF
}

load_state() {
    if [[ -f "$STATE_FILE" ]]; then
        source "$STATE_FILE"
        CURRENT_STEP="${SETUP_STEP:-1}"
    else
        CURRENT_STEP=1
        SETUP_STARTED="$(date -Iseconds)"
    fi
}

clear_state() {
    rm -f "$STATE_FILE"
}

# ==============================================================================
# Sudo Setup (Safe)
# ==============================================================================
setup_sudo() {
    info "Checking sudo access..."
    
    # Test if we can sudo
    if sudo -n true 2>/dev/null; then
        ok "sudo access OK (passwordless)"
        return 0
    fi
    
    if sudo true; then
        ok "sudo access OK"
        return 0
    fi
    
    # Need to set up sudo
    warn "sudo not configured for $USER"
    echo ""
    echo "To fix this, you need root access. Options:"
    echo ""
    echo "  Option 1: If you know the root password:"
    echo "    su -c 'usermod -aG wheel $USER'"
    echo "    su -c 'echo \"$USER ALL=(ALL:ALL) NOPASSWD: ALL\" > /etc/sudoers.d/uke-$USER'"
    echo "    Then logout and back in"
    echo ""
    echo "  Option 2: From a TTY as root:"
    echo "    1. Press Ctrl+Alt+F3"
    echo "    2. Login as root"
    echo "    3. Run: usermod -aG wheel $USER"
    echo "    4. Run: echo '$USER ALL=(ALL:ALL) ALL' > /etc/sudoers.d/$USER"
    echo "    5. Run: chmod 440 /etc/sudoers.d/$USER"
    echo "    6. Reboot"
    echo ""
    
    return 1
}

# ==============================================================================
# Hardware Detection
# ==============================================================================
detect_hardware() {
    # GPU
    if lspci 2>/dev/null | grep -qi nvidia; then
        DETECTED_GPU="nvidia"
    elif lspci 2>/dev/null | grep -qi "amd.*radeon\|radeon.*amd"; then
        DETECTED_GPU="amd"
    else
        DETECTED_GPU="intel"
    fi
    
    # Form factor
    if [[ -d /sys/class/power_supply/BAT0 ]] || [[ -d /sys/class/power_supply/BAT1 ]]; then
        DETECTED_FORM="laptop_14"
    else
        DETECTED_FORM="desktop"
    fi
    
    # Monitors (if Hyprland running)
    if command -v hyprctl &>/dev/null && [[ -n "${HYPRLAND_INSTANCE_SIGNATURE:-}" ]]; then
        DETECTED_MONITORS=$(hyprctl monitors -j 2>/dev/null | jq length 2>/dev/null || echo "1")
    else
        DETECTED_MONITORS=1
    fi
}

# ==============================================================================
# Step 1: System Check
# ==============================================================================
step_system_check() {
    echo ""
    printf "%s[Step 1/6] System Check%s\n" "$BOLD" "$RESET"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    
    # Check arch
    if [[ -f /etc/arch-release ]]; then
        ok "Arch Linux detected"
    else
        warn "Not Arch Linux - some features may not work"
    fi
    
    # Check internet
    if ping -c1 -W2 archlinux.org &>/dev/null; then
        ok "Internet connectivity"
    else
        fail "No internet. Connect first."
        exit 1
    fi
    
    # Check sudo
    if ! setup_sudo; then
        fail "Cannot proceed without sudo. See instructions above."
        exit 1
    fi
    
    CURRENT_STEP=2
    save_state
}

# ==============================================================================
# Step 2: Package Installation
# ==============================================================================
step_packages() {
    echo ""
    printf "%s[Step 2/6] Package Installation%s\n" "$BOLD" "$RESET"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    
    # Update mirrors first
    if command -v reflector &>/dev/null; then
        info "Optimizing mirrors..."
        sudo reflector --latest 10 --protocol https --sort rate --save /etc/pacman.d/mirrorlist 2>/dev/null || true
    fi
    
    if [[ -x "$UKE_ROOT/scripts/arch-check.sh" ]]; then
        info "Running package checker..."
        "$UKE_ROOT/scripts/arch-check.sh" --install
    else
        warn "arch-check.sh not found, installing manually..."
        sudo pacman -Syu --noconfirm
        sudo pacman -S --noconfirm --needed hyprland wezterm stow jq wofi waybar dunst fzf
    fi
    
    # Ensure AUR helper exists
    if ! command -v yay &>/dev/null && ! command -v paru &>/dev/null; then
        info "Installing yay (AUR helper)..."
        local tmp_dir=$(mktemp -d)
        git clone https://aur.archlinux.org/yay.git "$tmp_dir/yay" 2>/dev/null
        cd "$tmp_dir/yay" && makepkg -si --noconfirm
        cd - >/dev/null
        rm -rf "$tmp_dir"
    fi
    
    ok "Packages installed"
    CURRENT_STEP=3
    save_state
}

# ==============================================================================
# Step 3: UKE Core Installation
# ==============================================================================
step_uke_install() {
    echo ""
    printf "%s[Step 3/6] UKE Core Installation%s\n" "$BOLD" "$RESET"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    
    if [[ -x "$UKE_ROOT/scripts/install.sh" ]]; then
        info "Running UKE installer..."
        "$UKE_ROOT/scripts/install.sh"
    else
        fail "install.sh not found"
        exit 1
    fi
    
    ok "UKE core installed"
    CURRENT_STEP=4
    save_state
}

# ==============================================================================
# Step 4: Hardware Profile
# ==============================================================================
step_hardware() {
    echo ""
    printf "%s[Step 4/6] Hardware Profile%s\n" "$BOLD" "$RESET"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    
    detect_hardware
    
    info "Detected: GPU=$DETECTED_GPU, Form=$DETECTED_FORM, Monitors=$DETECTED_MONITORS"
    
    local profile_file="${XDG_STATE_HOME:-$HOME/.local/state}/uke/machine.profile"
    mkdir -p "$(dirname "$profile_file")"
    
    if [[ "$HEADLESS" == "true" ]]; then
        # Auto-generate profile
        cat > "$profile_file" << EOF
# UKE Machine Profile (auto-generated)
UKE_OS="arch"
UKE_FORM_FACTOR="$DETECTED_FORM"
UKE_MONITORS="$DETECTED_MONITORS"
UKE_GPU="$DETECTED_GPU"
UKE_KEYBOARD="pc"
EOF
        ok "Profile auto-generated"
    else
        # Interactive
        if [[ -x "$UKE_ROOT/scripts/manage_profile.sh" ]]; then
            "$UKE_ROOT/scripts/manage_profile.sh"
        else
            # Fallback to simple questions
            echo ""
            read -p "GPU [$DETECTED_GPU]: " gpu
            read -p "Form factor [$DETECTED_FORM]: " form
            read -p "Monitors [$DETECTED_MONITORS]: " mons
            read -p "Keyboard [pc/mac]: " kb
            
            cat > "$profile_file" << EOF
UKE_OS="arch"
UKE_FORM_FACTOR="${form:-$DETECTED_FORM}"
UKE_MONITORS="${mons:-$DETECTED_MONITORS}"
UKE_GPU="${gpu:-$DETECTED_GPU}"
UKE_KEYBOARD="${kb:-pc}"
EOF
        fi
        ok "Profile configured"
    fi
    
    # Apply profile
    if [[ -x "$UKE_ROOT/scripts/apply_profile.sh" ]]; then
        "$UKE_ROOT/scripts/apply_profile.sh"
    fi
    
    CURRENT_STEP=5
    save_state
}

# ==============================================================================
# Step 5: Service Setup
# ==============================================================================
step_services() {
    echo ""
    printf "%s[Step 5/6] Service Setup%s\n" "$BOLD" "$RESET"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    
    # Enable system services
    for svc in keyd bluetooth NetworkManager; do
        sudo systemctl enable "$svc" 2>/dev/null && ok "Enabled: $svc" || warn "Skipped: $svc"
    done
    
    # Setup keyd
    if [[ -x "$UKE_ROOT/scripts/keyd-setup.sh" ]]; then
        "$UKE_ROOT/scripts/keyd-setup.sh" install 2>/dev/null || warn "keyd setup skipped"
    fi
    
    # Setup user services
    for svc in pipewire pipewire-pulse wireplumber; do
        systemctl --user enable "$svc" 2>/dev/null || true
    done
    
    CURRENT_STEP=6
    save_state
}

# ==============================================================================
# Step 6: Verification
# ==============================================================================
step_verify() {
    echo ""
    printf "%s[Step 6/6] Verification%s\n" "$BOLD" "$RESET"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    
    if [[ -x "$UKE_ROOT/bin/uke-doctor" ]]; then
        "$UKE_ROOT/bin/uke-doctor" || true
    fi
    
    clear_state
    
    echo ""
    echo "${GREEN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${RESET}"
    echo "${GREEN}${BOLD}âœ“ UKE Setup Complete!${RESET}"
    echo "${GREEN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${RESET}"
    echo ""
    echo "Next steps:"
    echo "  1. Reboot your system"
    echo "  2. Login on TTY1 - Hyprland will auto-start"
    echo "  3. Use Alt+Return for terminal"
    echo "  4. Use Alt+Space for launcher (wofi)"
    echo ""
    echo "Quick commands:"
    echo "  uke status     - Show UKE status"
    echo "  uke doctor     - Diagnose issues"
    echo "  uke-fix        - Fix common problems"
    echo "  uke-update     - Update everything"
    echo ""
    echo "Shell features:"
    echo "  Ctrl+R         - Fuzzy history search (fzf)"
    echo "  Ctrl+T         - Fuzzy file search"
    echo "  fcd            - Fuzzy cd with preview"
    echo ""
}

# ==============================================================================
# Main
# ==============================================================================
main() {
    echo ""
    printf "%sâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—%s\n" "$CYAN" "$RESET"
    printf "%sâ•‘%s      UKE Setup Wizard v7.2           %sâ•‘%s\n" "$CYAN" "$BOLD" "$CYAN" "$RESET"
    printf "%sâ•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•%s\n" "$CYAN" "$RESET"
    
    local start_step=1
    
    # Parse args
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --headless) HEADLESS=true ;;
            --minimal)  MINIMAL=true ;;
            --step)     start_step="$2"; shift ;;
            --resume)   load_state; start_step=$CURRENT_STEP ;;
            -h|--help)
                echo "Usage: uke-setup [options]"
                echo "Options:"
                echo "  --headless  Non-interactive, use defaults"
                echo "  --minimal   Essential packages only"
                echo "  --step N    Start from step N"
                echo "  --resume    Resume from last step"
                exit 0
                ;;
        esac
        shift
    done
    
    CURRENT_STEP=$start_step
    
    [[ $CURRENT_STEP -le 1 ]] && step_system_check
    [[ $CURRENT_STEP -le 2 ]] && step_packages
    [[ $CURRENT_STEP -le 3 ]] && step_uke_install
    [[ $CURRENT_STEP -le 4 ]] && step_hardware
    [[ $CURRENT_STEP -le 5 ]] && step_services
    [[ $CURRENT_STEP -le 6 ]] && step_verify
}

main "$@"



################################################################################
FILE PATH: uke/bin/uke
################################################################################

#!/usr/bin/env bash
# ==============================================================================
# UKE - Unified Keyboard Environment CLI v7.0
# ==============================================================================
# Main command-line interface for UKE.
#
# Usage: uke <command> [args]
#
# Commands:
#   gen        Generate configs from registry.yaml
#   apply      Generate hardware configs from machine.profile
#   profile    Manage hardware profile (TUI)
#   reload     Reload window manager
#   status     Show current status
#   validate   Validate configuration
#   edit       Edit config files
#   log        Manage logs
#   install    Run installer
#   doctor     Health check
#   help       Show help
# ==============================================================================
set -euo pipefail

# ==============================================================================
# Path Resolution
# ==============================================================================
SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do
  DIR="$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )"
  SOURCE="$(readlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"
done
SCRIPT_DIR="$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )"
export UKE_ROOT="${SCRIPT_DIR%/bin}"



source "$UKE_ROOT/lib/core.sh"
source "$UKE_ROOT/lib/wm.sh"

# ==============================================================================
# Commands
# ==============================================================================

cmd_gen() {
    local target="${1:-all}"
    bash "$UKE_LIB/gen.sh" "$target"
}

cmd_apply() {
    local flags="${1:-}"
    bash "$UKE_SCRIPTS/apply_profile.sh" $flags
}

cmd_profile() {
    bash "$UKE_SCRIPTS/manage_profile.sh" "$@"
}

cmd_reload() {
    wm_reload
}

cmd_status() {
    echo ""
    printf "%sâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—%s\n" "$C_CYAN" "$C_RESET"
    printf "%sâ•‘%s       UKE v%s Status                 %sâ•‘%s\n" "$C_CYAN" "$C_BOLD" "$UKE_VERSION" "$C_CYAN" "$C_RESET"
    printf "%sâ•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•%s\n" "$C_CYAN" "$C_RESET"
    echo ""
    
    echo "Platform:    $UKE_OS"
    [[ -n "$UKE_DISTRO" ]] && echo "Distro:      $UKE_DISTRO"
    echo "UKE Root:    $UKE_ROOT"
    echo "Config Path: $UKE_CONFIG_SOURCE"
    echo ""
    
    # Hardware profile
    if has_profile; then
        load_hardware_profile
        ok "Hardware Profile:"
        echo "  OS:          $(get_profile OS)"
        echo "  Form Factor: $(get_profile FORM_FACTOR)"
        echo "  Monitors:    $(get_profile MONITORS)"
        echo "  GPU:         $(get_profile GPU)"
        echo "  Keyboard:    $(get_profile KEYBOARD)"
    else
        warn "No hardware profile found"
        info "Run 'uke profile' to create one"
    fi
    echo ""
    
    # Window manager status
    if wm_running; then
        ok "Window Manager: $(wm_name) running"
        echo "  Workspace: $(wm_current_workspace 2>/dev/null || echo 'unknown')"
    else
        fail "Window Manager: not running"
    fi
    echo ""
    
    # Cloud path
    if [[ -n "${UKE_CLOUD_PATH:-}" ]]; then
        if [[ -d "$UKE_CLOUD_PATH" ]]; then
            ok "Cloud Path: $UKE_CLOUD_PATH"
        else
            warn "Cloud Path: $UKE_CLOUD_PATH (not found)"
        fi
    fi
}

cmd_validate() {
    log_info "Validating configuration..."
    local errors=0
    
    # Check registry
    if [[ -f "$UKE_CONFIG/registry.yaml" ]]; then
        ok "registry.yaml exists"
    else
        fail "registry.yaml missing at $UKE_CONFIG/registry.yaml"
        ((errors++))
    fi
    
    # Check generated configs
    if is_macos; then
        [[ -f "$UKE_GEN/skhd/skhdrc" ]] && ok "skhd config exists" || { fail "skhd config missing"; ((errors++)); }
        [[ -f "$UKE_GEN/yabai/yabairc" ]] && ok "yabai config exists" || { fail "yabai config missing"; ((errors++)); }
    else
        [[ -f "$UKE_GEN/hyprland/hyprland.conf" ]] && ok "hyprland config exists" || { fail "hyprland config missing"; ((errors++)); }
    fi
    
    # Check hardware profile and ghost files
    if has_profile; then
        ok "Hardware profile exists"
        
        if is_macos; then
            [[ -f "$HOME/.config/yabai/generated_hardware.conf" ]] && ok "yabai ghost file exists" || warn "yabai ghost file missing (run 'uke apply')"
        else
            [[ -f "$HOME/.config/hypr/generated_hardware.conf" ]] && ok "hyprland ghost file exists" || warn "hyprland ghost file missing (run 'uke apply')"
        fi
        
        [[ -f "$HOME/.config/alacritty/generated_font.toml" ]] && ok "alacritty ghost file exists" || warn "alacritty ghost file missing"
        [[ -f "$HOME/.config/wezterm/generated_hardware.lua" ]] && ok "wezterm ghost file exists" || warn "wezterm ghost file missing"
    else
        warn "No hardware profile - run 'uke profile' to create one"
    fi
    
    echo ""
    if [[ $errors -eq 0 ]]; then
        ok "All validations passed!"
    else
        fail "$errors error(s) found"
        return 1
    fi
}

cmd_edit() {
    local target="${1:-registry}"
    local file
    
    case "$target" in
        registry|reg)  file="$UKE_CONFIG/registry.yaml" ;;
        profile)       file="$UKE_PROFILE_FILE" ;;
        skhd)          file="$UKE_GEN/skhd/skhdrc" ;;
        yabai)         file="$UKE_GEN/yabai/yabairc" ;;
        hyprland)      file="$UKE_GEN/hyprland/hyprland.conf" ;;
        *)             log_fatal "Unknown target: $target (use: registry|profile|skhd|yabai|hyprland)" ;;
    esac
    
    if [[ ! -f "$file" ]]; then
        log_fatal "File not found: $file"
    fi
    
    ${EDITOR:-nvim} "$file"
}

cmd_log() {
    case "${1:-tail}" in
        tail)  tail -n "${2:-50}" "$UKE_LOG_FILE" 2>/dev/null || echo "No logs" ;;
        clear) : > "$UKE_LOG_FILE" && ok "Log cleared" ;;
        path)  echo "$UKE_LOG_FILE" ;;
        *)     log_fatal "Unknown: $1 (use: tail|clear|path)" ;;
    esac
}

cmd_install() {
    if [[ -x "$UKE_SCRIPTS/install.sh" ]]; then
        bash "$UKE_SCRIPTS/install.sh" "$@"
    else
        log_fatal "Installer not found: $UKE_SCRIPTS/install.sh"
    fi
}

cmd_doctor() {
    if [[ -x "$UKE_BIN/uke-doctor" ]]; then
        bash "$UKE_BIN/uke-doctor" "$@"
    else
        # Inline basic health check
        log_info "Running basic health check..."
        cmd_validate
    fi
}

cmd_help() {
    cat << EOF
${C_CYAN}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${C_RESET}
${C_CYAN}â•‘${C_BOLD}       UKE v$UKE_VERSION - Unified Keyboard Environment          ${C_CYAN}â•‘${C_RESET}
${C_CYAN}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${C_RESET}

${C_BOLD}Usage:${C_RESET} uke <command> [args]

${C_BOLD}Core Commands:${C_RESET}
  gen [target]     Generate configs from registry.yaml
                   Targets: skhd|yabai|hyprland|gather|all
  apply [--dry-run] Generate hardware configs from machine.profile
  profile          Manage hardware profile (interactive TUI)
  reload           Reload window manager

${C_BOLD}Info Commands:${C_RESET}
  status           Show current status
  validate         Validate configuration
  doctor           Run health check

${C_BOLD}Utility Commands:${C_RESET}
  edit [target]    Edit config (registry|profile|skhd|yabai|hyprland)
  log [cmd]        Manage logs (tail|clear|path)
  install [opts]   Run installer
  help             Show this help

${C_BOLD}Examples:${C_RESET}
  uke gen                    # Generate all configs
  uke profile                # Open hardware profile TUI
  uke apply                  # Generate hardware ghost files
  uke gen && uke reload      # Apply changes
  uke edit                   # Edit registry.yaml

${C_BOLD}Workflow (New Machine):${C_RESET}
  1. uke profile             # Set hardware settings
  2. uke apply               # Generate ghost files
  3. uke gen && uke reload   # Generate and apply configs

${C_BOLD}Companion Commands:${C_RESET}
  uke-gather                 # Organize windows to workspaces
  uke-bunch <name>           # Run environment preset
  uke-scratchpad <name>      # Toggle scratchpad window
  uke-session <cmd>          # Save/restore window layouts
  uke-launch <app>           # Smart app launcher
  uke-doctor                 # Detailed health check
  uke-backup                 # Backup configs
  uke-debug                  # Diagnostics
  uke-logs [component]       # Live log viewer

EOF
}

# ==============================================================================
# Main
# ==============================================================================
case "${1:-help}" in
    gen|generate)      shift; cmd_gen "$@" ;;
    apply)             shift; cmd_apply "$@" ;;
    profile|prof)      shift; cmd_profile "$@" ;;
    reload)            cmd_reload ;;
    status|stat)       cmd_status ;;
    validate|val)      cmd_validate ;;
    edit)              shift; cmd_edit "$@" ;;
    log)               shift; cmd_log "$@" ;;
    install)           shift; cmd_install "$@" ;;
    doctor|doc)        shift; cmd_doctor "$@" ;;
    help|--help|-h)    cmd_help ;;
    version|--version|-v) echo "UKE v$UKE_VERSION" ;;
    *)
        log_error "Unknown command: $1"
        echo ""
        cmd_help
        exit 1
        ;;
esac



################################################################################
FILE PATH: uke/bin/uke-gather
################################################################################

# ==============================================================================
# UKE Gather - Organize windows by workspace
# ==============================================================================
# Source: /Users/laurenz/dotfiles/uke/config/registry.yaml
# Generated: 2025-12-04T21:08:38+01:00
# Platform: macos
#
# DO NOT EDIT DIRECTLY - Regenerate with: uke gen
# ==============================================================================

#!/usr/bin/env bash
set -euo pipefail

SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do
  DIR="$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )"
  SOURCE="$(readlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"
done
SCRIPT_DIR="$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )"
export UKE_ROOT="${SCRIPT_DIR%/bin}"

source "$UKE_ROOT/lib/core.sh"
require_cmd jq

gather_macos() {
    local current_space
    current_space=$(yabai -m query --spaces --space | jq -r '.index')
    log_info "Gathering windows for space $current_space..."
    
    case $current_space in
        1)
            yabai -m query --windows | jq -r '.[] | select(.app == "Safari" or .app == "Brave Browser" or .app == "Firefox") | .id' | \
                xargs -I {} yabai -m window {} --space 1 2>/dev/null || true
            ;;
        2)
            yabai -m query --windows | jq -r '.[] | select(.app == "Obsidian") | .id' | \
                xargs -I {} yabai -m window {} --space 2 2>/dev/null || true
            ;;
        3)
            yabai -m query --windows | jq -r '.[] | select(.app == "WezTerm" or .app == "Code" or .app == "Xcode" or .app == "Cursor") | .id' | \
                xargs -I {} yabai -m window {} --space 3 2>/dev/null || true
            ;;
        5)
            yabai -m query --windows | jq -r '.[] | select(.app == "Preview" or .app == "PDF Expert") | .id' | \
                xargs -I {} yabai -m window {} --space 5 2>/dev/null || true
            ;;
        6)
            yabai -m query --windows | jq -r '.[] | select(.app == "Raindrop.io") | .id' | \
                xargs -I {} yabai -m window {} --space 6 2>/dev/null || true
            ;;
        7)
            yabai -m query --windows | jq -r '.[] | select(.app == "Spotify") | .id' | \
                xargs -I {} yabai -m window {} --space 7 2>/dev/null || true
            ;;
        8)
            yabai -m query --windows | jq -r '.[] | select(.app == "Microsoft Word" or .app == "Microsoft Excel" or .app == "Microsoft PowerPoint") | .id' | \
                xargs -I {} yabai -m window {} --space 8 2>/dev/null || true
            ;;
        9)
            yabai -m query --windows | jq -r '.[] | select(.app == "Slack" or .app == "Discord" or .app == "Mail") | .id' | \
                xargs -I {} yabai -m window {} --space 9 2>/dev/null || true
            ;;
        10)
            yabai -m query --windows | jq -r '.[] | select(.app == "Claude" or .app == "Perplexity") | .id' | \
                xargs -I {} yabai -m window {} --space 10 2>/dev/null || true
            ;;
        *)
            log_info "No gather action for space $current_space"
            ;;
    esac
    ok "Windows gathered"
}

gather_linux() {
    local current_ws
    current_ws=$(hyprctl activeworkspace -j | jq -r '.id')
    log_info "Gathering windows for workspace $current_ws..."
    
    case $current_ws in
        1)
            hyprctl clients -j | jq -r '.[] | select(.class | test("brave|firefox|chromium"; "i")) | .address' | \
                while read -r addr; do hyprctl dispatch movetoworkspacesilent "1,address:$addr" 2>/dev/null; done
            ;;
        2)
            hyprctl clients -j | jq -r '.[] | select(.class | test("obsidian"; "i")) | .address' | \
                while read -r addr; do hyprctl dispatch movetoworkspacesilent "2,address:$addr" 2>/dev/null; done
            ;;
        3)
            hyprctl clients -j | jq -r '.[] | select(.class | test("wezterm|code|alacritty|kitty"; "i")) | .address' | \
                while read -r addr; do hyprctl dispatch movetoworkspacesilent "3,address:$addr" 2>/dev/null; done
            ;;
        5)
            hyprctl clients -j | jq -r '.[] | select(.class | test("evince|zathura|okular"; "i")) | .address' | \
                while read -r addr; do hyprctl dispatch movetoworkspacesilent "5,address:$addr" 2>/dev/null; done
            ;;
        6)
            hyprctl clients -j | jq -r '.[] | select(.class | test("raindrop"; "i")) | .address' | \
                while read -r addr; do hyprctl dispatch movetoworkspacesilent "6,address:$addr" 2>/dev/null; done
            ;;
        7)
            hyprctl clients -j | jq -r '.[] | select(.class | test("spotify"; "i")) | .address' | \
                while read -r addr; do hyprctl dispatch movetoworkspacesilent "7,address:$addr" 2>/dev/null; done
            ;;
        8)
            hyprctl clients -j | jq -r '.[] | select(.class | test("libreoffice|soffice"; "i")) | .address' | \
                while read -r addr; do hyprctl dispatch movetoworkspacesilent "8,address:$addr" 2>/dev/null; done
            ;;
        9)
            hyprctl clients -j | jq -r '.[] | select(.class | test("slack|discord|thunderbird|telegram"; "i")) | .address' | \
                while read -r addr; do hyprctl dispatch movetoworkspacesilent "9,address:$addr" 2>/dev/null; done
            ;;
        10)
            hyprctl clients -j | jq -r '.[] | select(.class | test("claude"; "i")) | .address' | \
                while read -r addr; do hyprctl dispatch movetoworkspacesilent "10,address:$addr" 2>/dev/null; done
            ;;
        *)
            log_info "No gather action for workspace $current_ws"
            ;;
    esac
    ok "Windows gathered"
}

is_macos && gather_macos || gather_linux



################################################################################
FILE PATH: uke/bin/uke-services
################################################################################

#!/usr/bin/env bash
# ==============================================================================
# UKE Services v7.2 - Service Health & Management
# ==============================================================================
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
export UKE_ROOT="${SCRIPT_DIR%/bin}"
source "$UKE_ROOT/lib/core.sh"

# Load services from registry if yq available, otherwise use defaults
load_services() {
    local registry="$UKE_ROOT/config/registry.yaml"
    
    if command -v yq &>/dev/null && [[ -f "$registry" ]]; then
        # Read from YAML
        mapfile -t SYSTEM_SERVICES < <(yq -r '.services.system[]' "$registry" 2>/dev/null || echo "")
        mapfile -t USER_SERVICES < <(yq -r '.services.user[]' "$registry" 2>/dev/null || echo "")
        mapfile -t HYPR_PROCESSES < <(yq -r '.services.hyprland[]' "$registry" 2>/dev/null || echo "")
    fi
    
    # Fallback to defaults if empty
    [[ ${#SYSTEM_SERVICES[@]} -eq 0 ]] && SYSTEM_SERVICES=(keyd bluetooth NetworkManager)
    [[ ${#USER_SERVICES[@]} -eq 0 ]] && USER_SERVICES=(pipewire pipewire-pulse wireplumber)
    [[ ${#HYPR_PROCESSES[@]} -eq 0 ]] && HYPR_PROCESSES=(waybar dunst hypridle hyprpaper)
}

load_services

show_status() {
    echo ""
    printf "%sâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—%s\n" "$C_CYAN" "$C_RESET"
    printf "%sâ•‘%s        UKE Service Status            %sâ•‘%s\n" "$C_CYAN" "$C_BOLD" "$C_CYAN" "$C_RESET"
    printf "%sâ•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•%s\n" "$C_CYAN" "$C_RESET"
    
    local issues=0
    
    echo ""
    printf "%s=== System Services ===%s\n" "$C_BOLD" "$C_RESET"
    for svc in "${SYSTEM_SERVICES[@]}"; do
        [[ -z "$svc" ]] && continue
        if systemctl is-active "$svc" &>/dev/null; then
            printf "  %sâœ“%s %-18s %sactive%s\n" "$C_GREEN" "$C_RESET" "$svc" "$C_GREEN" "$C_RESET"
        elif systemctl is-enabled "$svc" &>/dev/null; then
            printf "  %s!%s %-18s %senabled but stopped%s\n" "$C_YELLOW" "$C_RESET" "$svc" "$C_YELLOW" "$C_RESET"
            ((issues++))
        else
            printf "  %s-%s %-18s %snot enabled%s\n" "$C_DIM" "$C_RESET" "$svc" "$C_DIM" "$C_RESET"
        fi
    done
    
    echo ""
    printf "%s=== User Services ===%s\n" "$C_BOLD" "$C_RESET"
    for svc in "${USER_SERVICES[@]}"; do
        [[ -z "$svc" ]] && continue
        if systemctl --user is-active "$svc" &>/dev/null; then
            printf "  %sâœ“%s %-18s %sactive%s\n" "$C_GREEN" "$C_RESET" "$svc" "$C_GREEN" "$C_RESET"
        else
            printf "  %sâœ—%s %-18s %snot running%s\n" "$C_RED" "$C_RESET" "$svc" "$C_RED" "$C_RESET"
            ((issues++))
        fi
    done
    
    echo ""
    printf "%s=== Hyprland Ecosystem ===%s\n" "$C_BOLD" "$C_RESET"
    for proc in "${HYPR_PROCESSES[@]}"; do
        [[ -z "$proc" ]] && continue
        local pid=$(pgrep -x "$proc" 2>/dev/null | head -1)
        if [[ -n "$pid" ]]; then
            printf "  %sâœ“%s %-18s %srunning (PID %s)%s\n" "$C_GREEN" "$C_RESET" "$proc" "$C_GREEN" "$pid" "$C_RESET"
        else
            printf "  %s-%s %-18s %snot running%s\n" "$C_DIM" "$C_RESET" "$proc" "$C_DIM" "$C_RESET"
        fi
    done
    
    echo ""
    if [[ $issues -gt 0 ]]; then
        warn "$issues service(s) need attention"
        info "Run: uke-services restart"
    else
        ok "All critical services running"
    fi
}

restart_service() {
    local target="${1:-all}"
    
    if [[ "$target" == "all" ]]; then
        info "Restarting all services..."
        for svc in "${SYSTEM_SERVICES[@]}"; do
            [[ -z "$svc" ]] && continue
            sudo systemctl restart "$svc" 2>/dev/null && ok "Restarted: $svc" || warn "Failed: $svc"
        done
        for svc in "${USER_SERVICES[@]}"; do
            [[ -z "$svc" ]] && continue
            systemctl --user restart "$svc" 2>/dev/null && ok "Restarted: $svc" || warn "Failed: $svc"
        done
        for proc in "${HYPR_PROCESSES[@]}"; do
            [[ -z "$proc" ]] && continue
            pkill -x "$proc" 2>/dev/null || true
            sleep 0.3
            "$proc" &>/dev/null &
            disown 2>/dev/null || true
            ok "Restarted: $proc"
        done
    else
        # Check which type of service
        if printf '%s\n' "${SYSTEM_SERVICES[@]}" | grep -qx "$target"; then
            sudo systemctl restart "$target" && ok "Restarted: $target"
        elif printf '%s\n' "${USER_SERVICES[@]}" | grep -qx "$target"; then
            systemctl --user restart "$target" && ok "Restarted: $target"
        elif printf '%s\n' "${HYPR_PROCESSES[@]}" | grep -qx "$target"; then
            pkill -x "$target" 2>/dev/null || true
            sleep 0.3
            "$target" &>/dev/null &
            disown 2>/dev/null || true
            ok "Restarted: $target"
        else
            fail "Unknown service: $target"
            return 1
        fi
    fi
}

enable_services() {
    info "Enabling services at boot..."
    for svc in "${SYSTEM_SERVICES[@]}"; do
        [[ -z "$svc" ]] && continue
        sudo systemctl enable "$svc" 2>/dev/null && ok "Enabled: $svc" || warn "Skipped: $svc"
    done
    for svc in "${USER_SERVICES[@]}"; do
        [[ -z "$svc" ]] && continue
        systemctl --user enable "$svc" 2>/dev/null && ok "Enabled: $svc" || warn "Skipped: $svc"
    done
}

show_logs() {
    local svc="${1:-}"
    if [[ -z "$svc" ]]; then
        journalctl -b --no-pager -n 50
    elif printf '%s\n' "${SYSTEM_SERVICES[@]}" | grep -qx "$svc"; then
        journalctl -u "$svc" -b --no-pager -n 50
    elif printf '%s\n' "${USER_SERVICES[@]}" | grep -qx "$svc"; then
        journalctl --user -u "$svc" -b --no-pager -n 50
    else
        fail "Unknown service: $svc"
    fi
}

case "${1:-status}" in
    status)     show_status ;;
    restart)    restart_service "${2:-all}" ;;
    enable)     enable_services ;;
    disable)    info "Disabling not implemented (safety)" ;;
    logs)       show_logs "${2:-}" ;;
    list)
        echo "System:   ${SYSTEM_SERVICES[*]}"
        echo "User:     ${USER_SERVICES[*]}"
        echo "Hyprland: ${HYPR_PROCESSES[*]}"
        ;;
    -h|--help)
        echo "Usage: uke-services [command] [service]"
        echo "Commands:"
        echo "  status    Show service status (default)"
        echo "  restart   Restart services"
        echo "  enable    Enable services at boot"
        echo "  logs      View service logs"
        echo "  list      List managed services"
        ;;
    *)          fail "Unknown command: $1" ;;
esac



################################################################################
FILE PATH: uke/bin/uke-sticky
################################################################################

#!/usr/bin/env bash
# ==============================================================================
# UKE Sticky v7.2 - Toggle Floating Always-On-Top Window
# ==============================================================================
# Makes the focused window a floating, always-on-top, sticky window that
# follows you across workspaces. Perfect for keeping a terminal visible
# while working. Press again to restore normal behavior.
# ==============================================================================
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
export UKE_ROOT="${SCRIPT_DIR%/bin}"
source "$UKE_ROOT/lib/core.sh"

# State file to track sticky windows
STATE_DIR="${XDG_STATE_HOME:-$HOME/.local/state}/uke"
STICKY_STATE="$STATE_DIR/sticky_windows"

mkdir -p "$STATE_DIR"
touch "$STICKY_STATE"

# ==============================================================================
# Hyprland Implementation
# ==============================================================================
hyprland_get_window_id() {
    hyprctl activewindow -j | jq -r '.address'
}

hyprland_is_sticky() {
    local addr="$1"
    grep -qx "$addr" "$STICKY_STATE" 2>/dev/null
}

hyprland_make_sticky() {
    local addr="$1"
    
    # Make floating
    hyprctl dispatch togglefloating
    
    # Pin to all workspaces (sticky)
    hyprctl dispatch pin
    
    # Resize to a nice floating size (40% width, 50% height, bottom-right)
    hyprctl dispatch resizeactive exact 40% 50%
    hyprctl dispatch moveactive exact 58% 48%
    
    # Record as sticky
    echo "$addr" >> "$STICKY_STATE"
    
    ok "Window is now sticky (floating + pinned)"
    info "Press again to unstick, or drag to move"
}

hyprland_unmake_sticky() {
    local addr="$1"
    
    # Unpin
    hyprctl dispatch pin
    
    # Return to tiled
    hyprctl dispatch togglefloating
    
    # Remove from state
    sed -i "\|^${addr}$|d" "$STICKY_STATE"
    
    ok "Window restored to normal"
}

hyprland_toggle() {
    local addr=$(hyprland_get_window_id)
    
    if [[ -z "$addr" ]] || [[ "$addr" == "null" ]]; then
        fail "No active window"
        return 1
    fi
    
    if hyprland_is_sticky "$addr"; then
        hyprland_unmake_sticky "$addr"
    else
        hyprland_make_sticky "$addr"
    fi
}

# ==============================================================================
# Yabai (macOS) Implementation
# ==============================================================================
yabai_get_window_id() {
    yabai -m query --windows --window | jq -r '.id'
}

yabai_is_sticky() {
    local wid="$1"
    grep -qx "$wid" "$STICKY_STATE" 2>/dev/null
}

yabai_make_sticky() {
    local wid="$1"
    
    # Make floating
    yabai -m window --toggle float
    
    # Make sticky (visible on all spaces)
    yabai -m window --toggle sticky
    
    # Make topmost (always on top)
    yabai -m window --toggle topmost
    
    # Resize and position (bottom-right quadrant)
    yabai -m window --resize abs:800:500
    yabai -m window --move abs:1100:550
    
    # Record as sticky
    echo "$wid" >> "$STICKY_STATE"
    
    ok "Window is now sticky (floating + sticky + topmost)"
    info "Press again to unstick, or drag to move"
}

yabai_unmake_sticky() {
    local wid="$1"
    
    # Remove topmost
    yabai -m window --toggle topmost
    
    # Remove sticky
    yabai -m window --toggle sticky
    
    # Return to tiled
    yabai -m window --toggle float
    
    # Remove from state
    sed -i '' "\|^${wid}$|d" "$STICKY_STATE" 2>/dev/null || \
        sed -i "\|^${wid}$|d" "$STICKY_STATE"
    
    ok "Window restored to normal"
}

yabai_toggle() {
    local wid=$(yabai_get_window_id)
    
    if [[ -z "$wid" ]] || [[ "$wid" == "null" ]]; then
        fail "No active window"
        return 1
    fi
    
    if yabai_is_sticky "$wid"; then
        yabai_unmake_sticky "$wid"
    else
        yabai_make_sticky "$wid"
    fi
}

# ==============================================================================
# Utility Commands
# ==============================================================================
list_sticky() {
    echo ""
    printf "%s=== Sticky Windows ===%s\n" "$C_BOLD" "$C_RESET"
    
    if [[ ! -s "$STICKY_STATE" ]]; then
        info "No sticky windows"
        return
    fi
    
    while read -r addr; do
        [[ -z "$addr" ]] && continue
        if is_linux; then
            local title=$(hyprctl clients -j | jq -r ".[] | select(.address == \"$addr\") | .title" 2>/dev/null)
            echo "  â€¢ $addr: ${title:-unknown}"
        else
            echo "  â€¢ $addr"
        fi
    done < "$STICKY_STATE"
}

clear_sticky() {
    info "Clearing sticky state..."
    
    # Try to unstick all tracked windows
    while read -r addr; do
        [[ -z "$addr" ]] && continue
        if is_linux; then
            # Try to unpin if window still exists
            hyprctl dispatch pin address:"$addr" 2>/dev/null || true
        fi
    done < "$STICKY_STATE"
    
    > "$STICKY_STATE"
    ok "Sticky state cleared"
}

# ==============================================================================
# Main
# ==============================================================================
case "${1:-toggle}" in
    toggle|"")
        if is_linux; then
            if [[ -n "${HYPRLAND_INSTANCE_SIGNATURE:-}" ]]; then
                hyprland_toggle
            else
                fail "Hyprland not running"
                exit 1
            fi
        elif is_macos; then
            yabai_toggle
        else
            fail "Unsupported platform"
            exit 1
        fi
        ;;
    list)
        list_sticky
        ;;
    clear)
        clear_sticky
        ;;
    -h|--help)
        echo "Usage: uke-sticky [command]"
        echo ""
        echo "Commands:"
        echo "  toggle  Toggle sticky mode for focused window (default)"
        echo "  list    List all sticky windows"
        echo "  clear   Clear sticky state (reset)"
        echo ""
        echo "Sticky windows are:"
        echo "  â€¢ Floating (not tiled)"
        echo "  â€¢ Pinned to all workspaces"
        echo "  â€¢ Always on top"
        echo "  â€¢ Draggable with mouse"
        echo ""
        echo "Keybinding: PRIMARY+S (Alt+S on Linux, Cmd+S on macOS)"
        ;;
    *)
        fail "Unknown command: $1"
        exit 1
        ;;
esac



################################################################################
FILE PATH: uke/bin/uke-update
################################################################################

#!/usr/bin/env bash
# ==============================================================================
# UKE Update v7.2 - Unified System Update Manager
# ==============================================================================
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
export UKE_ROOT="${SCRIPT_DIR%/bin}"
source "$UKE_ROOT/lib/core.sh"

AUR_HELPER=""
[[ -x "$(command -v yay)" ]] && AUR_HELPER="yay"
[[ -x "$(command -v paru)" ]] && AUR_HELPER="paru"

show_news() {
    info "Fetching Arch Linux news..."
    if command -v curl &>/dev/null; then
        curl -s "https://archlinux.org/feeds/news/" 2>/dev/null | \
            grep -oP '(?<=<title>).*?(?=</title>)' | head -5 | tail -4 | \
            while read -r title; do echo "  â€¢ $title"; done
    else
        warn "curl not installed, skipping news"
    fi
    echo ""
}

check_updates() {
    info "Checking for updates..."
    echo ""
    
    printf "%s=== Official Packages ===%s\n" "$C_BOLD" "$C_RESET"
    local official=$(checkupdates 2>/dev/null | wc -l)
    if [[ $official -gt 0 ]]; then
        checkupdates 2>/dev/null | head -10
        [[ $official -gt 10 ]] && echo "  ... and $((official - 10)) more"
        echo ""
        info "$official package(s) available"
    else
        ok "System is up to date"
    fi
    
    if [[ -n "$AUR_HELPER" ]]; then
        echo ""
        printf "%s=== AUR Packages ===%s\n" "$C_BOLD" "$C_RESET"
        local aur=$("$AUR_HELPER" -Qua 2>/dev/null | wc -l)
        if [[ $aur -gt 0 ]]; then
            "$AUR_HELPER" -Qua 2>/dev/null | head -10
            [[ $aur -gt 10 ]] && echo "  ... and $((aur - 10)) more"
            echo ""
            info "$aur AUR package(s) available"
        else
            ok "AUR packages up to date"
        fi
    fi
    
    echo ""
    printf "%s=== UKE ===%s\n" "$C_BOLD" "$C_RESET"
    if [[ -d "$UKE_ROOT/.git" ]]; then
        cd "$UKE_ROOT"
        git fetch origin 2>/dev/null
        local behind=$(git rev-list HEAD..origin/main --count 2>/dev/null || echo "0")
        if [[ $behind -gt 0 ]]; then
            info "UKE is $behind commit(s) behind"
        else
            ok "UKE is up to date"
        fi
    else
        warn "UKE not a git repo"
    fi
}

refresh_mirrors() {
    if ! command -v reflector &>/dev/null; then
        warn "reflector not installed, skipping mirror refresh"
        return 0
    fi
    
    info "Refreshing mirrors (this may take a moment)..."
    sudo reflector --latest 20 --protocol https --sort rate --save /etc/pacman.d/mirrorlist
    ok "Mirrors refreshed"
}

clean_cache() {
    info "Cleaning package cache..."
    
    # Clean with paccache if available
    if command -v paccache &>/dev/null; then
        sudo paccache -rk2  # Keep only last 2 versions
        ok "Package cache cleaned (kept last 2 versions)"
    else
        warn "pacman-contrib not installed, skipping cache cleanup"
    fi
}

clean_orphans() {
    info "Checking for orphaned packages..."
    
    local orphans=$(pacman -Qtdq 2>/dev/null | wc -l)
    if [[ $orphans -gt 0 ]]; then
        echo ""
        pacman -Qtdq 2>/dev/null
        echo ""
        read -p "Remove $orphans orphaned package(s)? [y/N] " -n 1 -r
        echo ""
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            sudo pacman -Rns $(pacman -Qtdq) --noconfirm
            ok "Orphans removed"
        fi
    else
        ok "No orphaned packages"
    fi
}

update_system() {
    info "Updating official packages..."
    sudo pacman -Syu --noconfirm
    ok "System packages updated"
}

update_aur() {
    if [[ -z "$AUR_HELPER" ]]; then
        warn "No AUR helper found (yay/paru)"
        return 1
    fi
    info "Updating AUR packages..."
    "$AUR_HELPER" -Sua --noconfirm
    ok "AUR packages updated"
}

update_uke() {
    if [[ ! -d "$UKE_ROOT/.git" ]]; then
        warn "UKE is not a git repository"
        return 1
    fi
    info "Updating UKE..."
    cd "$UKE_ROOT"
    git pull origin main 2>/dev/null || git pull
    info "Regenerating configs..."
    "$UKE_ROOT/lib/gen.sh" all
    ok "UKE updated"
}

update_all() {
    echo ""
    printf "%sâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—%s\n" "$C_CYAN" "$C_RESET"
    printf "%sâ•‘%s        UKE Update Manager            %sâ•‘%s\n" "$C_CYAN" "$C_BOLD" "$C_CYAN" "$C_RESET"
    printf "%sâ•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•%s\n" "$C_CYAN" "$C_RESET"
    echo ""
    
    show_news
    
    # Check disk space
    local free=$(df -BG / | awk 'NR==2 {print $4}' | tr -d 'G')
    if [[ $free -lt 2 ]]; then
        fail "Low disk space: ${free}GB free. Need at least 2GB."
        info "Run: uke-update --clean"
        exit 1
    fi
    
    # Refresh mirrors first (for faster downloads)
    refresh_mirrors
    echo ""
    
    update_system
    echo ""
    [[ -n "$AUR_HELPER" ]] && update_aur
    echo ""
    update_uke
    
    # Check if kernel was updated
    local current_kernel=$(uname -r | sed 's/-arch.*//')
    local installed_kernel=$(pacman -Q linux 2>/dev/null | awk '{print $2}' | sed 's/\.arch.*//')
    if [[ "$current_kernel" != "$installed_kernel" ]]; then
        echo ""
        warn "Kernel updated ($current_kernel â†’ $installed_kernel). Reboot recommended!"
    fi
    
    echo ""
    ok "All updates complete!"
}

case "${1:---all}" in
    --check)    check_updates ;;
    --news)     show_news ;;
    --system)   update_system ;;
    --aur)      update_aur ;;
    --uke)      update_uke ;;
    --mirrors)  refresh_mirrors ;;
    --clean)    clean_cache; clean_orphans ;;
    --orphans)  clean_orphans ;;
    --all)      update_all ;;
    -h|--help)
        echo "Usage: uke-update [option]"
        echo "Options:"
        echo "  --check    Show pending updates"
        echo "  --news     Show Arch Linux news"
        echo "  --system   Update official packages only"
        echo "  --aur      Update AUR packages only"
        echo "  --uke      Update UKE only"
        echo "  --mirrors  Refresh mirror list (reflector)"
        echo "  --clean    Clean package cache & orphans"
        echo "  --orphans  Remove orphaned packages"
        echo "  --all      Update everything (default)"
        ;;
    *)          fail "Unknown option: $1" ;;
esac



################################################################################
FILE PATH: uke/config/registry.yaml
################################################################################

# ==============================================================================
# UKE Registry v7.0 - Single Source of Truth
# ==============================================================================
# This file defines all software preferences, keybindings, and app assignments.
# Hardware-specific settings are in machine.profile (see: uke profile)
#
# After editing: uke gen && uke reload
# ==============================================================================

version: "7.0.0"

# ==============================================================================
# Theme / Colorscheme
# ==============================================================================
# Colors used across all generated configs (Nord theme)
theme:
  name: "nord"
  colors:
    accent: "#88c0d0"
    background: "#2e3440"
    bg_light: "#3b4252"
    foreground: "#eceff4"
    border_active: "88c0d0"      # Without # for yabai/hyprland
    border_inactive: "3b4252"
    red: "#bf616a"
    green: "#a3be8c"
    yellow: "#ebcb8b"
    blue: "#5e81ac"

# ==============================================================================
# Modifiers
# ==============================================================================
# Maps logical modifier names to physical keys per platform
# PRIMARY: Window manager operations (focus, move, workspaces)
# SECONDARY: Terminal/WezTerm internals
# TERTIARY: Window resizing
# QUATERNARY: Shell signals (Ctrl+C, etc.) - NEVER intercepted
modifiers:
  primary:        { macos: "cmd",           linux: "ALT" }
  primary_shift:  { macos: "cmd + shift",   linux: "ALT SHIFT" }
  secondary:      { macos: "alt",           linux: "SUPER" }
  secondary_shift: { macos: "alt + shift",  linux: "SUPER SHIFT" }
  tertiary:       { macos: "alt + shift",   linux: "SUPER SHIFT" }
  quaternary:     { macos: "ctrl",          linux: "CTRL" }
  bunch:          { macos: "cmd + ctrl",    linux: "ALT CTRL" }
  launcher:       { macos: "cmd + alt",     linux: "ALT SUPER" }

# ==============================================================================
# Custom Keybindings
# ==============================================================================
# These generate additional keybindings beyond standard WM controls
keybindings:
  # Toggle sticky window (floating + pinned + always-on-top)
  sticky:
    key: "s"
    mod: "primary_shift"
    action: "exec"
    command: "uke-sticky toggle"
  
  # Quick fix
  quickfix:
    key: "f"
    mod: "primary_shift"
    action: "exec"
    command: "uke-fix"

# ==============================================================================
# Applications
# ==============================================================================
# Maps app nicknames to actual app names per platform
apps:
  # Browsers
  safari:      { macos: "Safari",           linux: "" }
  brave:       { macos: "Brave Browser",    linux: "brave" }
  firefox:     { macos: "Firefox",          linux: "firefox" }
  chrome:      { macos: "Google Chrome",    linux: "google-chrome-stable" }
  
  # Notes & Knowledge
  obsidian:    { macos: "Obsidian",         linux: "obsidian" }
  notion:      { macos: "Notion",           linux: "notion-app" }
  
  # Documents
  preview:     { macos: "Preview",          linux: "evince" }
  pdfexpert:   { macos: "PDF Expert",       linux: "" }
  zathura:     { macos: "",                 linux: "zathura" }
  okular:      { macos: "",                 linux: "okular" }
  
  # Development
  wezterm:     { macos: "WezTerm",          linux: "wezterm" }
  alacritty:   { macos: "Alacritty",        linux: "alacritty" }
  kitty:       { macos: "kitty",            linux: "kitty" }
  code:        { macos: "Visual Studio Code", linux: "code" }
  codium:      { macos: "VSCodium",         linux: "codium" }
  xcode:       { macos: "Xcode",            linux: "" }
  cursor:      { macos: "Cursor",           linux: "cursor" }
  
  # Media
  spotify:     { macos: "Spotify",          linux: "spotify" }
  music:       { macos: "Music",            linux: "" }
  
  # Bookmarks
  raindrop:    { macos: "Raindrop.io",      linux: "raindrop" }
  
  # Office
  word:        { macos: "Microsoft Word",       linux: "libreoffice-writer" }
  excel:       { macos: "Microsoft Excel",      linux: "libreoffice-calc" }
  powerpoint:  { macos: "Microsoft PowerPoint", linux: "libreoffice-impress" }
  pages:       { macos: "Pages",            linux: "" }
  numbers:     { macos: "Numbers",          linux: "" }
  keynote:     { macos: "Keynote",          linux: "" }
  libreoffice: { macos: "",                 linux: "libreoffice" }
  
  # Communication
  slack:       { macos: "Slack",            linux: "slack" }
  discord:     { macos: "Discord",          linux: "discord" }
  mail:        { macos: "Mail",             linux: "thunderbird" }
  telegram:    { macos: "Telegram",         linux: "telegram-desktop" }
  whatsapp:    { macos: "WhatsApp",         linux: "" }
  messages:    { macos: "Messages",         linux: "" }
  teams:       { macos: "Microsoft Teams",  linux: "teams" }
  
  # AI
  claude:      { macos: "Claude",           linux: "" }
  perplexity:  { macos: "Perplexity",       linux: "" }
  chatgpt:     { macos: "ChatGPT",          linux: "" }

# ==============================================================================
# Workspaces
# ==============================================================================
# Defines what apps belong on which workspace
# Apps will be automatically moved to their assigned workspace
workspaces:
  1:  { name: "browser",   apps: [safari, brave, firefox, chrome] }
  2:  { name: "notes",     apps: [obsidian, notion] }
  3:  { name: "code",      apps: [wezterm, alacritty, kitty, code, codium, xcode, cursor] }
  4:  { name: "catch-all", apps: [] }
  5:  { name: "documents", apps: [preview, pdfexpert, zathura, okular] }
  6:  { name: "raindrop",  apps: [raindrop] }
  7:  { name: "media",     apps: [spotify, music] }
  8:  { name: "office",    apps: [word, excel, powerpoint, pages, numbers, keynote, libreoffice] }
  9:  { name: "comms",     apps: [slack, discord, mail, telegram, whatsapp, messages, teams] }
  10: { name: "ai",        apps: [claude, perplexity, chatgpt] }

# ==============================================================================
# Scratchpads
# ==============================================================================
# Dropdown/toggle windows that appear on demand
scratchpads:
  terminal:
    app: wezterm
    key: "grave"           # backtick key (`)
    size: { width: 80, height: 40 }
    position: "top"
    
  notes:
    app: obsidian
    key: "n"
    size: { width: 60, height: 70 }
    position: "center"
    modifier: "launcher"   # Cmd+Alt on macOS, Alt+Super on Linux
    
  music:
    app: spotify
    key: "m"
    size: { width: 50, height: 60 }
    position: "center"
    modifier: "launcher"
    
  calc:
    app_macos: "Calculator"
    app_linux: "gnome-calculator"
    key: "c"
    size: { width: 30, height: 40 }
    position: "center"

# ==============================================================================
# Float Rules
# ==============================================================================
# Apps that should always float (not be tiled)
float_rules:
  - "System Settings"
  - "System Preferences"
  - "Calculator"
  - "Finder"
  - "App Store"
  - "Karabiner-Elements"
  - "Karabiner-EventViewer"
  - "Activity Monitor"
  - "Archive Utility"
  - "zoom.us"
  - "FaceTime"
  - "pavucontrol"
  - "nm-connection-editor"
  - "lxappearance"
  - "blueman-manager"

# ==============================================================================
# Window Rules
# ==============================================================================
# Fine-grained control over window behavior
window_rules:
  - match: { app: "zoom.us" }
    float: true
    sticky: true
    opacity: 1.0
    
  - match: { app: "FaceTime" }
    float: true
    sticky: true

  - match: { title: "Picture in Picture" }
    float: true
    sticky: true
    topmost: true
    size: { width: 400, height: 225 }

  - match: { title: "Preferences" }
    float: true
    center: true
    
  - match: { title: "Settings" }
    float: true
    center: true

# ==============================================================================
# Bunches (Environment Presets)
# ==============================================================================
# Pre-configured environments launched with Cmd+Ctrl+1-5 (macOS) / Alt+Ctrl+F1-F5 (Linux)
bunches:
  study:
    description: "Study and note-taking environment"
    focus: 2
    apps: [obsidian, brave, wezterm, preview]
    
  guitar:
    description: "Guitar practice with music"
    focus: 7
    apps: [spotify, brave]
    
  coding:
    description: "Development environment"
    focus: 3
    apps: [wezterm, code, brave]
    
  email:
    description: "Communication and admin"
    focus: 9
    apps: [mail, slack, brave]
    
  reading:
    description: "Focused reading"
    focus: 5
    apps: [preview, obsidian]

# ==============================================================================
# Window Manager Base Settings
# ==============================================================================
# Note: These can be overridden by machine.profile via ghost files
window_manager:
  macos:
    layout: bsp
    padding: 4
    gap: 4
    mouse_follows_focus: false
    focus_follows_mouse: false
    borders:
      enabled: true
      width: 3
      
  linux:
    layout: dwindle
    gaps_in: 2
    gaps_out: 4
    border_size: 2
    animations: true

# ==============================================================================
# Sessions
# ==============================================================================
sessions:
  storage: "~/.local/state/uke/sessions"
  autosave:
    enabled: false
    interval: 300
    name: "autosave"

# ==============================================================================
# Services (for uke-services)
# ==============================================================================
# Managed services that UKE monitors and can restart
services:
  system:
    - keyd              # Keyboard remapping
    - bluetooth         # Bluetooth (optional)
    - NetworkManager    # Network management
  
  user:
    - pipewire          # Audio server
    - pipewire-pulse    # PulseAudio compatibility
    - wireplumber       # Session manager
  
  hyprland:
    - waybar            # Status bar
    - dunst             # Notifications
    - hypridle          # Idle manager
    - hyprpaper         # Wallpaper



################################################################################
FILE PATH: uke/stow/nvim/.config/nvim/init.lua
################################################################################

-- ==============================================================================
-- UKE Neovim Configuration
-- ==============================================================================
-- Minimal neovim config - extend with your own plugins
-- ==============================================================================

-- ==============================================================================
-- Options
-- ==============================================================================
vim.opt.number = true
vim.opt.relativenumber = true
vim.opt.mouse = 'a'
vim.opt.ignorecase = true
vim.opt.smartcase = true
vim.opt.hlsearch = false
vim.opt.wrap = false
vim.opt.breakindent = true
vim.opt.tabstop = 4
vim.opt.shiftwidth = 4
vim.opt.expandtab = true
vim.opt.signcolumn = 'yes'
vim.opt.updatetime = 250
vim.opt.termguicolors = true
vim.opt.splitright = true
vim.opt.splitbelow = true
vim.opt.scrolloff = 8
vim.opt.undofile = true

-- ==============================================================================
-- Keymaps
-- ==============================================================================
vim.g.mapleader = ' '
vim.g.maplocalleader = ' '

-- Better navigation
vim.keymap.set('n', '<C-d>', '<C-d>zz')
vim.keymap.set('n', '<C-u>', '<C-u>zz')
vim.keymap.set('n', 'n', 'nzzzv')
vim.keymap.set('n', 'N', 'Nzzzv')

-- Better indenting
vim.keymap.set('v', '<', '<gv')
vim.keymap.set('v', '>', '>gv')

-- Move lines
vim.keymap.set('v', 'J', ":m '>+1<CR>gv=gv")
vim.keymap.set('v', 'K', ":m '<-2<CR>gv=gv")

-- Window navigation
vim.keymap.set('n', '<C-h>', '<C-w>h')
vim.keymap.set('n', '<C-j>', '<C-w>j')
vim.keymap.set('n', '<C-k>', '<C-w>k')
vim.keymap.set('n', '<C-l>', '<C-w>l')

-- Buffer navigation
vim.keymap.set('n', '<S-h>', ':bprev<CR>')
vim.keymap.set('n', '<S-l>', ':bnext<CR>')

-- Quick save/quit
vim.keymap.set('n', '<leader>w', ':w<CR>')
vim.keymap.set('n', '<leader>q', ':q<CR>')

-- Clear search
vim.keymap.set('n', '<Esc>', ':noh<CR>')

-- System clipboard
vim.keymap.set({'n', 'v'}, '<leader>y', '"+y')
vim.keymap.set('n', '<leader>Y', '"+Y')
vim.keymap.set({'n', 'v'}, '<leader>p', '"+p')

-- ==============================================================================
-- Autocommands
-- ==============================================================================
-- Highlight on yank
vim.api.nvim_create_autocmd('TextYankPost', {
    callback = function()
        vim.highlight.on_yank()
    end,
})

-- Restore cursor position
vim.api.nvim_create_autocmd('BufReadPost', {
    callback = function()
        local mark = vim.api.nvim_buf_get_mark(0, '"')
        local lcount = vim.api.nvim_buf_line_count(0)
        if mark[1] > 0 and mark[1] <= lcount then
            pcall(vim.api.nvim_win_set_cursor, 0, mark)
        end
    end,
})

-- ==============================================================================
-- Colorscheme
-- ==============================================================================
-- Try to load Nord, fallback to built-in
local ok, _ = pcall(vim.cmd, 'colorscheme nord')
if not ok then
    vim.cmd('colorscheme habamax')  -- Good built-in dark theme
end



################################################################################
FILE PATH: uke/stow/keyd/.config/keyd/default.conf
################################################################################

# ==============================================================================
# UKE keyd Configuration
# ==============================================================================
# Caps Lock becomes a super-modifier with hjkl navigation
# 
# Install with: sudo ./scripts/keyd-setup.sh
# ==============================================================================

[ids]
*

[main]
# Caps Lock as a modal "nav" layer + Escape on tap
capslock = overload(nav, esc)

# Optional: Swap Left Alt and Left Super for Mac keyboards on Linux
# leftalt = leftmeta
# leftmeta = leftalt

[nav]
# Vim-style navigation
h = left
j = down
k = up
l = right

# Extended navigation
y = home
u = pageup
i = pagedown
o = end

# Word-wise movement (Ctrl+Arrow)
b = C-left
w = C-right

# Selection (Shift+Arrow) - using wasd
a = S-left
s = S-down
w = S-up
d = S-right

# Word selection (Ctrl+Shift+Arrow)
q = C-S-left
e = C-S-right

# Delete operations
x = delete
backspace = C-backspace

# Quick shortcuts
f = C-f      # Find
g = C-g      # Go to
n = C-n      # New
p = C-p      # Command palette style
z = C-z      # Undo

# Escape hatch - just in case
escape = capslock



################################################################################
FILE PATH: uke/stow/wezterm/.config/wezterm/wezterm.lua
################################################################################

-- ==============================================================================
-- UKE WezTerm Configuration v7.2 - Cross-Platform (FIXED)
-- ==============================================================================
-- SECONDARY Layer: Alt (macOS) / Super (Linux)
-- Conflict-free: Cmd stays with yabai, Alt handles terminal internals
-- ==============================================================================

local wezterm = require('wezterm')
local config = wezterm.config_builder()
local act = wezterm.action

-- ==============================================================================
-- OS Detection
-- ==============================================================================

local function is_macos()
  return wezterm.target_triple:find("darwin") ~= nil
end

local function is_linux()
  return wezterm.target_triple:find("linux") ~= nil
end

-- SECONDARY modifier: Alt on macOS, Super on Linux
local SECONDARY = is_macos() and "ALT" or "SUPER"

-- ==============================================================================
-- Load Hardware Config (Ghost File)
-- ==============================================================================
-- Try multiple paths to find the generated hardware config

local hw = nil
local hw_paths = {
  wezterm.config_dir .. '/generated_hardware.lua',
  os.getenv("HOME") .. '/.config/wezterm/generated_hardware.lua',
  os.getenv("HOME") .. '/.wezterm_hardware.lua',
}

for _, path in ipairs(hw_paths) do
  local ok, result = pcall(function()
    return dofile(path)
  end)
  if ok and result then
    hw = result
    break
  end
end

-- Defaults if ghost file is missing
if not hw then
  hw = {
    font_size = is_macos() and 14.0 or 11.0,
    is_macos = is_macos(),
    is_linux = is_linux(),
    front_end = "OpenGL",
    gpu = "integrated",
    keyboard = "standard",
    monitors = 1,
  }
end

-- ==============================================================================
-- Appearance
-- ==============================================================================

config.color_scheme = 'Catppuccin Mocha'

config.font = wezterm.font_with_fallback({
  'JetBrainsMono Nerd Font',
  'JetBrains Mono',
  'Fira Code',
  'Menlo',
  'Monaco',
  'monospace',
})

config.font_size = hw.font_size or (is_macos() and 14.0 or 11.0)
config.line_height = 1.2

-- Window
config.window_decorations = "RESIZE"
config.window_padding = {
  left = 8,
  right = 8,
  top = 8,
  bottom = 8,
}

config.window_background_opacity = 0.95
if is_macos() then
  config.macos_window_background_blur = 20
end

-- Tab bar
config.enable_tab_bar = true
config.use_fancy_tab_bar = false
config.tab_bar_at_bottom = true
config.hide_tab_bar_if_only_one_tab = true

-- Initial size
config.initial_cols = 120
config.initial_rows = 35

-- ==============================================================================
-- GPU / Rendering
-- ==============================================================================

config.front_end = hw.front_end or "OpenGL"
config.webgpu_power_preference = "HighPerformance"

-- ==============================================================================
-- Behavior
-- ==============================================================================

config.scrollback_lines = 10000
config.enable_scroll_bar = false
config.window_close_confirmation = "NeverPrompt"
config.check_for_updates = false

-- Cursor
config.default_cursor_style = 'BlinkingBlock'
config.cursor_blink_rate = 500

-- ==============================================================================
-- Keybindings (SECONDARY Layer)
-- ==============================================================================

config.keys = {
  -- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  -- Tab Management
  -- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  { key = "t", mods = SECONDARY, action = act.SpawnTab("CurrentPaneDomain") },

  -- Close pane (closes split first, then tab if no more panes)
  { key = "w", mods = SECONDARY, action = act.CloseCurrentPane({ confirm = false }) },
  { key = "x", mods = SECONDARY, action = act.CloseCurrentPane({ confirm = false }) },

  -- Tab navigation relative
  { key = "[", mods = SECONDARY, action = act.ActivateTabRelative(-1) },
  { key = "]", mods = SECONDARY, action = act.ActivateTabRelative(1) },

  -- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  -- Pane Splitting
  -- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  { key = "\\", mods = SECONDARY, action = act.SplitHorizontal({ domain = "CurrentPaneDomain" }) },
  { key = "-", mods = SECONDARY, action = act.SplitVertical({ domain = "CurrentPaneDomain" }) },
  { key = "d", mods = SECONDARY, action = act.SplitHorizontal({ domain = "CurrentPaneDomain" }) },
  { key = "D", mods = SECONDARY .. "|SHIFT", action = act.SplitVertical({ domain = "CurrentPaneDomain" }) },

  -- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  -- Pane Navigation (Vim-style)
  -- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  { key = "h", mods = SECONDARY, action = act.ActivatePaneDirection("Left") },
  { key = "j", mods = SECONDARY, action = act.ActivatePaneDirection("Down") },
  { key = "k", mods = SECONDARY, action = act.ActivatePaneDirection("Up") },
  { key = "l", mods = SECONDARY, action = act.ActivatePaneDirection("Right") },

  -- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  -- Pane Resizing (SECONDARY + Shift)
  -- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  { key = "H", mods = SECONDARY .. "|SHIFT", action = act.AdjustPaneSize({ "Left", 5 }) },
  { key = "J", mods = SECONDARY .. "|SHIFT", action = act.AdjustPaneSize({ "Down", 5 }) },
  { key = "K", mods = SECONDARY .. "|SHIFT", action = act.AdjustPaneSize({ "Up", 5 }) },
  { key = "L", mods = SECONDARY .. "|SHIFT", action = act.AdjustPaneSize({ "Right", 5 }) },

  -- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  -- Utilities
  -- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  { key = "z", mods = SECONDARY, action = act.TogglePaneZoomState },
  { key = "f", mods = SECONDARY, action = act.Search({ CaseInSensitiveString = "" }) },
  { key = "r", mods = SECONDARY, action = act.ReloadConfiguration },
  { key = "p", mods = SECONDARY, action = act.ActivateCommandPalette },

  -- Copy mode
  { key = "c", mods = SECONDARY .. "|SHIFT", action = act.ActivateCopyMode },

  -- Quick select (like tmux fingers)
  { key = "Space", mods = SECONDARY, action = act.QuickSelect },

  -- Font size
  { key = "=", mods = SECONDARY, action = act.IncreaseFontSize },
  { key = "+", mods = SECONDARY .. "|SHIFT", action = act.IncreaseFontSize },
  { key = "0", mods = SECONDARY, action = act.ResetFontSize },
}

-- Tab navigation with numbers (1-9)
for i = 1, 9 do
  table.insert(config.keys, {
    key = tostring(i),
    mods = SECONDARY,
    action = act.ActivateTab(i - 1),
  })
end

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- Mouse Bindings
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

config.mouse_bindings = {
  -- Right click to paste
  {
    event = { Down = { streak = 1, button = "Right" } },
    mods = "NONE",
    action = act.PasteFrom("Clipboard"),
  },
}

-- Keep default keybindings for system copy/paste
config.disable_default_key_bindings = false

return config


################################################################################
FILE PATH: uke/stow/zathura/.config/zathura/zathurarc
################################################################################

# UKE Zathura Configuration - Nord Theme
# ==============================================================================

# Appearance (Nord theme)
set default-bg                  "#2e3440"
set default-fg                  "#d8dee9"
set statusbar-bg                "#3b4252"
set statusbar-fg                "#d8dee9"
set inputbar-bg                 "#3b4252"
set inputbar-fg                 "#d8dee9"
set notification-bg             "#3b4252"
set notification-fg             "#d8dee9"
set notification-error-bg       "#bf616a"
set notification-error-fg       "#2e3440"
set notification-warning-bg     "#ebcb8b"
set notification-warning-fg     "#2e3440"
set highlight-color             "#ebcb8b"
set highlight-active-color      "#88c0d0"
set completion-bg               "#3b4252"
set completion-fg               "#d8dee9"
set completion-highlight-bg     "#88c0d0"
set completion-highlight-fg     "#2e3440"
set recolor-lightcolor          "#2e3440"
set recolor-darkcolor           "#eceff4"

# Behavior
set selection-clipboard         clipboard
set window-title-basename       true
set statusbar-home-tilde        true
set adjust-open                 "best-fit"
set scroll-page-aware           true
set smooth-scroll               true
set scroll-step                 80
set zoom-step                   10
set guioptions                  ""

# Recolor for dark mode (toggle with i)
set recolor                     true
set recolor-keephue             true

# Keybindings
map <C-=> zoom in
map <C--> zoom out
map <C-0> zoom default
map D toggle_page_mode
map r reload
map R rotate
map i recolor
map p print



################################################################################
FILE PATH: uke/stow/tmux/.tmux.conf
################################################################################

# ==============================================================================
# UKE Tmux Configuration
# ==============================================================================
# Minimal tmux config that complements UKE window management
# ==============================================================================

# ==============================================================================
# General
# ==============================================================================
set -g default-terminal "tmux-256color"
set -ag terminal-overrides ",xterm-256color:RGB"
set -g mouse on
set -g history-limit 50000
set -g base-index 1
setw -g pane-base-index 1
set -g renumber-windows on
set -s escape-time 0

# ==============================================================================
# Prefix
# ==============================================================================
# Use Ctrl+Space as prefix (doesn't conflict with UKE modifiers)
unbind C-b
set -g prefix C-Space
bind C-Space send-prefix

# ==============================================================================
# Keybindings
# ==============================================================================
# Reload config
bind r source-file ~/.tmux.conf \; display "Config reloaded!"

# Split panes (same as WezTerm for muscle memory)
bind d split-window -h -c "#{pane_current_path}"
bind D split-window -v -c "#{pane_current_path}"

# Vim-style pane navigation
bind h select-pane -L
bind j select-pane -D
bind k select-pane -U
bind l select-pane -R

# Resize panes
bind -r H resize-pane -L 5
bind -r J resize-pane -D 5
bind -r K resize-pane -U 5
bind -r L resize-pane -R 5

# New window
bind c new-window -c "#{pane_current_path}"

# Kill pane/window without confirmation
bind x kill-pane
bind X kill-window

# Zoom
bind z resize-pane -Z

# ==============================================================================
# Copy Mode (Vi-style)
# ==============================================================================
setw -g mode-keys vi
bind -T copy-mode-vi v send -X begin-selection
bind -T copy-mode-vi y send -X copy-selection-and-cancel
bind -T copy-mode-vi Escape send -X cancel

# ==============================================================================
# Status Bar (Nord theme)
# ==============================================================================
set -g status-position top
set -g status-style "bg=#3b4252,fg=#eceff4"
set -g status-left "#[bg=#5e81ac,fg=#eceff4,bold] #S #[bg=#3b4252] "
set -g status-left-length 30
set -g status-right "#[fg=#88c0d0]%H:%M #[fg=#4c566a]| #[fg=#a3be8c]%d-%b"
set -g status-right-length 50

# Window status
setw -g window-status-format " #I:#W "
setw -g window-status-current-format "#[bg=#88c0d0,fg=#2e3440,bold] #I:#W #[bg=#3b4252]"
setw -g window-status-separator ""

# Pane borders
set -g pane-border-style "fg=#4c566a"
set -g pane-active-border-style "fg=#88c0d0"

# Message style
set -g message-style "bg=#ebcb8b,fg=#2e3440,bold"



################################################################################
FILE PATH: uke/stow/zsh/.zshrc
################################################################################

# ==============================================================================
# UKE ZSH Configuration v7.2 - Cross-Platform
# ==============================================================================
# Works on both macOS and Linux (Arch)
# ==============================================================================

# ==============================================================================
# OS Detection
# ==============================================================================
case "$(uname -s)" in
    Darwin*) export UKE_OS="macos" ;;
    Linux*)  export UKE_OS="linux" ;;
    *)       export UKE_OS="unknown" ;;
esac

# ==============================================================================
# Path Configuration
# ==============================================================================
export PATH="$HOME/.local/bin:$PATH"
export UKE_ROOT="${UKE_ROOT:-$HOME/dotfiles/uke}"

# Add UKE bin to path
[[ -d "$UKE_ROOT/bin" ]] && export PATH="$UKE_ROOT/bin:$PATH"

# Platform-specific paths
if [[ "$UKE_OS" == "macos" ]]; then
    # Homebrew (Apple Silicon first, then Intel)
    [[ -f "/opt/homebrew/bin/brew" ]] && eval "$(/opt/homebrew/bin/brew shellenv)"
    [[ -f "/usr/local/bin/brew" ]] && eval "$(/usr/local/bin/brew shellenv)"
fi

# ==============================================================================
# History
# ==============================================================================
HISTFILE=~/.zsh_history
HISTSIZE=50000
SAVEHIST=50000
setopt SHARE_HISTORY
setopt HIST_IGNORE_DUPS
setopt HIST_IGNORE_SPACE
setopt HIST_FIND_NO_DUPS
setopt HIST_VERIFY
setopt INC_APPEND_HISTORY
setopt APPEND_HISTORY

# ==============================================================================
# Directory Navigation
# ==============================================================================
setopt AUTO_CD
setopt AUTO_PUSHD
setopt PUSHD_IGNORE_DUPS
setopt PUSHD_SILENT

# ==============================================================================
# Completion
# ==============================================================================
autoload -Uz compinit
compinit -C

zstyle ':completion:*' menu select
zstyle ':completion:*' matcher-list 'm:{a-zA-Z}={A-Za-z}'
zstyle ':completion:*' list-colors "${(s.:.)LS_COLORS}"
zstyle ':completion:*:descriptions' format '%F{yellow}-- %d --%f'

# ==============================================================================
# Key Bindings (Emacs mode)
# ==============================================================================
bindkey -e
bindkey '^[[A' history-search-backward
bindkey '^[[B' history-search-forward
bindkey '^[[H' beginning-of-line
bindkey '^[[F' end-of-line
bindkey '^[[3~' delete-char

# ==============================================================================
# Environment Variables
# ==============================================================================
export EDITOR="${EDITOR:-nvim}"
export VISUAL="${VISUAL:-nvim}"
export PAGER='less'
export LESS='-R'
export LANG=en_US.UTF-8
export LC_ALL=en_US.UTF-8

# ==============================================================================
# Aliases - Universal
# ==============================================================================
# Navigation
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias -- -='cd -'

# Listing (prefer eza, fall back to ls)
if command -v eza &>/dev/null; then
    alias ls='eza --icons'
    alias ll='eza -la --icons --git'
    alias la='eza -a --icons'
    alias lt='eza --tree --level=2 --icons'
    alias l='eza -l --icons'
else
    if [[ "$UKE_OS" == "macos" ]]; then
        alias ls='ls -G'
    else
        alias ls='ls --color=auto'
    fi
    alias ll='ls -lah'
    alias la='ls -a'
fi

# Safety
alias rm='rm -i'
alias mv='mv -i'
alias cp='cp -i'

# Better defaults
alias grep='grep --color=auto'
alias df='df -h'
alias du='du -h'
alias free='free -h' 2>/dev/null || true

# Editor
alias v='$EDITOR'
alias vim='$EDITOR'
alias vimrc='$EDITOR ~/.config/nvim/init.lua'
alias zshrc='$EDITOR ~/.zshrc'
alias reload='source ~/.zshrc'

# Git shortcuts
alias g='git'
alias gs='git status'
alias ga='git add'
alias gc='git commit'
alias gp='git push'
alias gl='git log --oneline --graph --decorate -20'
alias gd='git diff'
alias gco='git checkout'
alias gb='git branch'
gcl() { git clone "$1" && cd "$(basename "$1" .git)"; }

# Tmux
alias ta='tmux attach'
alias tn='tmux new -s'
alias tl='tmux list-sessions'
alias tmuxrc='$EDITOR ~/.tmux.conf'

# UKE shortcuts
alias ug='uke gen'
alias ur='uke reload'
alias us='uke status'
alias ud='uke doctor'
alias up='uke profile'
alias ua='uke apply'
alias uf='uke-fix'
alias uu='uke-update'
alias usv='uke-services'
alias b='uke-bunch'
alias uke-edit='uke edit'
alias uke-reload='uke gen && uke reload'

# Dotfiles
alias dots='cd ~/dotfiles'

# Network
alias myip='curl -s ifconfig.me'

# ==============================================================================
# Aliases - Platform Specific
# ==============================================================================
if [[ "$UKE_OS" == "macos" ]]; then
    # macOS Window Manager
    alias yabai-restart='yabai --restart-service'
    alias skhd-restart='skhd --restart-service'
    alias yabai-log='tail -f /tmp/yabai_*.err.log'
    alias skhd-log='tail -f /tmp/skhd_*.err.log'
    
    # macOS Directories
    alias dl='cd ~/Downloads'
    alias desk='cd ~/Desktop'
    
    # macOS Utilities
    alias ports='lsof -i -P'
    alias flushdns='sudo dscacheutil -flushcache; sudo killall -HUP mDNSResponder'
else
    # Linux (Hyprland)
    alias hypr-restart='hyprctl reload'
    alias hypr-log='cat ~/.hyprland.log'
    
    # Systemd
    alias sc='systemctl'
    alias scu='systemctl --user'
    
    # Clipboard (Wayland)
    if command -v wl-copy &>/dev/null; then
        alias pbcopy='wl-copy'
        alias pbpaste='wl-paste'
    fi
    
    # Arch Linux
    if [[ -f /etc/arch-release ]]; then
        alias pac='sudo pacman'
        alias pacs='sudo pacman -S'
        alias pacr='sudo pacman -Rns'
        alias pacq='pacman -Qs'
        alias pacu='uke-update --all'
        
        if command -v yay &>/dev/null; then
            alias yayu='yay -Syu'
            alias yays='yay -Ss'
        fi
    fi
fi

# ==============================================================================
# Functions
# ==============================================================================
mkcd() { mkdir -p "$1" && cd "$1"; }

extract() {
    [[ -f "$1" ]] || { echo "'$1' is not a valid file"; return 1; }
    case "$1" in
        *.tar.bz2) tar xjf "$1" ;;
        *.tar.gz)  tar xzf "$1" ;;
        *.bz2)     bunzip2 "$1" ;;
        *.gz)      gunzip "$1" ;;
        *.tar)     tar xf "$1" ;;
        *.tbz2)    tar xjf "$1" ;;
        *.tgz)     tar xzf "$1" ;;
        *.zip)     unzip "$1" ;;
        *.7z)      7z x "$1" ;;
        *)         echo "'$1' cannot be extracted" ;;
    esac
}

ff() { find . -type f -iname "*$1*"; }

# Stow helpers
stowit()   { cd ~/dotfiles && stow "$@" && cd - >/dev/null; }
unstowit() { cd ~/dotfiles && stow -D "$@" && cd - >/dev/null; }
restowit() { cd ~/dotfiles && stow -R "$@" && cd - >/dev/null; }

# Show current workspace
workspace() {
    if [[ "$UKE_OS" == "macos" ]]; then
        yabai -m query --spaces --space 2>/dev/null | jq -r '.index'
    else
        hyprctl activeworkspace 2>/dev/null | grep "workspace ID" | awk '{print $3}'
    fi
}

# Environment info
envinfo() {
    echo "OS: $UKE_OS"
    echo "Shell: $SHELL"
    echo "Editor: $EDITOR"
    [[ -n "$TMUX" ]] && echo "Tmux: $(tmux display-message -p '#S')" || echo "Tmux: -"
    echo "Workspace: $(workspace 2>/dev/null || echo '-')"
}

# ==============================================================================
# FZF Integration
# ==============================================================================
if command -v fzf &>/dev/null; then
    # Source fzf - try different paths
    if [[ "$UKE_OS" == "macos" ]]; then
        [[ -f ~/.fzf.zsh ]] && source ~/.fzf.zsh
        # Homebrew fzf
        [[ -f /opt/homebrew/opt/fzf/shell/key-bindings.zsh ]] && source /opt/homebrew/opt/fzf/shell/key-bindings.zsh
        [[ -f /opt/homebrew/opt/fzf/shell/completion.zsh ]] && source /opt/homebrew/opt/fzf/shell/completion.zsh
    else
        [[ -f /usr/share/fzf/key-bindings.zsh ]] && source /usr/share/fzf/key-bindings.zsh
        [[ -f /usr/share/fzf/completion.zsh ]] && source /usr/share/fzf/completion.zsh
    fi
    
    # Try new fzf --zsh syntax (fzf 0.48+)
    source <(fzf --zsh 2>/dev/null) || true
    
    # FZF theme (Nord-inspired, works with Catppuccin too)
    export FZF_DEFAULT_OPTS="
        --height 40% --layout=reverse --border
        --color=bg+:#3b4252,bg:#2e3440,spinner:#81a1c1,hl:#88c0d0
        --color=fg:#d8dee9,header:#88c0d0,info:#5e81ac,pointer:#81a1c1
        --color=marker:#88c0d0,fg+:#d8dee9,prompt:#81a1c1,hl+:#88c0d0
    "
    
    # Use fd if available (faster than find)
    if command -v fd &>/dev/null; then
        export FZF_DEFAULT_COMMAND='fd --type f --hidden --follow --exclude .git'
        export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"
        export FZF_ALT_C_COMMAND='fd --type d --hidden --follow --exclude .git'
    fi
    
    # Fuzzy cd with preview
    fcd() {
        local dir
        dir=$(fd --type d --hidden --follow --exclude .git 2>/dev/null | fzf --preview 'eza --tree --level=1 --icons {} 2>/dev/null || ls -la {}') && cd "$dir"
    }
    
    # Fuzzy history
    fh() {
        print -z $(fc -l 1 | fzf +s --tac | sed 's/ *[0-9]* *//')
    }
    
    # Fuzzy kill process
    fkill() {
        local pid
        pid=$(ps -ef | sed 1d | fzf -m | awk '{print $2}')
        if [[ -n "$pid" ]]; then
            echo "$pid" | xargs kill -${1:-9}
        fi
    }
fi

# ==============================================================================
# Zoxide (smart cd)
# ==============================================================================
if command -v zoxide &>/dev/null; then
    eval "$(zoxide init zsh)"
    alias cd='z'
fi

# ==============================================================================
# Prompt
# ==============================================================================
# Use Starship if available, otherwise custom prompt
if command -v starship &>/dev/null; then
    eval "$(starship init zsh)"
else
    # Custom prompt with git integration
    autoload -Uz vcs_info
    precmd() { vcs_info }
    
    zstyle ':vcs_info:git:*' formats ' %F{yellow}(%b)%f'
    zstyle ':vcs_info:git:*' actionformats ' %F{yellow}(%b|%a)%f'
    setopt PROMPT_SUBST
    
    # Two-line prompt with path and git
    PROMPT='%F{blue}%~%f${vcs_info_msg_0_}
%F{cyan}â¯%f '
    
    # Right prompt with time
    RPROMPT='%F{8}%T%f'
fi

# ==============================================================================
# Window Title
# ==============================================================================
case $TERM in
    xterm*|rxvt*|alacritty|wezterm|foot)
        precmd() {
            [[ -z "${STARSHIP_SHELL:-}" ]] && vcs_info
            print -Pn "\e]0;%~\a"
        }
        preexec() {
            print -Pn "\e]0;$1\a"
        }
        ;;
esac

# ==============================================================================
# Plugins
# ==============================================================================
# zsh-autosuggestions
if [[ "$UKE_OS" == "macos" ]]; then
    [[ -f /opt/homebrew/share/zsh-autosuggestions/zsh-autosuggestions.zsh ]] && \
        source /opt/homebrew/share/zsh-autosuggestions/zsh-autosuggestions.zsh
else
    [[ -f /usr/share/zsh/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh ]] && \
        source /usr/share/zsh/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh
fi

# zsh-syntax-highlighting (must be last plugin)
if [[ "$UKE_OS" == "macos" ]]; then
    [[ -f /opt/homebrew/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh ]] && \
        source /opt/homebrew/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
else
    [[ -f /usr/share/zsh/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh ]] && \
        source /usr/share/zsh/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
fi

# ==============================================================================
# Local Overrides
# ==============================================================================
[[ -f ~/.zshrc.local ]] && source ~/.zshrc.local



################################################################################
FILE PATH: uke/stow/zsh/.zprofile
################################################################################

# ==============================================================================
# UKE ZSH Profile
# ==============================================================================
# Login shell configuration - runs once at login
# ==============================================================================

# ==============================================================================
# Environment
# ==============================================================================
export LANG=en_US.UTF-8
export LC_ALL=en_US.UTF-8

# XDG Base Directory
export XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.config}"
export XDG_DATA_HOME="${XDG_DATA_HOME:-$HOME/.local/share}"
export XDG_STATE_HOME="${XDG_STATE_HOME:-$HOME/.local/state}"
export XDG_CACHE_HOME="${XDG_CACHE_HOME:-$HOME/.cache}"

# Path
export PATH="$HOME/.local/bin:$PATH"

# UKE
export UKE_ROOT="${UKE_ROOT:-$HOME/dotfiles/uke}"

# ==============================================================================
# Platform-Specific Login Setup
# ==============================================================================
case "$(uname -s)" in
    Darwin)
        # macOS: Setup Homebrew in login shell
        [[ -f "/opt/homebrew/bin/brew" ]] && eval "$(/opt/homebrew/bin/brew shellenv)"
        [[ -f "/usr/local/bin/brew" ]] && eval "$(/usr/local/bin/brew shellenv)"
        ;;
    Linux)
        # ==============================================================================
        # Linux (Arch): Hyprland Auto-start on TTY1
        # ==============================================================================
        # SAFETY: Only runs on TTY1, not in graphical environment
        # ESCAPE HATCH: Hold Ctrl+C during login to skip, or create ~/.no-hyprland
        # TO DISABLE: Remove this block or create ~/.no-hyprland
        # ==============================================================================
        
        # Skip autostart conditions:
        # - Already in X or Wayland
        # - Not on TTY1
        # - Escape file exists
        # - NOAUTOSTART environment variable set
        if [[ -z "${DISPLAY:-}" ]] && \
           [[ -z "${WAYLAND_DISPLAY:-}" ]] && \
           [[ "${XDG_VTNR:-}" == "1" ]] && \
           [[ ! -f "$HOME/.no-hyprland" ]] && \
           [[ -z "${NOAUTOSTART:-}" ]]; then
            
            # Give user 2 seconds to press Ctrl+C to abort
            echo "Starting Hyprland in 2 seconds... (Ctrl+C to cancel, or create ~/.no-hyprland)"
            sleep 2
            
            # Check if Hyprland is actually installed and working
            if command -v Hyprland &>/dev/null; then
                # Use exec only if we're confident it will work
                # If it fails, we fall through to normal shell
                Hyprland || {
                    echo "Hyprland failed to start!"
                    echo "To disable autostart: touch ~/.no-hyprland"
                    echo "Dropping to shell..."
                }
            else
                echo "Hyprland not found. Install with: sudo pacman -S hyprland"
            fi
        fi
        ;;
esac



################################################################################
FILE PATH: uke/docs/MACOS-SIP.md
################################################################################

# macOS SIP Configuration for Yabai

## Overview

System Integrity Protection (SIP) restricts certain operations on macOS. Yabai requires partial SIP modification for full functionality.

## Feature Comparison

| Feature | SIP Enabled | SIP Partial |
|:--------|:------------|:------------|
| Window focus | âœ“ | âœ“ |
| Window resize | âœ“ | âœ“ |
| Window move | âœ“ | âœ“ |
| Space switching | âœ— | âœ“ |
| Space creation | âœ— | âœ“ |
| Move to space | âœ— | âœ“ |

**Bottom line:** For UKE's workspace management features, you need partial SIP.

## Checking SIP Status

```bash
csrutil status
```

## Modifying SIP (Apple Silicon)

1. **Shut down** your Mac completely

2. **Boot to Recovery:**
   - Hold power button until "Loading startup options" appears
   - Select "Options" â†’ Continue

3. **Open Terminal** from Utilities menu

4. **Run command:**
   ```bash
   csrutil enable --without fs --without debug --without nvram
   ```

5. **Reboot**

6. **Enable ARM64E ABI:**
   ```bash
   sudo nvram boot-args=-arm64e_preview_abi
   ```

7. **Reboot again**

## Modifying SIP (Intel Mac)

1. **Shut down** your Mac completely

2. **Boot to Recovery:**
   - Hold Cmd+R during startup

3. **Open Terminal** from Utilities menu

4. **Run command:**
   ```bash
   csrutil enable --without fs --without debug --without nvram
   ```

5. **Reboot**

## Loading the Scripting Addition

After SIP modification, yabai's scripting addition must be loaded:

```bash
# Add to sudoers for password-less loading
echo "$(whoami) ALL=(root) NOPASSWD: sha256:$(shasum -a 256 $(which yabai) | cut -d " " -f 1) $(which yabai) --load-sa" | sudo tee /private/etc/sudoers.d/yabai

# Load the scripting addition
sudo yabai --load-sa
```

The yabairc config already includes `sudo yabai --load-sa`.

## Verifying

```bash
# Check SIP status
csrutil status

# Test space switching
yabai -m space --focus 2
```

## Reverting

To restore full SIP:

1. Boot to Recovery
2. Run: `csrutil enable`
3. Reboot

## Security Considerations

Partially disabling SIP reduces system protections. The specific flags disabled:

- `fs`: Filesystem protections (needed for yabai injection)
- `debug`: Debugging restrictions
- `nvram`: Boot argument modifications

This is a trade-off between functionality and security. Consider your threat model.

## References

- [Yabai Wiki: Disabling SIP](https://github.com/koekeishiya/yabai/wiki/Disabling-System-Integrity-Protection)
- [Apple: About SIP](https://support.apple.com/en-us/HT204899)



################################################################################
FILE PATH: uke/docs/README.md
################################################################################

# UKE - Unified Keyboard Environment v7.2

A cross-platform keyboard-driven workflow system with comprehensive Arch Linux management.

## What's New in v7.2

### Core Features
- **`uke-services`** - Service health monitoring (reads from registry.yaml)
- **`uke-update`** - Unified updates with mirror optimization & cache cleaning
- **`uke-fix`** - Quick fixes with auto-detection & cache cleanup
- **`uke-setup`** - First-boot wizard with safe sudo handling
- **`uke-backup`** - Enhanced backup with full restore capability
- **`uke-snapshot`** - System snapshots (btrfs/snapper/timeshift)

### QoL Improvements
- **`uke-launch`** - Smart file type detection (PDFs open in zathura)
- **Mirror optimization** - reflector integration for faster updates
- **Cache cleaning** - paccache & orphan removal built-in
- **fzf integration** - Fuzzy history (Ctrl+R), file search (Ctrl+T)
- **Service definitions in YAML** - Configure services in registry.yaml

### New Stow Packages
- **zathura/** - Vim-like PDF viewer with Nord theme
- Enhanced **.zshrc** with fzf, better aliases, UKE shortcuts

## Quick Start

### Fresh Arch Install
```bash
git clone <repo> ~/dotfiles/uke
cd ~/dotfiles/uke
./bin/uke-setup
# Reboot - done!
```

### Existing System
```bash
cd ~/dotfiles/uke
./scripts/arch-check.sh
./scripts/install.sh
uke profile && uke apply
```

## Daily Commands

```bash
uke-update          # Update system + AUR + UKE + optimize mirrors
uke-update --clean  # Clean cache & orphans
uke-fix             # Auto-detect and fix issues
uke-services        # Check service status
```

## Update Manager

```bash
uke-update --check    # Show pending updates
uke-update --news     # Show Arch news
uke-update --mirrors  # Refresh mirror list
uke-update --clean    # Clean cache & orphans
uke-update --all      # Everything (default)
```

Features:
- Mirror optimization via reflector
- Package cache cleanup (keeps last 2 versions)
- Orphaned package removal
- Kernel update detection (reboot warning)

## Service Manager

Services are defined in `config/registry.yaml`:
```yaml
services:
  system: [keyd, bluetooth, NetworkManager]
  user: [pipewire, pipewire-pulse, wireplumber]
  hyprland: [waybar, dunst, hypridle, hyprpaper]
```

Commands:
```bash
uke-services          # Status
uke-services restart  # Restart all
uke-services logs keyd
```

## Quick Fixes

```bash
uke-fix              # Auto-detect issues
uke-fix --audio      # Restart PipeWire
uke-fix --keys       # Restart keyd
uke-fix --cache      # Clean caches
uke-fix --all        # Fix everything
```

## Sticky Window

Make any window floating, always-on-top, and pinned to all workspaces:

```bash
uke-sticky toggle    # Toggle sticky mode (Alt+Shift+S / Cmd+Shift+S)
uke-sticky list      # Show all sticky windows
uke-sticky clear     # Reset all sticky windows
```

Perfect for keeping a terminal visible while working across workspaces.

**Keybinding:** `Alt+Shift+S` (Linux) / `Cmd+Shift+S` (macOS)

## Smart Launcher

```bash
uke-launch browser              # Open default browser
uke-launch ~/docs/paper.pdf     # Opens in zathura
uke-launch https://arch.org     # Opens URL
```

## Shell Features (fzf)

After installation, your shell has:
- **Ctrl+R** - Fuzzy history search
- **Ctrl+T** - Fuzzy file search
- **Alt+C** - Fuzzy cd
- **fcd** - Fuzzy cd with preview
- **fh** - Fuzzy history
- **fkill** - Fuzzy process kill

## Key Bindings

| Action | macOS | Linux |
|--------|-------|-------|
| Focus window | Cmd+hjkl | Alt+hjkl |
| Move window | Cmd+Shift+hjkl | Alt+Shift+hjkl |
| Resize | Alt+Shift+hjkl | Super+Shift+hjkl |
| Switch workspace | Cmd+1-0 | Alt+1-0 |
| Terminal | Cmd+Return | Alt+Return |
| Launcher | Cmd+Space | Alt+Space |
| Sticky toggle | Cmd+Shift+S | Alt+Shift+S |
| Quick fix | Cmd+Shift+X | Alt+Shift+F |

## Directory Structure

```
uke/
â”œâ”€â”€ bin/                    # CLI tools
â”‚   â”œâ”€â”€ uke-services        # Service manager
â”‚   â”œâ”€â”€ uke-update          # Update manager
â”‚   â”œâ”€â”€ uke-fix             # Quick fixes
â”‚   â”œâ”€â”€ uke-setup           # First-boot wizard
â”‚   â”œâ”€â”€ uke-launch          # Smart launcher
â”‚   â””â”€â”€ ...
â”œâ”€â”€ config/
â”‚   â””â”€â”€ registry.yaml       # Single source of truth
â”œâ”€â”€ stow/
â”‚   â”œâ”€â”€ zathura/            # PDF viewer
â”‚   â”œâ”€â”€ zsh/                # Shell with fzf
â”‚   â””â”€â”€ ...
â””â”€â”€ scripts/
    â””â”€â”€ arch-check.sh       # Package checker
```

## Troubleshooting

### Low disk space
```bash
uke-update --clean
```

### Slow updates
```bash
uke-update --mirrors
```

### Audio not working
```bash
uke-fix --audio
```

### Check everything
```bash
uke doctor
uke-services
```



################################################################################
FILE PATH: uke/docs/PHILOSOPHY.md
################################################################################

# UKE Philosophy: Implementing Features the Right Way

This document explains UKE's architectural principles and how to implement new features in a way that maintains consistency, portability, and maintainability.

## Core Principles

### 1. Single Source of Truth (SSOT)

**Everything derives from `registry.yaml`.**

The registry is the canonical definition of:
- Keybindings and their modifiers
- Application names (cross-platform)
- Workspace assignments
- Window rules
- Service definitions
- Scratchpad configurations

**Why this matters:** When you want to change a keybinding, you change it in ONE place. The generators (`gen.sh`) then produce platform-specific configs.

```yaml
# Good: Define once
keybindings:
  sticky:
    key: "s"
    mod: "primary_shift"
    command: "uke-sticky toggle"

# gen.sh produces:
# - Hyprland: bind = ALT SHIFT, S, exec, uke-sticky toggle
# - skhd:     cmd + shift - s : uke-sticky toggle
```

**Anti-pattern:** Never hardcode platform-specific keybindings directly in config files.

---

### 2. Modifier Abstraction

UKE uses **semantic modifiers** that map to platform-specific keys:

| Semantic | macOS | Linux |
|----------|-------|-------|
| `primary` | Cmd | Alt |
| `primary_shift` | Cmd+Shift | Alt+Shift |
| `secondary` | Alt | Super |
| `secondary_shift` | Alt+Shift | Super+Shift |
| `tertiary` | Alt+Shift | Super+Shift |
| `quaternary` | Ctrl | Ctrl |

**When implementing a new keybinding:**

1. Choose the appropriate semantic modifier based on the action's "tier":
   - `primary`: Core WM operations (focus, move windows)
   - `primary_shift`: Window manipulation (resize, special modes like sticky)
   - `secondary`: Terminal/app-internal bindings
   - `launcher`: Multi-key launchers (Cmd+Alt / Alt+Super)

2. Define it in `registry.yaml` using the semantic name
3. Let `gen.sh` handle the platform translation

---

### 3. Cross-Platform Command Abstraction

Commands should be **platform-agnostic wrappers** that detect the environment and call the appropriate tool.

**Pattern:**

```bash
#!/usr/bin/env bash
# uke-<feature>

if is_linux; then
    if [[ -n "${HYPRLAND_INSTANCE_SIGNATURE:-}" ]]; then
        hyprland_implementation
    fi
elif is_macos; then
    yabai_implementation
fi
```

**Example: `uke-sticky`**

```bash
# The command abstracts away:
# - Hyprland: hyprctl dispatch togglefloating + pin
# - Yabai: yabai -m window --toggle float/sticky/topmost

# User just runs: uke-sticky toggle
# Works identically on both platforms
```

**Anti-pattern:** Don't create `uke-sticky-hyprland` and `uke-sticky-yabai`. One command, multiple implementations.

---

### 4. State Management

For features that need to track state (like sticky windows), use:

```
$XDG_STATE_HOME/uke/  (~/.local/state/uke/)
â”œâ”€â”€ sticky_windows      # List of sticky window IDs
â”œâ”€â”€ crash_count         # Autostart crash tracking
â”œâ”€â”€ machine.profile     # Hardware profile
â””â”€â”€ setup-state         # Setup wizard progress
```

**Why XDG_STATE_HOME?**
- `~/.config/` is for user-editable configuration
- `~/.local/state/` is for runtime state that can be regenerated
- `~/.local/share/` is for persistent user data (backups)

---

### 5. Ghost Files (Hardware Abstraction)

**Ghost files** are machine-specific configurations generated from the profile:

```
~/.config/hypr/generated_hardware.conf
~/.config/wezterm/generated_hardware.lua
```

These contain:
- GPU-specific settings (nvidia vs intel vs amd)
- Form factor adjustments (laptop vs desktop)
- Monitor configurations
- Font size scaling

**Why?**
- Same dotfiles work on multiple machines
- Hardware-specific tweaks don't pollute main configs
- `uke apply` regenerates them from `machine.profile`

**When adding hardware-dependent features:**

1. Add the setting to `scripts/apply_profile.sh`
2. Reference the ghost file in your stow config
3. Document the setting in the profile options

---

### 6. Graceful Degradation

Every UKE command should:

1. **Check prerequisites** before acting
2. **Fail gracefully** with helpful messages
3. **Work without optional dependencies** where possible

**Example:**

```bash
# Good: Check if we're in the right environment
if [[ -z "${HYPRLAND_INSTANCE_SIGNATURE:-}" ]]; then
    warn "Hyprland not running, skipping..."
    return 0
fi

# Good: Fallback when optional tool missing
if command -v reflector &>/dev/null; then
    reflector --latest 20 ...
else
    warn "reflector not installed, skipping mirror optimization"
fi
```

---

### 7. Generator Flow

```
registry.yaml
     â”‚
     â–¼
  gen.sh
     â”‚
     â”œâ”€â”€â–¶ gen/hyprland/keybinds.conf
     â”œâ”€â”€â–¶ gen/skhd/skhdrc
     â””â”€â”€â–¶ gen/yabai/yabairc

machine.profile
     â”‚
     â–¼
apply_profile.sh
     â”‚
     â”œâ”€â”€â–¶ ~/.config/hypr/generated_hardware.conf
     â””â”€â”€â–¶ ~/.config/wezterm/generated_hardware.lua
```

**When adding a new feature:**

1. Define it in `registry.yaml` (if it's a keybinding, app, or setting)
2. Update `gen.sh` to parse and output platform configs
3. Create the `uke-<feature>` command in `bin/`
4. If hardware-dependent, add to `apply_profile.sh`
5. Document in README.md

---

## Implementation Checklist

When adding a new feature, ask yourself:

### â˜ Is it defined in registry.yaml?
- Keybindings â†’ `keybindings:` section
- Apps â†’ `apps:` section  
- Services â†’ `services:` section
- Window rules â†’ `window_rules:` section

### â˜ Is it cross-platform?
- Single command with platform detection
- Uses semantic modifiers
- Tested on both macOS and Linux (or gracefully degrades)

### â˜ Does it follow UKE conventions?
- Script in `bin/` with `uke-` prefix
- Sources `lib/core.sh` for colors and helpers
- Uses `ok()`, `fail()`, `info()`, `warn()` for output
- Includes `--help` documentation
- Is executable (`chmod +x`)

### â˜ Is state properly managed?
- Runtime state â†’ `$XDG_STATE_HOME/uke/`
- User data â†’ `$XDG_DATA_HOME/uke/`
- Config â†’ `$XDG_CONFIG_HOME/uke/` or `$UKE_ROOT/config/`

### â˜ Does it fail gracefully?
- Checks for required tools
- Provides helpful error messages
- Suggests fixes when things go wrong

### â˜ Is it documented?
- Added to README.md
- Has `--help` output
- Comments in code explain "why" not just "what"

---

## Example: Adding the Sticky Feature

Here's how `uke-sticky` was implemented following these principles:

### Step 1: Define in registry.yaml

```yaml
keybindings:
  sticky:
    key: "s"
    mod: "primary_shift"      # Alt+Shift on Linux, Cmd+Shift on macOS
    action: "exec"
    command: "uke-sticky toggle"
```

### Step 2: Create cross-platform command

```bash
# bin/uke-sticky

if is_linux; then
    hyprland_toggle()  # Uses hyprctl
elif is_macos; then
    yabai_toggle()     # Uses yabai -m
fi
```

### Step 3: Implement platform-specific logic

**Hyprland:**
```bash
hyprctl dispatch togglefloating
hyprctl dispatch pin
```

**Yabai:**
```bash
yabai -m window --toggle float
yabai -m window --toggle sticky
yabai -m window --toggle topmost
```

### Step 4: Track state

```bash
STICKY_STATE="$XDG_STATE_HOME/uke/sticky_windows"
echo "$window_id" >> "$STICKY_STATE"  # Remember it's sticky
```

### Step 5: Make it toggleable

```bash
if is_already_sticky "$window_id"; then
    unmake_sticky "$window_id"
else
    make_sticky "$window_id"
fi
```

### Step 6: Add subcommands

```bash
case "${1:-toggle}" in
    toggle) ... ;;
    list)   ... ;;
    clear)  ... ;;
esac
```

### Step 7: Document

- Added to README.md
- Includes `--help`
- This philosophy doc

---

## Avoid These Mistakes

### âŒ Hardcoding platform-specific values

```bash
# Bad
bind = ALT, S, exec, uke-sticky

# Good: Let gen.sh produce this from registry.yaml
```

### âŒ Creating duplicate commands

```bash
# Bad
bin/uke-sticky-hyprland
bin/uke-sticky-yabai

# Good: One command with internal platform detection
bin/uke-sticky
```

### âŒ Scattering state files

```bash
# Bad
~/.sticky_windows
/tmp/uke_state
~/.config/uke/runtime_stuff

# Good: Centralized
~/.local/state/uke/sticky_windows
```

### âŒ Silent failures

```bash
# Bad
hyprctl dispatch pin 2>/dev/null

# Good
if ! hyprctl dispatch pin; then
    fail "Could not pin window"
    exit 1
fi
```

### âŒ Missing help

```bash
# Bad: No documentation
case "$1" in
    toggle) ... ;;
esac

# Good: Always include help
case "$1" in
    -h|--help) show_help ;;
    toggle) ... ;;
esac
```

---

## Summary

UKE's power comes from its abstractions:

| Layer | Purpose |
|-------|---------|
| `registry.yaml` | Single source of truth |
| `gen.sh` | Platform-specific config generation |
| `lib/core.sh` | Shared utilities and detection |
| `uke-*` commands | Cross-platform wrappers |
| Ghost files | Machine-specific overrides |

When in doubt, follow the pattern of existing features. Read the code of `uke-sticky`, `uke-services`, or `uke-backup` to see these principles in action.

The goal is: **Change one thing in one place, have it work everywhere.**



################################################################################
FILE PATH: uke/gen/.gitkeep
################################################################################




################################################################################
FILE PATH: uke/gen/skhd/skhdrc
################################################################################

# ==============================================================================
# SKHD CONFIG - Keyboard Shortcuts (macOS)
# ==============================================================================
# Source: /Users/laurenz/dotfiles/uke/config/registry.yaml
# Generated: 2025-12-04T21:08:37+01:00
# Platform: macos
#
# DO NOT EDIT DIRECTLY - Regenerate with: uke gen
# ==============================================================================

# ==============================================================================
# Smart Focus & Focus History
# ==============================================================================
cmd - escape : yabai -m window --focus mouse
cmd + shift - 0x32 : yabai -m window --focus recent

# ==============================================================================
# Window Focus Navigation (PRIMARY: Cmd + hjkl)
# ==============================================================================
cmd - h : yabai -m window --focus west
cmd - j : yabai -m window --focus south
cmd - k : yabai -m window --focus north
cmd - l : yabai -m window --focus east

# ==============================================================================
# Window Movement (PRIMARY + SHIFT: Cmd+Shift + hjkl)
# ==============================================================================
cmd + shift - h : yabai -m window --warp west
cmd + shift - j : yabai -m window --warp south
cmd + shift - k : yabai -m window --warp north
cmd + shift - l : yabai -m window --warp east

# ==============================================================================
# Window Resizing (TERTIARY: Alt+Shift + hjkl)
# ==============================================================================
alt + shift - h : yabai -m window --resize left:-50:0
alt + shift - j : yabai -m window --resize bottom:0:50
alt + shift - k : yabai -m window --resize top:0:-50
alt + shift - l : yabai -m window --resize right:50:0

# ==============================================================================
# Launch Terminal
# ==============================================================================
cmd - return : open -a WezTerm

# ==============================================================================
# Window Controls
# ==============================================================================
cmd + shift - f : yabai -m window --toggle zoom-fullscreen
cmd + shift - space : yabai -m window --toggle float
cmd + shift - 0x2A : yabai -m window --toggle split

# ==============================================================================
# Advanced Layout Controls
# ==============================================================================
cmd + ctrl - s : yabai -m window --insert stack
cmd + shift - r : yabai -m space --rotate 90
cmd + shift - x : yabai -m space --mirror x-axis
cmd + shift - y : yabai -m space --mirror y-axis
cmd + shift - b : yabai -m space --balance
cmd + ctrl - t : yabai -m space --layout $(yabai -m query --spaces --space | jq -r 'if .type == "bsp" then "stack" else "bsp" end')

# ==============================================================================
# Workspace Navigation (PRIMARY + Number)
# ==============================================================================
cmd - 1 : yabai -m space --focus 1
cmd - 2 : yabai -m space --focus 2
cmd - 3 : yabai -m space --focus 3
cmd - 4 : yabai -m space --focus 4
cmd - 5 : yabai -m space --focus 5
cmd - 6 : yabai -m space --focus 6
cmd - 7 : yabai -m space --focus 7
cmd - 8 : yabai -m space --focus 8
cmd - 9 : yabai -m space --focus 9
cmd - 0x1D : yabai -m space --focus 10
cmd - 0x21 : yabai -m space --focus prev
cmd - 0x1E : yabai -m space --focus next

# ==============================================================================
# Move Window to Workspace (PRIMARY + SHIFT + Number)
# ==============================================================================
cmd + shift - 1 : yabai -m window --space 1 --focus
cmd + shift - 2 : yabai -m window --space 2 --focus
cmd + shift - 3 : yabai -m window --space 3 --focus
cmd + shift - 4 : yabai -m window --space 4 --focus
cmd + shift - 5 : yabai -m window --space 5 --focus
cmd + shift - 6 : yabai -m window --space 6 --focus
cmd + shift - 7 : yabai -m window --space 7 --focus
cmd + shift - 8 : yabai -m window --space 8 --focus
cmd + shift - 9 : yabai -m window --space 9 --focus
cmd + shift - 0x1D : yabai -m window --space 10 --focus

# ==============================================================================
# Gather Windows (Cmd + `)
# ==============================================================================
cmd - 0x32 : $HOME/.local/bin/uke-gather

# ==============================================================================
# Scratchpads
# ==============================================================================
cmd + alt - 0x32 : $HOME/.local/bin/uke-scratchpad terminal
cmd + alt - n : $HOME/.local/bin/uke-scratchpad notes
cmd + alt - m : $HOME/.local/bin/uke-scratchpad music

# ==============================================================================
# Smart App Launchers (LAUNCHER: Cmd+Alt)
# ==============================================================================
# Sticky window (floating + pinned + always-on-top)
cmd + shift - s : $HOME/.local/bin/uke-sticky toggle
# Quick fix
cmd + shift - x : $HOME/.local/bin/uke-fix

cmd + alt - b : $HOME/.local/bin/uke-launch brave
cmd + alt - o : $HOME/.local/bin/uke-launch obsidian
cmd + alt - c : $HOME/.local/bin/uke-launch code
cmd + alt - r : $HOME/.local/bin/uke-launch raindrop
cmd + alt - t : $HOME/.local/bin/uke-launch wezterm

# ==============================================================================
# Bunches (Generated from registry.yaml)
# ==============================================================================
cmd + ctrl - 1 : $HOME/.local/bin/uke-bunch study
cmd + ctrl - 2 : $HOME/.local/bin/uke-bunch guitar
cmd + ctrl - 3 : $HOME/.local/bin/uke-bunch coding
cmd + ctrl - 4 : $HOME/.local/bin/uke-bunch email
cmd + ctrl - 5 : $HOME/.local/bin/uke-bunch reading

# ==============================================================================
# Session Management
# ==============================================================================
cmd + ctrl - s : $HOME/.local/bin/uke-session save quick
cmd + ctrl + shift - s : $HOME/.local/bin/uke-session restore quick



################################################################################
FILE PATH: uke/gen/yabai/yabairc
################################################################################

# ==============================================================================
# YABAI CONFIG - Window Manager (macOS)
# ==============================================================================
# Source: /Users/laurenz/dotfiles/uke/config/registry.yaml
# Generated: 2025-12-04T21:08:37+01:00
# Platform: macos
#
# DO NOT EDIT DIRECTLY - Regenerate with: uke gen
# ==============================================================================

#!/usr/bin/env sh

# Load Scripting Addition
sudo yabai --load-sa

# ==============================================================================
# Layout Configuration
# ==============================================================================
yabai -m config layout bsp
yabai -m config window_placement second_child
yabai -m config top_padding    4
yabai -m config bottom_padding 4
yabai -m config left_padding   4
yabai -m config right_padding  4
yabai -m config window_gap     4

# ==============================================================================
# Mouse Configuration
# ==============================================================================
yabai -m config mouse_follows_focus off
yabai -m config focus_follows_mouse off
yabai -m config mouse_modifier alt
yabai -m config mouse_action1 move
yabai -m config mouse_action2 resize

# ==============================================================================
# Window Behavior
# ==============================================================================
yabai -m config split_ratio 0.50
yabai -m config auto_balance off

# ==============================================================================
# Window Borders (Nord colorscheme)
# ==============================================================================
pkill -x borders 2>/dev/null || true
borders width=3 active_color=0xff88c0d0 inactive_color=0xff3b4252 &

# ==============================================================================
# Terminal Opacity
# ==============================================================================
yabai -m config window_opacity off
yabai -m rule --add app="^WezTerm$" opacity=0.92
yabai -m rule --add app="^Alacritty$" opacity=0.92

# ==============================================================================
# Float Rules (Generated from registry.yaml)
# ==============================================================================
yabai -m rule --add app="^System$" manage=off
yabai -m rule --add app="^Settings$" manage=off
yabai -m rule --add app="^System$" manage=off
yabai -m rule --add app="^Preferences$" manage=off
yabai -m rule --add app="^Calculator$" manage=off
yabai -m rule --add app="^Finder$" manage=off
yabai -m rule --add app="^App$" manage=off
yabai -m rule --add app="^Store$" manage=off
yabai -m rule --add app="^Karabiner-Elements$" manage=off
yabai -m rule --add app="^Karabiner-EventViewer$" manage=off
yabai -m rule --add app="^Activity$" manage=off
yabai -m rule --add app="^Monitor$" manage=off
yabai -m rule --add app="^Archive$" manage=off
yabai -m rule --add app="^Utility$" manage=off
yabai -m rule --add app="^zoom.us$" manage=off
yabai -m rule --add app="^FaceTime$" manage=off
yabai -m rule --add app="^pavucontrol$" manage=off
yabai -m rule --add app="^nm-connection-editor$" manage=off
yabai -m rule --add app="^lxappearance$" manage=off
yabai -m rule --add app="^blueman-manager$" manage=off

# ==============================================================================
# Window Rules (Generated from registry.yaml)
# ==============================================================================
yabai -m rule --add app="^System Settings$" manage=off
yabai -m rule --add app="^Calculator$" manage=off sticky=on
yabai -m rule --add app="^Finder$" manage=off
yabai -m rule --add app="^App Store$" manage=off
yabai -m rule --add app="^Karabiner-Elements$" manage=off
yabai -m rule --add app="^Karabiner-EventViewer$" manage=off
yabai -m rule --add app="^zoom.us$" manage=off sticky=on opacity=1.0
yabai -m rule --add app="^FaceTime$" manage=off sticky=on
yabai -m rule --add title="Picture in Picture" manage=off sticky=on layer=above
yabai -m rule --add app="^Code$" title="Settings" manage=off
yabai -m rule --add title="Preferences" manage=off
yabai -m rule --add title="Settings" manage=off

# ==============================================================================
# Workspace Assignments (Generated from registry.yaml)
# ==============================================================================
yabai -m rule --add app="^Safari$" space=^1
yabai -m rule --add app="^Brave Browser$" space=^1
yabai -m rule --add app="^Firefox$" space=^1
yabai -m rule --add app="^Google Chrome$" space=^1
yabai -m rule --add app="^Obsidian$" space=^2
yabai -m rule --add app="^Notion$" space=^2
yabai -m rule --add app="^WezTerm$" space=^3
yabai -m rule --add app="^Alacritty$" space=^3
yabai -m rule --add app="^kitty$" space=^3
yabai -m rule --add app="^Visual Studio Code$" space=^3
yabai -m rule --add app="^VSCodium$" space=^3
yabai -m rule --add app="^Xcode$" space=^3
yabai -m rule --add app="^Cursor$" space=^3
yabai -m rule --add app="^Preview$" space=^5
yabai -m rule --add app="^PDF Expert$" space=^5
yabai -m rule --add app="^Raindrop.io$" space=^6
yabai -m rule --add app="^Spotify$" space=^7
yabai -m rule --add app="^Music$" space=^7
yabai -m rule --add app="^Microsoft Word$" space=^8
yabai -m rule --add app="^Microsoft Excel$" space=^8
yabai -m rule --add app="^Microsoft PowerPoint$" space=^8
yabai -m rule --add app="^Pages$" space=^8
yabai -m rule --add app="^Numbers$" space=^8
yabai -m rule --add app="^Keynote$" space=^8
yabai -m rule --add app="^Slack$" space=^9
yabai -m rule --add app="^Discord$" space=^9
yabai -m rule --add app="^Mail$" space=^9
yabai -m rule --add app="^Telegram$" space=^9
yabai -m rule --add app="^WhatsApp$" space=^9
yabai -m rule --add app="^Messages$" space=^9
yabai -m rule --add app="^Microsoft Teams$" space=^9
yabai -m rule --add app="^Claude$" space=^10
yabai -m rule --add app="^Perplexity$" space=^10
yabai -m rule --add app="^ChatGPT$" space=^10

# ==============================================================================
# HARDWARE SPECIFIC INCLUDES (Ghost Files)
# ==============================================================================
# Loads GPU/Monitor/Form Factor settings generated by: uke profile
# These settings override defaults based on machine.profile
HARDWARE_CONF="$HOME/.config/yabai/generated_hardware.conf"
if [[ -f "$HARDWARE_CONF" ]]; then
    source "$HARDWARE_CONF"
fi

echo "yabai: Configuration loaded"



################################################################################
FILE PATH: uke/.gitignore
################################################################################

# Generated files
gen/
!gen/.gitkeep

# State files (machine-specific)
*.profile

# MacOS
.DS_Store
*.swp

# Logs
*.log

# Ghost files (these are generated per-machine)
generated_*.conf
generated_*.lua
generated_*.toml



################################################################################
FILE PATH: uke/scripts/arch-check.sh
################################################################################

#!/usr/bin/env bash
# ==============================================================================
# UKE Arch Linux Package Checker v7.3 - Fixed
# ==============================================================================
set -uo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
UKE_ROOT="${SCRIPT_DIR%/scripts}"

RED=$'\e[31m' GREEN=$'\e[32m' YELLOW=$'\e[33m' BLUE=$'\e[34m'
CYAN=$'\e[36m' BOLD=$'\e[1m' DIM=$'\e[2m' RESET=$'\e[0m'

ok()   { printf "%sâœ“%s %s\n" "$GREEN" "$RESET" "$*" >&2; }
fail() { printf "%sâœ—%s %s\n" "$RED" "$RESET" "$*" >&2; }
info() { printf "%sâ†’%s %s\n" "$BLUE" "$RESET" "$*" >&2; }
warn() { printf "%s!%s %s\n" "$YELLOW" "$RESET" "$*" >&2; }

# Package groups as simple arrays
CORE_PKGS="hyprland stow jq git wezterm"
WM_PKGS="wofi waybar dunst hyprpaper hypridle hyprlock"
UTIL_PKGS="wl-clipboard cliphist grim slurp zathura zathura-pdf-mupdf"
SYSTEM_PKGS="pavucontrol network-manager-applet blueman thunar polkit-kde-agent"
DEV_PKGS="neovim ripgrep fd eza bat htop tmux fzf zsh-autosuggestions zsh-syntax-highlighting"
YAML_PKGS="go-yq"
ADMIN_PKGS="reflector pacman-contrib"
KEYBOARD_PKGS="keyd"
FONT_PKGS="ttf-jetbrains-mono-nerd noto-fonts-emoji"

check_pkg() { pacman -Qi "$1" &>/dev/null; }

get_missing() {
    local pkgs="$1" missing=""
    for p in $pkgs; do check_pkg "$p" || missing="$missing $p"; done
    echo "$missing"
}

show_group() {
    local name="$1" pkgs="$2" required="${3:-false}"
    local missing=$(get_missing "$pkgs")
    local total=$(echo $pkgs | wc -w)
    local miss_count=$(echo $missing | wc -w)
    [[ -z "$missing" ]] && miss_count=0
    local inst=$((total - miss_count))
    local icon="âœ“" color="$GREEN"
    [[ $miss_count -gt 0 ]] && { icon="â—‹"; color="$YELLOW"; }
    [[ "$required" == "true" && $miss_count -gt 0 ]] && { icon="âœ—"; color="$RED"; }
    local badge=""; [[ "$required" == "true" ]] && badge="${RED}[REQUIRED]${RESET} "
    printf "  %s%-30s%s %s%s%s (%d/%d)\n" "$badge" "$name" "$RESET" "$color" "$icon" "$RESET" "$inst" "$total" >&2
    [[ $miss_count -gt 0 ]] && printf "      ${DIM}Missing:${RESET}%s\n" "$missing" >&2
    echo "$missing"
}

handle_yq_conflict() {
    if check_pkg "yq"; then
        warn "Conflict: 'yq' conflicts with 'go-yq'"
        read -p "  Remove 'yq' and install 'go-yq'? [Y/n] " -r resp
        [[ "$resp" =~ ^[Nn] ]] && return 1
        sudo pacman -Rns --noconfirm yq 2>/dev/null || true
        ok "Removed 'yq'"
    fi
    return 0
}

install_pkgs() {
    local pkgs="$1"
    [[ -z "$pkgs" ]] && return 0
    info "Installing:$pkgs"
    sudo pacman -S --needed --noconfirm $pkgs
}

setup_services() {
    info "Setting up services..."
    check_pkg "keyd" && { sudo systemctl enable --now keyd 2>/dev/null && ok "keyd enabled"; }
    check_pkg "networkmanager" && { sudo systemctl enable --now NetworkManager 2>/dev/null; }
    check_pkg "bluez" && { sudo systemctl enable --now bluetooth 2>/dev/null; }
}

main() {
    local mode="${1:-}"
    echo "" >&2
    printf "%sâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—%s\n" "$CYAN" "$RESET" >&2
    printf "%sâ•‘%s  UKE Arch Package Checker v7.3      %sâ•‘%s\n" "$CYAN" "$BOLD" "$CYAN" "$RESET" >&2
    printf "%sâ•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•%s\n" "$CYAN" "$RESET" >&2
    echo "" >&2

    local m1=$(show_group "Core Dependencies" "$CORE_PKGS" true)
    local m2=$(show_group "Window Manager" "$WM_PKGS")
    local m3=$(show_group "Clipboard & Screenshots" "$UTIL_PKGS")
    local m4=$(show_group "System Utilities" "$SYSTEM_PKGS")
    local m5=$(show_group "Development Tools" "$DEV_PKGS")
    local m6=$(show_group "YAML Processor" "$YAML_PKGS")
    local m7=$(show_group "System Admin" "$ADMIN_PKGS")
    local m8=$(show_group "Keyboard Remapping" "$KEYBOARD_PKGS")
    local m9=$(show_group "Fonts" "$FONT_PKGS")

    echo "" >&2
    [[ "$mode" == "--check" ]] && exit 0

    echo "  ${BOLD}Install options:${RESET}" >&2
    echo "    a = ALL    r = Required only    1-9 = Select groups    q = Quit" >&2
    read -p "  Choice: " -r choice

    local to_install=""
    case "$choice" in
        a|A) to_install="$m1 $m2 $m3 $m4 $m5 $m6 $m7 $m8 $m9" ;;
        r|R) to_install="$m1" ;;
        q|Q) exit 0 ;;
        *)
            [[ "$choice" == *1* ]] && to_install="$to_install $m1"
            [[ "$choice" == *2* ]] && to_install="$to_install $m2"
            [[ "$choice" == *3* ]] && to_install="$to_install $m3"
            [[ "$choice" == *4* ]] && to_install="$to_install $m4"
            [[ "$choice" == *5* ]] && to_install="$to_install $m5"
            [[ "$choice" == *6* ]] && to_install="$to_install $m6"
            [[ "$choice" == *7* ]] && to_install="$to_install $m7"
            [[ "$choice" == *8* ]] && to_install="$to_install $m8"
            [[ "$choice" == *9* ]] && to_install="$to_install $m9"
            to_install="$to_install $m1"  # Always include required
            ;;
    esac

    to_install=$(echo "$to_install" | xargs -n1 | sort -u | xargs)
    [[ -z "$to_install" ]] && { ok "Nothing to install!"; exit 0; }

    # Handle yq conflict
    if [[ "$to_install" == *"go-yq"* ]]; then
        handle_yq_conflict || to_install=$(echo "$to_install" | sed 's/go-yq//')
    fi

    info "Will install:$to_install"
    read -p "  Proceed? [Y/n] " -r resp
    [[ "$resp" =~ ^[Nn] ]] && exit 0

    sudo pacman -Syu --noconfirm
    install_pkgs "$to_install"
    setup_services
    ok "Done! Run: ./scripts/install.sh"
}

main "$@"



################################################################################
FILE PATH: uke/scripts/install.sh
################################################################################

#!/usr/bin/env bash
# ==============================================================================
# UKE Installer v7.3 - DO NOT RUN WITH SUDO
# ==============================================================================
# Run as normal user: ./scripts/install.sh
# Only specific operations (services, hooks) will prompt for sudo
# ==============================================================================
set -uo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
UKE_ROOT="${SCRIPT_DIR%/scripts}"

RED=$'\e[31m' GREEN=$'\e[32m' YELLOW=$'\e[33m' BLUE=$'\e[34m'
CYAN=$'\e[36m' BOLD=$'\e[1m' DIM=$'\e[2m' RESET=$'\e[0m'

ok()   { echo "${GREEN}âœ“${RESET} $*" >&2; }
fail() { echo "${RED}âœ—${RESET} $*" >&2; }
info() { echo "${BLUE}â†’${RESET} $*" >&2; }
warn() { echo "${YELLOW}!${RESET} $*" >&2; }

# ==============================================================================
# Check if running as root (BAD)
# ==============================================================================
if [[ $EUID -eq 0 ]]; then
    fail "Do NOT run this script as root/sudo!"
    echo "Run as normal user: ./scripts/install.sh"
    exit 1
fi

# ==============================================================================
# Fix ownership if needed
# ==============================================================================
fix_ownership() {
    # Check if UKE files are owned by root (common after unzip as root)
    local owner
    owner=$(ls -ld "$UKE_ROOT/bin/uke" 2>/dev/null | awk '{print $3}')
    
    if [[ "$owner" == "root" ]]; then
        warn "UKE files are owned by root (probably extracted with sudo)"
        info "Fixing ownership (requires sudo)..."
        sudo chown -R "$USER:$USER" "$UKE_ROOT"
        ok "Ownership fixed"
    fi
}

# ==============================================================================
# OS Detection
# ==============================================================================
case "$(uname -s)" in
    Darwin) OS="macos" ;;
    Linux)  OS="linux" ;;
    *)      echo "Unsupported OS"; exit 1 ;;
esac

DISTRO=""
if [[ "$OS" == "linux" ]]; then
    [[ -f /etc/arch-release ]] && DISTRO="arch"
    [[ -f /etc/debian_version ]] && DISTRO="debian"
fi

# ==============================================================================
# Dependency Check
# ==============================================================================
check_deps() {
    info "Checking dependencies..."
    local missing=()
    
    for cmd in git stow jq; do
        command -v "$cmd" &>/dev/null || missing+=("$cmd")
    done
    
    if [[ "$OS" == "macos" ]]; then
        command -v yabai &>/dev/null || missing+=("yabai")
        command -v skhd &>/dev/null || missing+=("skhd")
    else
        command -v hyprctl &>/dev/null || missing+=("hyprland")
    fi
    
    if [[ ${#missing[@]} -gt 0 ]]; then
        fail "Missing: ${missing[*]}"
        echo ""
        echo "Install with:"
        if [[ "$OS" == "macos" ]]; then
            echo "  brew install ${missing[*]}"
        elif [[ "$DISTRO" == "arch" ]]; then
            echo "  sudo pacman -S ${missing[*]}"
            echo ""
            echo "Or run the full package check:"
            echo "  $UKE_ROOT/scripts/arch-check.sh"
        else
            echo "  Please install: ${missing[*]}"
        fi
        exit 1
    fi
    
    ok "All dependencies installed"
}

# ==============================================================================
# Create Directories
# ==============================================================================
create_dirs() {
    info "Creating directories..."
    mkdir -p ~/.local/bin
    mkdir -p ~/.local/state/uke
    mkdir -p ~/.config/skhd
    mkdir -p ~/.config/yabai
    mkdir -p ~/.config/hypr
    mkdir -p ~/.config/alacritty
    mkdir -p ~/.config/wezterm
    mkdir -p ~/.config/keyd
    mkdir -p "$UKE_ROOT/gen"/{skhd,yabai,hyprland}
    ok "Directories created"
}

# ==============================================================================
# Generate Configs
# ==============================================================================
generate_configs() {
    info "Generating configs..."
    bash "$UKE_ROOT/lib/gen.sh" all
}

# ==============================================================================
# Link Binaries
# ==============================================================================
link_binaries() {
    info "Linking binaries to ~/.local/bin..."
    
    for bin in "$UKE_ROOT/bin"/*; do
        [[ -f "$bin" ]] || continue
        local name=$(basename "$bin")
        chmod +x "$bin"
        ln -sf "$bin" "$HOME/.local/bin/$name"
        ok "Linked: $name"
    done
}

# ==============================================================================
# Setup Pacman Hook (Arch Linux only)
# ==============================================================================
setup_pacman_hook() {
    if [[ "$DISTRO" != "arch" ]]; then
        return 0
    fi
    
    info "Setting up pacman hook for system snapshots..."
    
    # Create symlink for uke-snapshot in system path (required for pacman hooks)
    if [[ -f "$HOME/.local/bin/uke-snapshot" ]]; then
        info "Creating system symlink for uke-snapshot (requires sudo)..."
        sudo ln -sf "$HOME/.local/bin/uke-snapshot" /usr/local/bin/uke-snapshot 2>/dev/null && \
            ok "Created /usr/local/bin/uke-snapshot symlink" || \
            warn "Could not create system symlink (run manually: sudo ln -sf ~/.local/bin/uke-snapshot /usr/local/bin/uke-snapshot)"
    fi
    
    # Install the pacman hook
    local hook_src="$UKE_ROOT/scripts/pacman-hooks/uke-snapshot.hook"
    local hook_dest="/etc/pacman.d/hooks/uke-snapshot.hook"
    
    if [[ -f "$hook_src" ]]; then
        sudo mkdir -p /etc/pacman.d/hooks 2>/dev/null
        sudo cp "$hook_src" "$hook_dest" 2>/dev/null && \
            ok "Installed pacman hook" || \
            warn "Could not install pacman hook (run manually: sudo cp $hook_src $hook_dest)"
    fi
}

# ==============================================================================
# Link Generated Configs
# ==============================================================================
link_configs() {
    info "Linking generated configs..."
    
    if [[ "$OS" == "macos" ]]; then
        [[ -f "$UKE_ROOT/gen/skhd/skhdrc" ]] && {
            ln -sf "$UKE_ROOT/gen/skhd/skhdrc" "$HOME/.config/skhd/skhdrc"
            ok "Linked: skhdrc"
        }
        
        [[ -f "$UKE_ROOT/gen/yabai/yabairc" ]] && {
            ln -sf "$UKE_ROOT/gen/yabai/yabairc" "$HOME/.config/yabai/yabairc"
            ok "Linked: yabairc"
        }
    else
        [[ -f "$UKE_ROOT/gen/hyprland/hyprland.conf" ]] && {
            ln -sf "$UKE_ROOT/gen/hyprland/hyprland.conf" "$HOME/.config/hypr/hyprland.conf"
            ok "Linked: hyprland.conf"
        }
    fi
}

# ==============================================================================
# Stow Dotfiles
# ==============================================================================
stow_dotfiles() {
    info "Stowing dotfiles..."
    
    local stow_dir="$UKE_ROOT/stow"
    
    if [[ ! -d "$stow_dir" ]]; then
        warn "Stow directory not found: $stow_dir"
        warn "Skipping dotfile stowing - create stow packages first"
        return 0
    fi
    
    # Check if stow directory has any packages
    local has_packages=false
    for dir in "$stow_dir"/*/; do
        if [[ -d "$dir" ]]; then
            has_packages=true
            break
        fi
    done
    
    if [[ "$has_packages" == "false" ]]; then
        warn "No stow packages found in $stow_dir"
        return 0
    fi
    
    cd "$stow_dir"
    
    local packages=(wezterm tmux zsh nvim zathura)
    [[ "$OS" == "macos" ]] && packages+=(karabiner)
    [[ "$OS" == "linux" ]] && packages+=(keyd)
    
    for pkg in "${packages[@]}"; do
        if [[ -d "$pkg" ]]; then
            # Check if package has content
            if find "$pkg" -mindepth 1 -maxdepth 1 | grep -q .; then
                stow -t "$HOME" -R "$pkg" 2>/dev/null && ok "Stowed: $pkg" || warn "Skipped: $pkg (conflict?)"
            else
                warn "Package empty: $pkg"
            fi
        fi
    done
}

# ==============================================================================
# Setup Hardware Profile
# ==============================================================================
setup_profile() {
    local profile_dir="${XDG_STATE_HOME:-$HOME/.local/state}/uke"
    local profile_file="$profile_dir/machine.profile"
    
    info "Checking for hardware profile at: $profile_file"
    
    if [[ -f "$profile_file" ]]; then
        ok "Hardware profile found"
        info "Generating hardware configs..."
        
        # Run apply_profile.sh with proper error handling
        if bash "$UKE_ROOT/scripts/apply_profile.sh"; then
            ok "Hardware configs generated"
        else
            warn "apply_profile.sh had errors (this is usually fine for first install)"
        fi
    else
        warn "No hardware profile found"
        echo ""
        echo "  ${BOLD}Create one now with:${RESET}"
        echo "    uke profile"
        echo ""
        echo "  ${BOLD}Then apply it:${RESET}"
        echo "    uke apply"
        echo ""
        
        # Create placeholder for Hyprland so it doesn't crash
        if [[ "$OS" == "linux" ]]; then
            local hypr_dir="$HOME/.config/hypr"
            local hypr_hw="$hypr_dir/generated_hardware.conf"
            if [[ ! -f "$hypr_hw" ]]; then
                mkdir -p "$hypr_dir"
                cat > "$hypr_hw" << 'EOF'
# Placeholder - run 'uke profile' then 'uke apply' to configure
monitor=,preferred,auto,1
general {
    gaps_in = 2
    gaps_out = 4
    border_size = 2
}
EOF
                ok "Created placeholder hardware config"
            fi
        fi
    fi
}

# ==============================================================================
# Setup Hyprland Auto-start (Linux only)
# ==============================================================================
setup_autostart() {
    if [[ "$OS" != "linux" ]]; then
        return 0
    fi
    
    info "Setting up Hyprland auto-start..."
    
    # Create the auto-start entry in .zprofile if using zsh
    local zprofile="$HOME/.zprofile"
    local marker="# UKE Hyprland Auto-start"
    
    if ! grep -q "$marker" "$zprofile" 2>/dev/null; then
        cat >> "$zprofile" << 'AUTOSTART'

# UKE Hyprland Auto-start
# Start Hyprland on TTY1 login with fallback
if [[ -z "${DISPLAY:-}" ]] && [[ "${XDG_VTNR:-}" == "1" ]] && [[ -z "${WAYLAND_DISPLAY:-}" ]]; then
    if command -v uke-autostart &>/dev/null; then
        exec uke-autostart
    elif command -v Hyprland &>/dev/null; then
        exec Hyprland
    fi
fi
AUTOSTART
        ok "Added auto-start to $zprofile"
    else
        ok "Auto-start already configured in $zprofile"
    fi
}

# ==============================================================================
# Start Services
# ==============================================================================
start_services() {
    info "Starting services..."
    
    if [[ "$OS" == "macos" ]]; then
        yabai --restart-service 2>/dev/null && ok "yabai restarted" || warn "yabai restart failed"
        skhd --restart-service 2>/dev/null && ok "skhd restarted" || warn "skhd restart failed"
    else
        if [[ -n "${HYPRLAND_INSTANCE_SIGNATURE:-}" ]]; then
            hyprctl reload 2>/dev/null && ok "hyprland reloaded" || warn "hyprland reload failed"
        else
            warn "Hyprland not running - config will load on next start"
        fi
    fi
}

# ==============================================================================
# Main
# ==============================================================================
main() {
    echo ""
    printf "%sâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—%s\n" "$CYAN" "$RESET"
    printf "%sâ•‘%s     UKE v7.3 Installer               %sâ•‘%s\n" "$CYAN" "$BOLD" "$CYAN" "$RESET"
    printf "%sâ•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•%s\n" "$CYAN" "$RESET"
    echo ""
    echo "Platform: $OS"
    [[ -n "$DISTRO" ]] && echo "Distro:   $DISTRO"
    echo "UKE Root: $UKE_ROOT"
    echo ""
    
    # Always fix ownership first
    fix_ownership
    
    case "${1:-full}" in
        --check)
            check_deps
            ;;
        --stow)
            stow_dotfiles
            ;;
        --link)
            link_binaries
            link_configs
            ;;
        --gen)
            generate_configs
            ;;
        --profile)
            setup_profile
            ;;
        --autostart)
            setup_autostart
            ;;
        full|*)
            check_deps
            create_dirs
            generate_configs
            link_binaries
            link_configs
            stow_dotfiles
            setup_profile
            setup_autostart
            setup_pacman_hook
            start_services
            
            echo ""
            echo "${GREEN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${RESET}"
            echo "${GREEN}âœ“ Installation complete!${RESET}"
            echo ""
            echo "Next steps:"
            echo "  1. Restart terminal (or: source ~/.zshrc)"
            echo "  2. Customize hardware: uke profile"
            echo "  3. Regenerate if needed: uke gen && uke reload"
            echo ""
            echo "Quick commands:"
            echo "  uke status    # Show current status"
            echo "  uke help      # Full command reference"
            echo "  uke doctor    # Diagnose issues"
            echo ""
            if [[ "$OS" == "linux" ]]; then
                echo "Auto-start:"
                echo "  Hyprland will auto-start on TTY1 login"
                echo "  To disable: remove UKE block from ~/.zprofile"
            fi
            ;;
    esac
}

main "$@"



################################################################################
FILE PATH: uke/scripts/uke-detect.sh
################################################################################

#!/usr/bin/env bash
# ==============================================================================
# UKE Detect - Find all UKE installations and artifacts
# ==============================================================================

# Resolve UKE_ROOT dynamically
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
UKE_ROOT="${SCRIPT_DIR%/scripts}"

echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
echo "â•‘     UKE Detection Report             â•‘"
echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

echo -e "\n[1] Binary Symlinks (~/.local/bin)"
for bin in uke uke-gather uke-bunch uke-doctor uke-backup uke-debug uke-logs uke-scratch uke-session; do
    if [[ -L "$HOME/.local/bin/$bin" ]]; then
        target=$(readlink "$HOME/.local/bin/$bin")
        echo "  âœ“ $bin â†’ $target"
    elif [[ -f "$HOME/.local/bin/$bin" ]]; then
        echo "  âš  $bin (file, not symlink)"
    else
        echo "  âœ— $bin (missing)"
    fi
done

echo -e "\n[2] Config Symlinks (~/.config)"
for cfg in "skhd/skhdrc" "yabai/yabairc" "hypr/hyprland.conf"; do
    path="$HOME/.config/$cfg"
    if [[ -L "$path" ]]; then
        echo "  âœ“ $cfg â†’ $(readlink "$path")"
    elif [[ -f "$path" ]]; then
        echo "  âš  $cfg (file, not symlink)"
    else
        echo "  - $cfg (not present)"
    fi
done

echo -e "\n[3] Stowed Dotfiles"
for dot in .wezterm.lua .tmux.conf .zshrc; do
    path="$HOME/$dot"
    if [[ -L "$path" ]]; then
        echo "  âœ“ $dot â†’ $(readlink "$path")"
    elif [[ -f "$path" ]]; then
        echo "  âš  $dot (file, not symlink - may not be UKE)"
    else
        echo "  - $dot (not present)"
    fi
done

if [[ -L "$HOME/.config/nvim" ]]; then
    echo "  âœ“ .config/nvim â†’ $(readlink "$HOME/.config/nvim")"
elif [[ -d "$HOME/.config/nvim" ]]; then
    echo "  âš  .config/nvim (directory, check if stowed)"
fi

echo -e "\n[4] UKE Directories"
for dir in "$UKE_ROOT" "$HOME/.local/state/uke" "$HOME/.uke-backups"; do
    if [[ -d "$dir" ]]; then
        count=$(find "$dir" -type f 2>/dev/null | wc -l)
        echo "  âœ“ $dir ($count files)"
    else
        echo "  - $dir (not present)"
    fi
done

echo -e "\n[5] Running Services"
pgrep -x yabai &>/dev/null && echo "  âœ“ yabai running" || echo "  - yabai not running"
pgrep -x skhd &>/dev/null && echo "  âœ“ skhd running" || echo "  - skhd not running"
[[ -n "${HYPRLAND_INSTANCE_SIGNATURE:-}" ]] && echo "  âœ“ hyprland running"

echo -e "\n[6] Monitors"
if command -v yabai &>/dev/null && pgrep -x yabai &>/dev/null; then
    yabai -m query --displays 2>/dev/null | jq -r '.[] | "  âœ“ Display \(.index): \(.frame.w)x\(.frame.h) at (\(.frame.x),\(.frame.y))"' 2>/dev/null || echo "  - Could not query displays"
elif [[ -n "${HYPRLAND_INSTANCE_SIGNATURE:-}" ]]; then
    hyprctl monitors -j 2>/dev/null | jq -r '.[] | "  âœ“ \(.name): \(.width)x\(.height)"' 2>/dev/null || echo "  - Could not query monitors"
else
    echo "  - Window manager not running"
fi

echo -e "\n[7] Log Files"
[[ -f "$HOME/.local/state/uke/uke.log" ]] && echo "  âœ“ UKE log exists" || echo "  - No UKE log"
ls /tmp/yabai_*.err.log &>/dev/null && echo "  âœ“ Yabai logs exist" || echo "  - No yabai logs"
ls /tmp/skhd_*.err.log &>/dev/null && echo "  âœ“ skhd logs exist" || echo "  - No skhd logs"

echo ""



################################################################################
FILE PATH: uke/scripts/uke-wipe.sh
################################################################################

#!/usr/bin/env bash
# ==============================================================================
# UKE Wipe - Complete uninstallation
# ==============================================================================
set -euo pipefail

# Resolve UKE_ROOT dynamically
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
UKE_ROOT="${SCRIPT_DIR%/scripts}"
UKE_STOW="$UKE_ROOT/stow"

RED=$'\e[31m' GREEN=$'\e[32m' YELLOW=$'\e[33m' RESET=$'\e[0m'

echo "${RED}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${RESET}"
echo "${RED}â•‘     UKE WIPE - Complete Removal      â•‘${RESET}"
echo "${RED}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${RESET}"
echo ""
echo "This will remove:"
echo "  â€¢ Binary symlinks in ~/.local/bin/uke*"
echo "  â€¢ Config symlinks (skhd, yabai, hyprland)"
echo "  â€¢ Stowed dotfiles (wezterm, tmux, zsh, nvim)"
echo "  â€¢ UKE state and backups"
echo ""
echo "${YELLOW}Source at $UKE_ROOT will NOT be deleted.${RESET}"
echo ""
read -p "Type 'wipe' to confirm: " confirm
[[ "$confirm" != "wipe" ]] && { echo "Aborted."; exit 1; }

echo ""

# 1. Remove binary symlinks
echo "Removing binary symlinks..."
rm -f ~/.local/bin/uke ~/.local/bin/uke-*
echo "  âœ“ Binaries removed"

# 2. Remove config symlinks
echo "Removing config symlinks..."
rm -f ~/.config/skhd/skhdrc
rm -f ~/.config/yabai/yabairc
rm -f ~/.config/hypr/hyprland.conf
echo "  âœ“ Config symlinks removed"

# 3. Unstow dotfiles
echo "Unstowing dotfiles..."
if command -v stow &>/dev/null && [[ -d "$UKE_STOW" ]]; then
    cd "$UKE_STOW"
    for pkg in wezterm tmux zsh nvim karabiner; do
        [[ -d "$pkg" ]] && stow -t "$HOME" -D "$pkg" 2>/dev/null && echo "  âœ“ Unstowed: $pkg" || true
    done
else
    # Manual removal if stow not available
    rm -f ~/.wezterm.lua ~/.tmux.conf ~/.zshrc
    rm -rf ~/.config/nvim
    echo "  âœ“ Dotfiles removed (manual)"
fi

# 4. Remove state and backups
echo "Removing state and backups..."
rm -rf ~/.local/state/uke
rm -rf ~/.uke-backups
echo "  âœ“ State removed"

# 5. Stop services (optional)
echo "Stopping services..."
if command -v yabai &>/dev/null; then
    yabai --stop-service 2>/dev/null || true
    skhd --stop-service 2>/dev/null || true
    echo "  âœ“ Services stopped"
fi

echo ""
echo "${GREEN}âœ“ UKE removed successfully.${RESET}"
echo ""
echo "To completely remove source:"
echo "  rm -rf $UKE_ROOT"
echo ""
echo "To reinstall later:"
echo "  cd $UKE_ROOT && ./scripts/install.sh"



################################################################################
FILE PATH: uke/scripts/keyd-setup.sh
################################################################################

#!/usr/bin/env bash
# ==============================================================================
# UKE keyd Setup Script
# ==============================================================================
# keyd requires system-level configuration in /etc/keyd/
# This script handles the sudo operations needed for keyd setup.
#
# Usage:
#   ./keyd-setup.sh           # Install and enable keyd config
#   ./keyd-setup.sh --status  # Check keyd status
#   ./keyd-setup.sh --remove  # Remove UKE keyd config
#   ./keyd-setup.sh --reload  # Reload keyd service
# ==============================================================================
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
UKE_ROOT="${SCRIPT_DIR%/scripts}"
KEYD_SOURCE="$UKE_ROOT/stow/keyd/.config/keyd/default.conf"
KEYD_TARGET="/etc/keyd/default.conf"

# Colors
RED=$'\e[31m' GREEN=$'\e[32m' YELLOW=$'\e[33m' BLUE=$'\e[34m'
BOLD=$'\e[1m' RESET=$'\e[0m'

ok()   { echo "${GREEN}âœ“${RESET} $*"; }
fail() { echo "${RED}âœ—${RESET} $*"; }
info() { echo "${BLUE}â†’${RESET} $*"; }
warn() { echo "${YELLOW}!${RESET} $*"; }

# ==============================================================================
# Check Prerequisites
# ==============================================================================
check_prereqs() {
    if [[ "$(uname -s)" != "Linux" ]]; then
        fail "keyd is only available on Linux"
        exit 1
    fi
    
    if ! command -v keyd &>/dev/null; then
        fail "keyd not installed"
        echo ""
        echo "Install with:"
        if command -v pacman &>/dev/null; then
            echo "  sudo pacman -S keyd"
        elif command -v apt &>/dev/null; then
            echo "  # Build from source: https://github.com/rvaiya/keyd"
        fi
        exit 1
    fi
    
    if [[ ! -f "$KEYD_SOURCE" ]]; then
        fail "Source config not found: $KEYD_SOURCE"
        exit 1
    fi
}

# ==============================================================================
# Install keyd Config
# ==============================================================================
install_keyd() {
    check_prereqs
    
    info "Installing keyd configuration..."
    
    # Create /etc/keyd if it doesn't exist
    if [[ ! -d /etc/keyd ]]; then
        sudo mkdir -p /etc/keyd
        ok "Created /etc/keyd/"
    fi
    
    # Symlink the config
    sudo ln -sf "$KEYD_SOURCE" "$KEYD_TARGET"
    ok "Linked config to $KEYD_TARGET"
    
    # Enable and start/restart keyd service
    if systemctl is-active keyd &>/dev/null; then
        sudo systemctl restart keyd
        ok "keyd service restarted"
    else
        sudo systemctl enable --now keyd
        ok "keyd service enabled and started"
    fi
    
    echo ""
    echo "${GREEN}keyd setup complete!${RESET}"
    echo ""
    echo "Your Caps Lock key now works as:"
    echo "  â€¢ Tap: Escape"
    echo "  â€¢ Hold + hjkl: Arrow keys"
    echo "  â€¢ Hold + yuio: Home/PageUp/PageDown/End"
    echo "  â€¢ Hold + wasd: Selection (Shift+Arrow)"
    echo "  â€¢ Hold + qe:   Word selection (Ctrl+Shift+Arrow)"
    echo ""
}

# ==============================================================================
# Show Status
# ==============================================================================
show_status() {
    echo "${BOLD}keyd Status:${RESET}"
    echo ""
    
    # Check if keyd is installed
    if command -v keyd &>/dev/null; then
        ok "keyd installed: $(keyd --version 2>/dev/null || echo 'version unknown')"
    else
        fail "keyd not installed"
        return 1
    fi
    
    # Check service status
    if systemctl is-active keyd &>/dev/null; then
        ok "keyd service: active"
    else
        fail "keyd service: inactive"
    fi
    
    # Check config symlink
    if [[ -L "$KEYD_TARGET" ]]; then
        local target=$(readlink "$KEYD_TARGET")
        ok "Config symlink: $KEYD_TARGET â†’ $target"
    elif [[ -f "$KEYD_TARGET" ]]; then
        warn "Config exists but not a symlink: $KEYD_TARGET"
    else
        fail "Config not found: $KEYD_TARGET"
    fi
    
    echo ""
    
    # Show current config summary
    if [[ -f "$KEYD_TARGET" ]]; then
        info "Current config summary:"
        grep -E "^\[|^[a-z]+ = " "$KEYD_TARGET" 2>/dev/null | head -20 || true
    fi
}

# ==============================================================================
# Remove keyd Config
# ==============================================================================
remove_keyd() {
    info "Removing UKE keyd configuration..."
    
    if [[ -L "$KEYD_TARGET" ]]; then
        sudo rm "$KEYD_TARGET"
        ok "Removed symlink: $KEYD_TARGET"
    elif [[ -f "$KEYD_TARGET" ]]; then
        warn "Config is not a symlink, not removing: $KEYD_TARGET"
    else
        warn "Config not found: $KEYD_TARGET"
    fi
    
    # Restart keyd to use default config (if any)
    if systemctl is-active keyd &>/dev/null; then
        sudo systemctl restart keyd
        ok "keyd service restarted"
    fi
    
    echo ""
    echo "keyd config removed. Your Caps Lock should return to normal after restart."
}

# ==============================================================================
# Reload keyd
# ==============================================================================
reload_keyd() {
    info "Reloading keyd service..."
    
    if ! systemctl is-active keyd &>/dev/null; then
        sudo systemctl start keyd
        ok "keyd service started"
    else
        sudo keyd reload
        ok "keyd reloaded"
    fi
}

# ==============================================================================
# Main
# ==============================================================================
case "${1:-install}" in
    install|--install)
        install_keyd
        ;;
    status|--status)
        show_status
        ;;
    remove|--remove|uninstall|--uninstall)
        remove_keyd
        ;;
    reload|--reload)
        reload_keyd
        ;;
    -h|--help|help)
        echo "UKE keyd Setup Script"
        echo ""
        echo "Usage:"
        echo "  $0 [command]"
        echo ""
        echo "Commands:"
        echo "  install   Install and enable keyd config (default)"
        echo "  status    Show keyd status"
        echo "  remove    Remove UKE keyd config"
        echo "  reload    Reload keyd service"
        echo "  help      Show this help"
        ;;
    *)
        fail "Unknown command: $1"
        echo "Run '$0 --help' for usage"
        exit 1
        ;;
esac



################################################################################
FILE PATH: uke/scripts/pacman-hooks/uke-snapshot.hook
################################################################################

[Trigger]
Operation = Upgrade
Operation = Install
Operation = Remove
Type = Package
Target = linux
Target = linux-lts
Target = nvidia*
Target = mesa

[Action]
Description = Creating UKE pre-update snapshot...
When = PreTransaction
# NOTE: This requires a symlink: sudo ln -sf ~/.local/bin/uke-snapshot /usr/local/bin/uke-snapshot
Exec = /usr/local/bin/uke-snapshot auto



################################################################################
FILE PATH: uke/scripts/manage_profile.sh
################################################################################

#!/usr/bin/env bash
# ==============================================================================
# UKE Profile Manager v7.0 - Hardware Configuration TUI
# ==============================================================================
# Interactive terminal UI for managing machine-specific hardware settings.
# Creates ~/.local/state/uke/machine.profile with hardware configuration.
#
# Usage: manage_profile.sh
#        uke profile
# ==============================================================================
set -euo pipefail

# [FIX] Bash Version Auto-Detection & Reload
# macOS ships with Bash 3.2. This script requires Bash 4.0+ (associative arrays).
if [ -z "${BASH_VERSINFO}" ] || [ "${BASH_VERSINFO[0]}" -lt 4 ]; then
    if [ -x /opt/homebrew/bin/bash ]; then
        exec /opt/homebrew/bin/bash "$0" "$@"
    elif [ -x /usr/local/bin/bash ]; then
        exec /usr/local/bin/bash "$0" "$@"
    else
        echo "Error: Bash 4.0+ required (found ${BASH_VERSION})."
        echo "Please install bash via homebrew: brew install bash"
        exit 1
    fi
fi

# ==============================================================================
# Path Resolution
# ==============================================================================
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
export UKE_ROOT="${SCRIPT_DIR%/scripts}"

# Source core if available, otherwise define minimally
if [[ -f "$UKE_ROOT/lib/core.sh" ]]; then
    source "$UKE_ROOT/lib/core.sh"
else
    # Minimal definitions
    UKE_STATE="${XDG_STATE_HOME:-$HOME/.local/state}/uke"
    UKE_PROFILE_FILE="$UKE_STATE/machine.profile"
    is_macos() { [[ "$(uname -s)" == "Darwin" ]]; }
fi

# ==============================================================================
# Configuration
# ==============================================================================
PROFILE_DIR="${UKE_STATE:-$HOME/.local/state/uke}"
PROFILE_FILE="${PROFILE_DIR}/machine.profile"
APPLY_SCRIPT="${SCRIPT_DIR}/apply_profile.sh"

# ==============================================================================
# Option Arrays (for cycling)
# ==============================================================================
declare -a OS_OPTIONS=("arch" "macos")
declare -a FORM_FACTOR_OPTIONS=("desktop" "laptop_14" "laptop_10")
declare -a MONITORS_OPTIONS=("1" "2" "3")
declare -a GPU_OPTIONS=("integrated" "nvidia" "amd")
declare -a KEYBOARD_OPTIONS=("pc" "mac")

# ==============================================================================
# Current Values (loaded from profile or defaults)
# ==============================================================================
declare PROFILE_OS=""
declare PROFILE_FORM_FACTOR=""
declare PROFILE_MONITORS=""
declare PROFILE_GPU=""
declare PROFILE_KEYBOARD=""

# ==============================================================================
# Colors (use existing from core.sh or define new)
# ==============================================================================
if [[ -z "${C_RED:-}" ]]; then
    if [[ -t 1 ]]; then
        C_RED=$'\e[31m'
        C_GREEN=$'\e[32m'
        C_YELLOW=$'\e[33m'
        C_BLUE=$'\e[34m'
        C_MAGENTA=$'\e[35m'
        C_CYAN=$'\e[36m'
        C_BOLD=$'\e[1m'
        C_DIM=$'\e[2m'
        C_RESET=$'\e[0m'
    else
        C_RED='' C_GREEN='' C_YELLOW='' C_BLUE='' C_MAGENTA='' C_CYAN=''
        C_BOLD='' C_DIM='' C_RESET=''
    fi
fi

# ==============================================================================
# Utility Functions
# ==============================================================================
ok()   { printf "%sâœ“%s %s\n" "${C_GREEN}" "${C_RESET}" "$*"; }
warn() { printf "%s!%s %s\n" "${C_YELLOW}" "${C_RESET}" "$*"; }
fail() { printf "%sâœ—%s %s\n" "${C_RED}" "${C_RESET}" "$*"; }
info() { printf "%sâ†’%s %s\n" "${C_BLUE}" "${C_RESET}" "$*"; }

clear_screen() {
    printf '\033[2J\033[H'
}

# ==============================================================================
# Hardware Detection
# ==============================================================================
detect_os() {
    case "$(uname -s)" in
        Darwin) echo "macos" ;;
        Linux)  echo "arch" ;;
        *)      echo "arch" ;;
    esac
}

detect_form_factor() {
    if [[ "$(uname -s)" == "Darwin" ]]; then
        if system_profiler SPDisplaysDataType 2>/dev/null | grep -q "Built-in"; then
            echo "laptop_14"
        else
            echo "desktop"
        fi
    else
        # Linux: check for laptop battery
        if [[ -d /sys/class/power_supply/BAT0 ]] || [[ -d /sys/class/power_supply/BAT1 ]]; then
            echo "laptop_14"
        else
            echo "desktop"
        fi
    fi
}

detect_gpu() {
    if [[ "$(uname -s)" == "Darwin" ]]; then
        echo "integrated"
    elif command -v lspci &>/dev/null; then
        if lspci 2>/dev/null | grep -qi nvidia; then
            echo "nvidia"
        elif lspci 2>/dev/null | grep -qi "amd.*radeon\|radeon.*amd"; then
            echo "amd"
        else
            echo "integrated"
        fi
    else
        echo "integrated"
    fi
}

detect_monitors() {
    if [[ "$(uname -s)" == "Darwin" ]]; then
        local count
        count=$(system_profiler SPDisplaysDataType 2>/dev/null | grep -c "Resolution:" || echo "1")
        echo "$count"
    elif command -v hyprctl &>/dev/null && [[ -n "${HYPRLAND_INSTANCE_SIGNATURE:-}" ]]; then
        hyprctl monitors -j 2>/dev/null | jq 'length' 2>/dev/null || echo "1"
    elif command -v xrandr &>/dev/null; then
        xrandr --query 2>/dev/null | grep -c " connected" || echo "1"
    else
        echo "1"
    fi
}

# ==============================================================================
# Profile Management
# ==============================================================================
init_defaults() {
    PROFILE_OS="$(detect_os)"
    PROFILE_FORM_FACTOR="$(detect_form_factor)"
    PROFILE_MONITORS="$(detect_monitors)"
    PROFILE_GPU="$(detect_gpu)"
    
    # Keyboard defaults based on OS
    if [[ "${PROFILE_OS}" == "macos" ]]; then
        PROFILE_KEYBOARD="mac"
    else
        PROFILE_KEYBOARD="pc"
    fi
}

load_profile() {
    # Ensure directory exists
    mkdir -p "${PROFILE_DIR}"
    
    if [[ -f "${PROFILE_FILE}" ]]; then
        # Source existing profile
        # shellcheck source=/dev/null
        source "${PROFILE_FILE}"
        
        # Map to local variables
        PROFILE_OS="${UKE_OS:-$(detect_os)}"
        PROFILE_FORM_FACTOR="${UKE_FORM_FACTOR:-desktop}"
        PROFILE_MONITORS="${UKE_MONITORS:-1}"
        PROFILE_GPU="${UKE_GPU:-integrated}"
        PROFILE_KEYBOARD="${UKE_KEYBOARD:-pc}"
    else
        # First run - initialize with auto-detected defaults
        init_defaults
        save_profile
        ok "Initialized new profile with auto-detected settings"
        sleep 1
    fi
}

save_profile() {
    mkdir -p "${PROFILE_DIR}"
    
    # Use temp file for atomic write
    local temp_file
    temp_file=$(mktemp)
    
    cat > "${temp_file}" << EOF
# ==============================================================================
# UKE Machine Profile v7.0
# ==============================================================================
# Generated by: uke profile (manage_profile.sh)
# Last updated: $(date -Iseconds)
#
# This file defines hardware-specific settings for this machine.
# It is NOT version controlled - each machine has its own profile.
#
# To regenerate hardware configs: uke apply
# ==============================================================================

export UKE_OS="${PROFILE_OS}"
export UKE_FORM_FACTOR="${PROFILE_FORM_FACTOR}"
export UKE_MONITORS="${PROFILE_MONITORS}"
export UKE_GPU="${PROFILE_GPU}"
export UKE_KEYBOARD="${PROFILE_KEYBOARD}"
EOF
    
    mv "${temp_file}" "${PROFILE_FILE}"
    chmod 600 "${PROFILE_FILE}"
}

# ==============================================================================
# Option Cycling
# ==============================================================================
get_index() {
    local value="$1"
    shift
    local -a options=("$@")
    local i
    
    for i in "${!options[@]}"; do
        if [[ "${options[$i]}" == "${value}" ]]; then
            echo "$i"
            return 0
        fi
    done
    echo "0"
}

cycle_next() {
    local value="$1"
    shift
    local -a options=("$@")
    local idx
    
    idx=$(get_index "${value}" "${options[@]}")
    local next_idx=$(( (idx + 1) % ${#options[@]} ))
    echo "${options[$next_idx]}"
}

# ==============================================================================
# Display Functions
# ==============================================================================
print_header() {
    printf "%sâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—%s\n" "${C_CYAN}" "${C_RESET}"
    printf "%sâ•‘%s       UKE Profile Manager v7.0 - Hardware Config            %sâ•‘%s\n" "${C_CYAN}" "${C_BOLD}" "${C_CYAN}" "${C_RESET}"
    printf "%sâ•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•%s\n" "${C_CYAN}" "${C_RESET}"
    echo ""
}

print_value() {
    local label="$1"
    local value="$2"
    local key="$3"
    local -a options=("${@:4}")
    
    # Format options string
    local options_str=""
    local opt
    for opt in "${options[@]}"; do
        if [[ "${opt}" == "${value}" ]]; then
            options_str+="${C_GREEN}${C_BOLD}${opt}${C_RESET} "
        else
            options_str+="${C_DIM}${opt}${C_RESET} "
        fi
    done
    
    printf "  %s[%s]%s %-15s %s\n" "${C_YELLOW}" "${key}" "${C_RESET}" "${label}:" "${options_str}"
}

print_dashboard() {
    clear_screen
    print_header
    
    printf "%sCurrent Configuration:%s\n\n" "${C_BOLD}" "${C_RESET}"
    
    print_value "OS" "${PROFILE_OS}" "1" "${OS_OPTIONS[@]}"
    print_value "Form Factor" "${PROFILE_FORM_FACTOR}" "2" "${FORM_FACTOR_OPTIONS[@]}"
    print_value "Monitors" "${PROFILE_MONITORS}" "3" "${MONITORS_OPTIONS[@]}"
    print_value "GPU" "${PROFILE_GPU}" "4" "${GPU_OPTIONS[@]}"
    print_value "Keyboard" "${PROFILE_KEYBOARD}" "5" "${KEYBOARD_OPTIONS[@]}"
    
    echo ""
    printf "%sâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€%s\n" "${C_DIM}" "${C_RESET}"
    echo ""
    printf "  %s[1-5]%s Cycle option   %s[s]%s Save & Apply   %s[r]%s Auto-detect   %s[q]%s Quit\n" \
        "${C_YELLOW}" "${C_RESET}" \
        "${C_GREEN}" "${C_RESET}" \
        "${C_BLUE}" "${C_RESET}" \
        "${C_RED}" "${C_RESET}"
    echo ""
    
    # Show profile path
    printf "%s  Profile: %s%s\n" "${C_DIM}" "${PROFILE_FILE}" "${C_RESET}"
    echo ""
}

# ==============================================================================
# Actions
# ==============================================================================
apply_changes() {
    save_profile
    ok "Profile saved to ${PROFILE_FILE}"
    
    if [[ -x "${APPLY_SCRIPT}" ]]; then
        echo ""
        info "Generating hardware-specific configs..."
        echo ""
        if bash "${APPLY_SCRIPT}"; then
            ok "Hardware configs generated!"
            echo ""
            info "Next: Run 'uke gen && uke reload' to apply all changes"
        else
            fail "Config generation failed!"
        fi
    else
        warn "apply_profile.sh not found at: ${APPLY_SCRIPT}"
        info "Run 'uke apply' manually to generate hardware configs"
    fi
    
    echo ""
    printf "Press any key to continue..."
    read -r -n1 -s
}

reset_to_defaults() {
    info "Auto-detecting hardware..."
    init_defaults
    ok "Reset to auto-detected values"
    sleep 1
}

# ==============================================================================
# Main Loop
# ==============================================================================
main() {
    load_profile
    
    local running=true
    while ${running}; do
        print_dashboard
        
        printf "  Choice: "
        read -r -n1 choice
        echo ""
        
        case "${choice}" in
            1) PROFILE_OS=$(cycle_next "${PROFILE_OS}" "${OS_OPTIONS[@]}") ;;
            2) PROFILE_FORM_FACTOR=$(cycle_next "${PROFILE_FORM_FACTOR}" "${FORM_FACTOR_OPTIONS[@]}") ;;
            3) PROFILE_MONITORS=$(cycle_next "${PROFILE_MONITORS}" "${MONITORS_OPTIONS[@]}") ;;
            4) PROFILE_GPU=$(cycle_next "${PROFILE_GPU}" "${GPU_OPTIONS[@]}") ;;
            5) PROFILE_KEYBOARD=$(cycle_next "${PROFILE_KEYBOARD}" "${KEYBOARD_OPTIONS[@]}") ;;
            s|S) apply_changes ;;
            r|R) reset_to_defaults ;;
            q|Q) running=false ;;
            *) ;;
        esac
    done
    
    clear_screen
    info "Exiting UKE Profile Manager"
}

# Allow running with --auto flag for non-interactive setup
if [[ "${1:-}" == "--auto" ]]; then
    load_profile
    if [[ ! -f "${PROFILE_FILE}" ]]; then
        init_defaults
        save_profile
        ok "Auto-initialized profile: ${PROFILE_FILE}"
    else
        ok "Profile already exists: ${PROFILE_FILE}"
    fi
    exit 0
fi

main "$@"



################################################################################
FILE PATH: uke/scripts/apply_profile.sh
################################################################################

#!/usr/bin/env bash
# ==============================================================================
# UKE Profile Applicator v7.0 - Hardware Config Generator
# ==============================================================================
# Reads ~/.local/state/uke/machine.profile and generates hardware-specific
# "ghost files" that are sourced by the main configs but NOT version controlled.
#
# Generated files:
#   - ~/.config/hypr/generated_hardware.conf
#   - ~/.config/yabai/generated_hardware.conf  
#   - ~/.config/wezterm/generated_hardware.lua
#
# Usage: apply_profile.sh [--dry-run]
#        uke apply [--dry-run]
# ==============================================================================
set -euo pipefail

# ==============================================================================
# Path Resolution
# ==============================================================================
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
export UKE_ROOT="${SCRIPT_DIR%/scripts}"

# Source core if available
if [[ -f "$UKE_ROOT/lib/core.sh" ]]; then
    source "$UKE_ROOT/lib/core.sh"
else
    # Minimal definitions
    UKE_STATE="${XDG_STATE_HOME:-$HOME/.local/state}/uke"
    UKE_PROFILE_FILE="$UKE_STATE/machine.profile"
    is_macos() { [[ "$(uname -s)" == "Darwin" ]]; }
    is_linux() { [[ "$(uname -s)" == "Linux" ]]; }
fi

# ==============================================================================
# Configuration
# ==============================================================================
PROFILE_DIR="${UKE_STATE:-$HOME/.local/state/uke}"
PROFILE_FILE="${PROFILE_DIR}/machine.profile"

# Output directories
HYPR_DIR="${HOME}/.config/hypr"
YABAI_DIR="${HOME}/.config/yabai"
WEZTERM_DIR="${HOME}/.config/wezterm"

# Dry run mode
DRY_RUN="${1:-}"

# ==============================================================================
# Colors (use existing from core.sh or define new)
# ==============================================================================
# Don't use readonly to avoid conflicts with core.sh
if [[ -z "${C_RED:-}" ]]; then
    if [[ -t 1 ]]; then
        C_RED=$'\e[31m'
        C_GREEN=$'\e[32m'
        C_YELLOW=$'\e[33m'
        C_BLUE=$'\e[34m'
        C_DIM=$'\e[2m'
        C_BOLD=$'\e[1m'
        C_RESET=$'\e[0m'
    else
        C_RED='' C_GREEN='' C_YELLOW='' C_BLUE=''
        C_DIM='' C_BOLD='' C_RESET=''
    fi
fi

# ==============================================================================
# Logging
# ==============================================================================
ok()   { printf "%sâœ“%s %s\n" "${C_GREEN}" "${C_RESET}" "$*"; }
warn() { printf "%s!%s %s\n" "${C_YELLOW}" "${C_RESET}" "$*"; }
fail() { printf "%sâœ—%s %s\n" "${C_RED}" "${C_RESET}" "$*" >&2; }
info() { printf "%sâ†’%s %s\n" "${C_BLUE}" "${C_RESET}" "$*"; }

# ==============================================================================
# Generated File Header
# ==============================================================================
gen_header() {
    local format="$1"
    
    case "$format" in
        conf)
            printf '%s\n' \
                "# ==============================================================================" \
                "# DO NOT EDIT - GENERATED HARDWARE CONFIG (Ghost File)" \
                "# ==============================================================================" \
                "# Generated by: uke apply (apply_profile.sh)" \
                "# Source: ~/.local/state/uke/machine.profile" \
                "# Timestamp: $(date -Iseconds)" \
                "#" \
                "# This file contains machine-specific settings based on your hardware profile." \
                "# To modify, run: uke profile" \
                "# ==============================================================================" \
                ""
            ;;
        lua)
            printf '%s\n' \
                "-- ==============================================================================" \
                "-- DO NOT EDIT - GENERATED HARDWARE CONFIG (Ghost File)" \
                "-- ==============================================================================" \
                "-- Generated by: uke apply (apply_profile.sh)" \
                "-- Source: ~/.local/state/uke/machine.profile" \
                "-- Timestamp: $(date -Iseconds)" \
                "--" \
                "-- To modify, run: uke profile" \
                "-- ==============================================================================" \
                ""
            ;;
    esac
}

# ==============================================================================
# Safe File Writing
# ==============================================================================
write_file() {
    local dest="$1"
    local content
    content=$(cat)
    
    if [[ "${DRY_RUN}" == "--dry-run" ]]; then
        info "[DRY RUN] Would write: ${dest}"
        printf "%s\n" "${content}"
        echo ""
        return 0
    fi
    
    mkdir -p "$(dirname "${dest}")"
    
    local temp_file
    temp_file=$(mktemp)
    printf "%s\n" "${content}" > "${temp_file}"
    mv "${temp_file}" "${dest}"
    
    ok "Generated: ${dest}"
}

# ==============================================================================
# Load Profile
# ==============================================================================
load_profile() {
    if [[ ! -f "${PROFILE_FILE}" ]]; then
        fail "Profile not found: ${PROFILE_FILE}"
        info "Run 'uke profile' to create one"
        exit 1
    fi
    
    # shellcheck source=/dev/null
    source "${PROFILE_FILE}"
    
    # Validate required variables
    local required_vars=(UKE_OS UKE_FORM_FACTOR UKE_MONITORS UKE_GPU UKE_KEYBOARD)
    local var
    for var in "${required_vars[@]}"; do
        if [[ -z "${!var:-}" ]]; then
            fail "Missing required variable: ${var}"
            exit 1
        fi
    done
}

# ==============================================================================
# Form Factor â†’ Settings Mapping
# ==============================================================================
get_font_size() {
    case "${UKE_FORM_FACTOR}" in
        desktop)    echo "11.0" ;;
        laptop_14)  echo "12.5" ;;
        laptop_10)  echo "10.0" ;;
        *)          echo "11.0" ;;
    esac
}

get_gaps() {
    case "${UKE_FORM_FACTOR}" in
        desktop)    echo "3:6:2" ;;   # gaps_in:gaps_out:border
        laptop_14)  echo "2:4:2" ;;
        laptop_10)  echo "1:2:1" ;;
        *)          echo "2:4:2" ;;
    esac
}

get_padding() {
    case "${UKE_FORM_FACTOR}" in
        desktop)    echo "6" ;;
        laptop_14)  echo "4" ;;
        laptop_10)  echo "2" ;;
        *)          echo "4" ;;
    esac
}

# [FIX] Add scaling for small screens
get_scaling() {
    case "${UKE_FORM_FACTOR}" in
        laptop_10)  echo "1.25" ;;  # 10" laptops need scaling
        *)          echo "1" ;;     # Others use native resolution
    esac
}

# ==============================================================================
# Generate Hyprland Hardware Config
# ==============================================================================
gen_hyprland() {
    if [[ "${UKE_OS}" != "arch" ]] && [[ "${UKE_OS}" != "linux" ]]; then
        info "Skipping Hyprland config (OS=${UKE_OS})"
        return 0
    fi
    
    local gaps padding
    IFS=':' read -r gaps_in gaps_out border_size <<< "$(get_gaps)"
    padding=$(get_padding)
    
    {
        gen_header "conf"
        
        echo "# GPU Configuration (${UKE_GPU})"
        case "${UKE_GPU}" in
            nvidia)
                cat << 'NVIDIA'
env = LIBVA_DRIVER_NAME,nvidia
env = XDG_SESSION_TYPE,wayland
env = GBM_BACKEND,nvidia-drm
env = __GLX_VENDOR_LIBRARY_NAME,nvidia
env = WLR_NO_HARDWARE_CURSORS,1
env = WLR_DRM_NO_ATOMIC,1

cursor {
    no_hardware_cursors = true
}
NVIDIA
                ;;
            amd)
                cat << 'AMD'
env = LIBVA_DRIVER_NAME,radeonsi
# AMD GPU - generally good Wayland support
AMD
                ;;
            *)
                echo "# Integrated GPU - no special settings needed"
                ;;
        esac
        echo ""
        
        echo "# Form Factor Configuration (${UKE_FORM_FACTOR})"
        cat << EOF
general {
    gaps_in = ${gaps_in}
    gaps_out = ${gaps_out}
    border_size = ${border_size}
}
EOF
        echo ""
        
        # [FIX] Get scaling factor for small screens
        local scaling
        scaling=$(get_scaling)
        
        echo "# Monitor Configuration (${UKE_MONITORS} monitors, scale=${scaling})"
        case "${UKE_MONITORS}" in
            1)
                # Single monitor with scaling
                echo "# Single monitor - auto-detect with scaling"
                echo "monitor=,preferred,auto,${scaling}"
                ;;
            2)
                # Dual monitors
                cat << EOF
# Dual monitor workspace assignment
# NOTE: Monitor names may vary! Check yours with: hyprctl monitors
# Common names: eDP-1, eDP-2 (laptop), HDMI-A-1, DP-1, DP-2 (external)
# Adjust the names below to match your setup

# Primary monitor (usually laptop screen)
monitor=eDP-1,preferred,0x0,${scaling}
monitor=eDP-2,preferred,0x0,${scaling}

# Secondary monitor (external)
monitor=HDMI-A-1,preferred,auto,1
monitor=DP-1,preferred,auto,1
monitor=DP-2,preferred,auto,1

# Workspace assignment
workspace = 1, monitor:eDP-1, default:true
workspace = 2, monitor:eDP-1
workspace = 3, monitor:eDP-1
workspace = 4, monitor:eDP-1
workspace = 5, monitor:eDP-1
workspace = 6, monitor:HDMI-A-1, default:true
workspace = 7, monitor:HDMI-A-1
workspace = 8, monitor:HDMI-A-1
workspace = 9, monitor:HDMI-A-1
workspace = 10, monitor:HDMI-A-1
EOF
                ;;
            3)
                cat << EOF
# Triple monitor workspace assignment
# NOTE: Monitor names may vary! Check yours with: hyprctl monitors
monitor=eDP-1,preferred,0x0,${scaling}
monitor=DP-1,preferred,auto,1
monitor=HDMI-A-1,preferred,auto,1

workspace = 1, monitor:eDP-1, default:true
workspace = 2, monitor:eDP-1
workspace = 3, monitor:eDP-1
workspace = 4, monitor:DP-1, default:true
workspace = 5, monitor:DP-1
workspace = 6, monitor:DP-1
workspace = 7, monitor:HDMI-A-1, default:true
workspace = 8, monitor:HDMI-A-1
workspace = 9, monitor:HDMI-A-1
workspace = 10, monitor:HDMI-A-1
EOF
                ;;
        esac
        echo ""
        
        echo "# Keyboard Configuration (${UKE_KEYBOARD})"
        if [[ "${UKE_KEYBOARD}" == "mac" ]]; then
            cat << 'MACKB'
input {
    kb_options = altwin:swap_lalt_lwin
}
MACKB
        else
            echo "# Standard PC keyboard layout"
        fi
        
    } | write_file "${HYPR_DIR}/generated_hardware.conf"
}

# ==============================================================================
# Generate Yabai Hardware Config
# ==============================================================================
gen_yabai() {
    if [[ "${UKE_OS}" != "macos" ]]; then
        return 0
    fi
    
    local padding
    padding=$(get_padding)
    
    {
        gen_header "conf"
        
        echo "# Form Factor Configuration (${UKE_FORM_FACTOR})"
        cat << EOF
yabai -m config top_padding    ${padding}
yabai -m config bottom_padding ${padding}
yabai -m config left_padding   ${padding}
yabai -m config right_padding  ${padding}
yabai -m config window_gap     ${padding}
EOF
        echo ""
        
        echo "# Monitor Configuration (${UKE_MONITORS} monitors)"
        if [[ "${UKE_MONITORS}" != "1" ]]; then
            echo "# Multi-monitor mode - workspaces distributed across displays"
        else
            echo "# Single monitor mode"
        fi
        
    } | write_file "${YABAI_DIR}/generated_hardware.conf"
}

# ==============================================================================
# Generate WezTerm Hardware Config
# ==============================================================================
gen_wezterm() {
    local font_size front_end
    font_size=$(get_font_size)
    
    case "${UKE_GPU}" in
        nvidia) front_end="WebGpu" ;;
        *)      front_end="OpenGL" ;;
    esac
    
    {
        gen_header "lua"
        
        cat << EOF
local M = {}

-- Profile: ${UKE_FORM_FACTOR}
M.font_size = ${font_size}

-- OS Detection
M.os = "${UKE_OS}"
M.is_macos = M.os == "macos"
M.is_linux = M.os == "arch" or M.os == "linux"

-- Keyboard layout
M.keyboard = "${UKE_KEYBOARD}"

-- GPU settings
M.gpu = "${UKE_GPU}"
M.front_end = "${front_end}"

-- Monitor count
M.monitors = ${UKE_MONITORS}

return M
EOF
    } | write_file "${WEZTERM_DIR}/generated_hardware.lua"
}

# ==============================================================================
# Summary
# ==============================================================================
print_summary() {
    local font_size gaps
    font_size=$(get_font_size)
    IFS=':' read -r gaps_in gaps_out border_size <<< "$(get_gaps)"
    
    echo ""
    printf "%sâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”%s\n" "${C_DIM}" "${C_RESET}"
    printf "%sHardware Profile Summary:%s\n" "${C_BOLD}" "${C_RESET}"
    echo "  OS:          ${UKE_OS}"
    echo "  Form Factor: ${UKE_FORM_FACTOR}"
    echo "  Monitors:    ${UKE_MONITORS}"
    echo "  GPU:         ${UKE_GPU}"
    echo "  Keyboard:    ${UKE_KEYBOARD}"
    echo ""
    printf "%sComputed Settings:%s\n" "${C_BOLD}" "${C_RESET}"
    echo "  Font Size:   ${font_size}pt"
    echo "  Gaps:        in=${gaps_in} out=${gaps_out} border=${border_size}"
    printf "%sâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”%s\n" "${C_DIM}" "${C_RESET}"
}

# ==============================================================================
# Main
# ==============================================================================
main() {
    if [[ "${DRY_RUN}" == "--dry-run" ]]; then
        info "DRY RUN MODE - No files will be written"
        echo ""
    fi
    
    info "Loading profile from ${PROFILE_FILE}..."
    load_profile
    
    info "Generating hardware-specific configs (Ghost Files)..."
    echo ""
    
    # Generate all configs
    # [FIX] Removed gen_alacritty to prevent permission errors
    gen_hyprland
    gen_yabai
    gen_wezterm
    
    print_summary
    
    echo ""
    if [[ "${DRY_RUN}" != "--dry-run" ]]; then
        if [[ "${UKE_OS}" == "arch" ]] || [[ "${UKE_OS}" == "linux" ]]; then
            info "Reload Hyprland: hyprctl reload"
        else
            # [FIX] Service autostart logic: Start if not running, otherwise reload
            # Uses direct flags instead of 'brew services' which can fail
            if ! pgrep -x "yabai" >/dev/null; then
                info "Starting yabai..."
                yabai --start-service 2>/dev/null || true
            else
                info "Reloading yabai..."
                yabai --restart-service 2>/dev/null || true
            fi

            if ! pgrep -x "skhd" >/dev/null; then
                info "Starting skhd..."
                skhd --start-service 2>/dev/null || true
            else
                skhd --restart-service 2>/dev/null || true
            fi
        fi
    fi
}

main "$@"



################################################################################
FILE PATH: uke/lib/gen.sh
################################################################################

#!/usr/bin/env bash
# ==============================================================================
# UKE Config Generator v7.0 - Dynamic YAML-Driven Generation
# ==============================================================================
# Generates platform-specific configs from registry.yaml (the Single Source of Truth)
# and integrates hardware-specific ghost files from machine.profile.
#
# Features:
#   - Dynamic keybinding generation from registry.yaml
#   - Dynamic workspace/app rules from registry.yaml
#   - Hardware profile integration (ghost files)
#   - Cloud path support
#   - Unified colorscheme
#
# Usage: gen.sh [target]
#   target: skhd | yabai | hyprland | gather | all
# ==============================================================================
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/core.sh"

# ==============================================================================
# Verify Dependencies
# ==============================================================================
check_yq() {
    if ! command -v yq &>/dev/null; then
        log_warn "yq not found - falling back to static generation"
        log_warn "Install yq for dynamic YAML parsing: brew install yq (macOS) or pacman -S go-yq (Arch)"
        return 1
    fi
    return 0
}

# ==============================================================================
# Registry Path Resolution
# ==============================================================================
REGISTRY="$UKE_CONFIG/registry.yaml"

ensure_registry() {
    if [[ ! -f "$REGISTRY" ]]; then
        log_fatal "Registry not found: $REGISTRY"
    fi
}

# ==============================================================================
# Generated File Header
# ==============================================================================
gen_header() {
    local format="$1"
    local file_desc="${2:-}"
    
    case "$format" in
        conf|sh)
            cat << EOF
# ==============================================================================
# ${file_desc:-AUTO-GENERATED BY UKE v$UKE_VERSION}
# ==============================================================================
# Source: $REGISTRY
# Generated: $(date -Iseconds)
# Platform: $UKE_OS
#
# DO NOT EDIT DIRECTLY - Regenerate with: uke gen
# ==============================================================================

EOF
            ;;
        lua)
            cat << EOF
-- ==============================================================================
-- ${file_desc:-AUTO-GENERATED BY UKE v$UKE_VERSION}
-- ==============================================================================
-- Source: $REGISTRY
-- Generated: $(date -Iseconds)
-- Platform: $UKE_OS
--
-- DO NOT EDIT DIRECTLY - Regenerate with: uke gen
-- ==============================================================================

EOF
            ;;
    esac
}

# ==============================================================================
# YAML Query Helpers
# ==============================================================================
# Get a value from registry.yaml with a default
reg_get() {
    local path="$1"
    local default="${2:-}"
    yaml_get "$REGISTRY" "$path" "$default"
}

# Get keys from a path
reg_keys() {
    local path="$1"
    yaml_keys "$REGISTRY" "$path"
}

# Get array values from a path
reg_array() {
    local path="$1"
    yaml_array "$REGISTRY" "$path"
}

# Get modifier for current platform
get_modifier() {
    local mod_name="$1"
    local platform_key
    is_macos && platform_key="macos" || platform_key="linux"
    reg_get ".modifiers.${mod_name}.${platform_key}"
}

# Get app name for current platform
get_app_name() {
    local app_key="$1"
    local platform_key
    is_macos && platform_key="macos" || platform_key="linux"
    reg_get ".apps.${app_key}.${platform_key}"
}

# ==============================================================================
# Colorscheme (from registry or defaults)
# ==============================================================================
get_color() {
    local color_name="$1"
    local default="$2"
    local theme_color
    theme_color=$(reg_get ".theme.colors.${color_name}")
    echo "${theme_color:-$default}"
}

# Default Nord colorscheme
COLOR_ACCENT=$(get_color "accent" "#88c0d0")
COLOR_BG=$(get_color "background" "#2e3440")
COLOR_BG_LIGHT=$(get_color "bg_light" "#3b4252")
COLOR_BORDER_ACTIVE=$(get_color "border_active" "88c0d0")
COLOR_BORDER_INACTIVE=$(get_color "border_inactive" "3b4252")

# ==============================================================================
# Generate skhd config (macOS)
# ==============================================================================
gen_skhd() {
    local out="$UKE_GEN/skhd/skhdrc"
    mkdir -p "$(dirname "$out")"
    
    log_info "Generating skhd config..."
    
    # Get modifiers
    local PRIMARY=$(get_modifier "primary")
    local PRIMARY_SHIFT=$(get_modifier "primary_shift")
    local TERTIARY=$(get_modifier "tertiary")
    local LAUNCHER=$(get_modifier "launcher")
    local BUNCH=$(get_modifier "bunch")
    
    {
        gen_header "conf" "SKHD CONFIG - Keyboard Shortcuts (macOS)"
        
        cat << 'STATIC_BINDINGS'
# ==============================================================================
# Smart Focus & Focus History
# ==============================================================================
cmd - escape : yabai -m window --focus mouse
cmd + shift - 0x32 : yabai -m window --focus recent

# ==============================================================================
# Window Focus Navigation (PRIMARY: Cmd + hjkl)
# ==============================================================================
cmd - h : yabai -m window --focus west
cmd - j : yabai -m window --focus south
cmd - k : yabai -m window --focus north
cmd - l : yabai -m window --focus east

# ==============================================================================
# Window Movement (PRIMARY + SHIFT: Cmd+Shift + hjkl)
# ==============================================================================
cmd + shift - h : yabai -m window --warp west
cmd + shift - j : yabai -m window --warp south
cmd + shift - k : yabai -m window --warp north
cmd + shift - l : yabai -m window --warp east

# ==============================================================================
# Window Resizing (TERTIARY: Alt+Shift + hjkl)
# ==============================================================================
alt + shift - h : yabai -m window --resize left:-50:0
alt + shift - j : yabai -m window --resize bottom:0:50
alt + shift - k : yabai -m window --resize top:0:-50
alt + shift - l : yabai -m window --resize right:50:0

# ==============================================================================
# Launch Terminal
# ==============================================================================
cmd - return : open -a WezTerm

# ==============================================================================
# Window Controls
# ==============================================================================
cmd + shift - f : yabai -m window --toggle zoom-fullscreen
cmd + shift - space : yabai -m window --toggle float
cmd + shift - 0x2A : yabai -m window --toggle split

# ==============================================================================
# Advanced Layout Controls
# ==============================================================================
cmd + ctrl - s : yabai -m window --insert stack
cmd + shift - r : yabai -m space --rotate 90
cmd + shift - x : yabai -m space --mirror x-axis
cmd + shift - y : yabai -m space --mirror y-axis
cmd + shift - b : yabai -m space --balance
cmd + ctrl - t : yabai -m space --layout $(yabai -m query --spaces --space | jq -r 'if .type == "bsp" then "stack" else "bsp" end')

# ==============================================================================
# Workspace Navigation (PRIMARY + Number)
# ==============================================================================
cmd - 1 : yabai -m space --focus 1
cmd - 2 : yabai -m space --focus 2
cmd - 3 : yabai -m space --focus 3
cmd - 4 : yabai -m space --focus 4
cmd - 5 : yabai -m space --focus 5
cmd - 6 : yabai -m space --focus 6
cmd - 7 : yabai -m space --focus 7
cmd - 8 : yabai -m space --focus 8
cmd - 9 : yabai -m space --focus 9
cmd - 0x1D : yabai -m space --focus 10
cmd - 0x21 : yabai -m space --focus prev
cmd - 0x1E : yabai -m space --focus next

# ==============================================================================
# Move Window to Workspace (PRIMARY + SHIFT + Number)
# ==============================================================================
cmd + shift - 1 : yabai -m window --space 1 --focus
cmd + shift - 2 : yabai -m window --space 2 --focus
cmd + shift - 3 : yabai -m window --space 3 --focus
cmd + shift - 4 : yabai -m window --space 4 --focus
cmd + shift - 5 : yabai -m window --space 5 --focus
cmd + shift - 6 : yabai -m window --space 6 --focus
cmd + shift - 7 : yabai -m window --space 7 --focus
cmd + shift - 8 : yabai -m window --space 8 --focus
cmd + shift - 9 : yabai -m window --space 9 --focus
cmd + shift - 0x1D : yabai -m window --space 10 --focus

# ==============================================================================
# Gather Windows (Cmd + `)
# ==============================================================================
cmd - 0x32 : $HOME/.local/bin/uke-gather

# ==============================================================================
# Scratchpads
# ==============================================================================
cmd + alt - 0x32 : $HOME/.local/bin/uke-scratchpad terminal
cmd + alt - n : $HOME/.local/bin/uke-scratchpad notes
cmd + alt - m : $HOME/.local/bin/uke-scratchpad music

# ==============================================================================
# Smart App Launchers (LAUNCHER: Cmd+Alt)
# ==============================================================================
# Sticky window (floating + pinned + always-on-top)
cmd + shift - s : $HOME/.local/bin/uke-sticky toggle
# Quick fix
cmd + shift - x : $HOME/.local/bin/uke-fix

cmd + alt - b : $HOME/.local/bin/uke-launch brave
cmd + alt - o : $HOME/.local/bin/uke-launch obsidian
cmd + alt - c : $HOME/.local/bin/uke-launch code
cmd + alt - r : $HOME/.local/bin/uke-launch raindrop
cmd + alt - t : $HOME/.local/bin/uke-launch wezterm

STATIC_BINDINGS

        # Generate bunches from registry.yaml
        echo "# =============================================================================="
        echo "# Bunches (Generated from registry.yaml)"
        echo "# =============================================================================="
        
        if check_yq; then
            local bunch_num=1
            for bunch_name in $(reg_keys ".bunches"); do
                echo "cmd + ctrl - $bunch_num : \$HOME/.local/bin/uke-bunch $bunch_name"
                ((bunch_num++))
                [[ $bunch_num -gt 5 ]] && break
            done
        else
            cat << 'STATIC_BUNCHES'
cmd + ctrl - 1 : $HOME/.local/bin/uke-bunch study
cmd + ctrl - 2 : $HOME/.local/bin/uke-bunch guitar
cmd + ctrl - 3 : $HOME/.local/bin/uke-bunch coding
cmd + ctrl - 4 : $HOME/.local/bin/uke-bunch email
cmd + ctrl - 5 : $HOME/.local/bin/uke-bunch reading
STATIC_BUNCHES
        fi
        
        cat << 'SESSION_BINDINGS'

# ==============================================================================
# Session Management
# ==============================================================================
cmd + ctrl - s : $HOME/.local/bin/uke-session save quick
cmd + ctrl + shift - s : $HOME/.local/bin/uke-session restore quick
SESSION_BINDINGS

    } > "$out"
    
    chmod +x "$out"
    ok "Generated: $out"
}

# ==============================================================================
# Generate yabai config (macOS)
# ==============================================================================
gen_yabai() {
    local out="$UKE_GEN/yabai/yabairc"
    mkdir -p "$(dirname "$out")"
    
    log_info "Generating yabai config..."
    
    {
        gen_header "sh" "YABAI CONFIG - Window Manager (macOS)"
        
        cat << EOF
#!/usr/bin/env sh

# Load Scripting Addition
sudo yabai --load-sa

# ==============================================================================
# Layout Configuration
# ==============================================================================
yabai -m config layout bsp
yabai -m config window_placement second_child
yabai -m config top_padding    4
yabai -m config bottom_padding 4
yabai -m config left_padding   4
yabai -m config right_padding  4
yabai -m config window_gap     4

# ==============================================================================
# Mouse Configuration
# ==============================================================================
yabai -m config mouse_follows_focus off
yabai -m config focus_follows_mouse off
yabai -m config mouse_modifier alt
yabai -m config mouse_action1 move
yabai -m config mouse_action2 resize

# ==============================================================================
# Window Behavior
# ==============================================================================
yabai -m config split_ratio 0.50
yabai -m config auto_balance off

# ==============================================================================
# Window Borders (Nord colorscheme)
# ==============================================================================
pkill -x borders 2>/dev/null || true
borders width=3 active_color=0xff${COLOR_BORDER_ACTIVE} inactive_color=0xff${COLOR_BORDER_INACTIVE} &

# ==============================================================================
# Terminal Opacity
# ==============================================================================
yabai -m config window_opacity off
yabai -m rule --add app="^WezTerm\$" opacity=0.92
yabai -m rule --add app="^Alacritty\$" opacity=0.92

EOF

        # Generate float rules from registry.yaml
        echo "# =============================================================================="
        echo "# Float Rules (Generated from registry.yaml)"
        echo "# =============================================================================="
        
        if check_yq; then
            for rule in $(reg_array ".float_rules"); do
                echo "yabai -m rule --add app=\"^${rule}\$\" manage=off"
            done
            echo ""
            
            # Generate window rules
            echo "# =============================================================================="
            echo "# Window Rules (Generated from registry.yaml)"
            echo "# =============================================================================="
            # Read window_rules array - this is more complex, use static for now
        fi
        
        cat << 'STATIC_RULES'
yabai -m rule --add app="^System Settings$" manage=off
yabai -m rule --add app="^Calculator$" manage=off sticky=on
yabai -m rule --add app="^Finder$" manage=off
yabai -m rule --add app="^App Store$" manage=off
yabai -m rule --add app="^Karabiner-Elements$" manage=off
yabai -m rule --add app="^Karabiner-EventViewer$" manage=off
yabai -m rule --add app="^zoom.us$" manage=off sticky=on opacity=1.0
yabai -m rule --add app="^FaceTime$" manage=off sticky=on
yabai -m rule --add title="Picture in Picture" manage=off sticky=on layer=above
yabai -m rule --add app="^Code$" title="Settings" manage=off
yabai -m rule --add title="Preferences" manage=off
yabai -m rule --add title="Settings" manage=off
STATIC_RULES

        echo ""
        echo "# =============================================================================="
        echo "# Workspace Assignments (Generated from registry.yaml)"
        echo "# =============================================================================="
        
        if check_yq; then
            for ws in $(reg_keys ".workspaces"); do
                for app in $(reg_array ".workspaces.${ws}.apps"); do
                    local app_name
                    app_name=$(get_app_name "$app")
                    [[ -n "$app_name" ]] && echo "yabai -m rule --add app=\"^${app_name}\$\" space=^${ws}"
                done
            done
        else
            cat << 'STATIC_WS'
yabai -m rule --add app="^Safari$" space=^1
yabai -m rule --add app="^Brave Browser$" space=^1
yabai -m rule --add app="^Obsidian$" space=^2
yabai -m rule --add app="^WezTerm$" space=^3
yabai -m rule --add app="^Code$" space=^3
yabai -m rule --add app="^Xcode$" space=^3
yabai -m rule --add app="^Preview$" space=^5
yabai -m rule --add app="^PDF Expert$" space=^5
yabai -m rule --add app="^Raindrop.io$" space=^6
yabai -m rule --add app="^Spotify$" space=^7
yabai -m rule --add app="^Microsoft Word$" space=^8
yabai -m rule --add app="^Microsoft Excel$" space=^8
yabai -m rule --add app="^Microsoft PowerPoint$" space=^8
yabai -m rule --add app="^Slack$" space=^9
yabai -m rule --add app="^Discord$" space=^9
yabai -m rule --add app="^Mail$" space=^9
yabai -m rule --add app="^Claude$" space=^10
yabai -m rule --add app="^Perplexity$" space=^10
STATIC_WS
        fi
        
        cat << 'HARDWARE_INCLUDE'

# ==============================================================================
# HARDWARE SPECIFIC INCLUDES (Ghost Files)
# ==============================================================================
# Loads GPU/Monitor/Form Factor settings generated by: uke profile
# These settings override defaults based on machine.profile
HARDWARE_CONF="$HOME/.config/yabai/generated_hardware.conf"
if [[ -f "$HARDWARE_CONF" ]]; then
    source "$HARDWARE_CONF"
fi

echo "yabai: Configuration loaded"
HARDWARE_INCLUDE

    } > "$out"
    
    chmod +x "$out"
    ok "Generated: $out"
}

# ==============================================================================
# Generate Hyprland config (Linux)
# ==============================================================================


gen_hyprland() {
    local out="$UKE_GEN/hyprland/hyprland.conf"
    mkdir -p "$(dirname "$out")"
    
    log_info "Generating Hyprland config (RECOVERY MODE)..."
    
    {
        gen_header "conf" "HYPRLAND CONFIG - Window Manager (Linux)"
        
        # 1. CORE SETTINGS (Quoted Heredoc - Variables are safe here)
        cat << 'HYPRLAND_CORE'
monitor=,preferred,auto,1

general {
    gaps_in = 2
    gaps_out = 4
    border_size = 2
    col.active_border = rgba(88c0d0ff)
    col.inactive_border = rgba(3b4252ff)
    layout = dwindle
    resize_on_border = true
}

decoration {
    rounding = 4
    blur {
        enabled = true
        size = 6
        passes = 2
    }
    shadow {
        enabled = true
        range = 8
        color = rgba(1a1a1aee)
    }
}

animations {
    enabled = true
    bezier = easeOutQuint, 0.22, 1, 0.36, 1
    animation = windows, 1, 4, easeOutQuint, slide
    animation = border, 1, 10, default
    animation = fade, 1, 5, default
    animation = workspaces, 1, 4, easeOutQuint, slide
}

input {
    kb_layout = us
    follow_mouse = 1
    touchpad {
        natural_scroll = true
    }
}

# GESTURES (Disabled for stability)
gestures {
    workspace_swipe = false
}
HYPRLAND_CORE

        # 2. KEYBINDINGS (Unquoted Heredoc - Variables expanded)
        # CRITICAL FIX: We use \$mainMod to escape the variable for Bash!
        
        local MOD="${UKE_MAIN_MOD:-Super}"
        
        cat << KEYBINDS

# Define the mod key variable for Hyprland
\$mainMod = $MOD

# App shortcuts
bind = \$mainMod, return, exec, wezterm
bind = \$mainMod, q, killactive
bind = \$mainMod, e, exit
bind = \$mainMod, f, togglefloating
bind = \$mainMod, p, pseudo
bind = \$mainMod, j, togglesplit

# Vim-style focus movement
bind = \$mainMod, h, movefocus, l
bind = \$mainMod, j, movefocus, d
bind = \$mainMod, k, movefocus, u
bind = \$mainMod, l, movefocus, r

# Workspaces 1-9
bind = \$mainMod, 1, workspace, 1
bind = \$mainMod, 2, workspace, 2
bind = \$mainMod, 3, workspace, 3
bind = \$mainMod, 4, workspace, 4
bind = \$mainMod, 5, workspace, 5
bind = \$mainMod, 6, workspace, 6
bind = \$mainMod, 7, workspace, 7
bind = \$mainMod, 8, workspace, 8
bind = \$mainMod, 9, workspace, 9

# Move active window to workspace
bind = \$mainMod SHIFT, 1, movetoworkspace, 1
bind = \$mainMod SHIFT, 2, movetoworkspace, 2
bind = \$mainMod SHIFT, 3, movetoworkspace, 3
bind = \$mainMod SHIFT, 4, movetoworkspace, 4
bind = \$mainMod SHIFT, 5, movetoworkspace, 5
bind = \$mainMod SHIFT, 6, movetoworkspace, 6
bind = \$mainMod SHIFT, 7, movetoworkspace, 7
bind = \$mainMod SHIFT, 8, movetoworkspace, 8
bind = \$mainMod SHIFT, 9, movetoworkspace, 9

KEYBINDS

        # 3. RULES & HARDWARE
        cat << 'WINDOWRULES'
windowrulev2 = workspace 1, class:^(brave-browser|firefox|chromium)$
windowrulev2 = workspace 3, class:^(wezterm|code|Code|Alacritty|kitty)$

# Load hardware specific settings (monitors, etc)
source = ~/.config/hypr/generated_hardware.conf
WINDOWRULES

    } > "$out"
    
    chmod 644 "$out"
    log_info "âœ“ Hyprland config generated (RECOVERY MODE)"
}





# ==============================================================================
# Generate uke-gather script
# ==============================================================================
gen_gather() {
    local out="$UKE_BIN/uke-gather"
    mkdir -p "$(dirname "$out")"
    
    log_info "Generating uke-gather..."
    
    {
        gen_header "sh" "UKE Gather - Organize windows by workspace"
        
        cat << 'EOF'
#!/usr/bin/env bash
set -euo pipefail

SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do
  DIR="$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )"
  SOURCE="$(readlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"
done
SCRIPT_DIR="$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )"
export UKE_ROOT="${SCRIPT_DIR%/bin}"

source "$UKE_ROOT/lib/core.sh"
require_cmd jq

gather_macos() {
    local current_space
    current_space=$(yabai -m query --spaces --space | jq -r '.index')
    log_info "Gathering windows for space $current_space..."
    
    case $current_space in
        1)
            yabai -m query --windows | jq -r '.[] | select(.app == "Safari" or .app == "Brave Browser" or .app == "Firefox") | .id' | \
                xargs -I {} yabai -m window {} --space 1 2>/dev/null || true
            ;;
        2)
            yabai -m query --windows | jq -r '.[] | select(.app == "Obsidian") | .id' | \
                xargs -I {} yabai -m window {} --space 2 2>/dev/null || true
            ;;
        3)
            yabai -m query --windows | jq -r '.[] | select(.app == "WezTerm" or .app == "Code" or .app == "Xcode" or .app == "Cursor") | .id' | \
                xargs -I {} yabai -m window {} --space 3 2>/dev/null || true
            ;;
        5)
            yabai -m query --windows | jq -r '.[] | select(.app == "Preview" or .app == "PDF Expert") | .id' | \
                xargs -I {} yabai -m window {} --space 5 2>/dev/null || true
            ;;
        6)
            yabai -m query --windows | jq -r '.[] | select(.app == "Raindrop.io") | .id' | \
                xargs -I {} yabai -m window {} --space 6 2>/dev/null || true
            ;;
        7)
            yabai -m query --windows | jq -r '.[] | select(.app == "Spotify") | .id' | \
                xargs -I {} yabai -m window {} --space 7 2>/dev/null || true
            ;;
        8)
            yabai -m query --windows | jq -r '.[] | select(.app == "Microsoft Word" or .app == "Microsoft Excel" or .app == "Microsoft PowerPoint") | .id' | \
                xargs -I {} yabai -m window {} --space 8 2>/dev/null || true
            ;;
        9)
            yabai -m query --windows | jq -r '.[] | select(.app == "Slack" or .app == "Discord" or .app == "Mail") | .id' | \
                xargs -I {} yabai -m window {} --space 9 2>/dev/null || true
            ;;
        10)
            yabai -m query --windows | jq -r '.[] | select(.app == "Claude" or .app == "Perplexity") | .id' | \
                xargs -I {} yabai -m window {} --space 10 2>/dev/null || true
            ;;
        *)
            log_info "No gather action for space $current_space"
            ;;
    esac
    ok "Windows gathered"
}

gather_linux() {
    local current_ws
    current_ws=$(hyprctl activeworkspace -j | jq -r '.id')
    log_info "Gathering windows for workspace $current_ws..."
    
    case $current_ws in
        1)
            hyprctl clients -j | jq -r '.[] | select(.class | test("brave|firefox|chromium"; "i")) | .address' | \
                while read -r addr; do hyprctl dispatch movetoworkspacesilent "1,address:$addr" 2>/dev/null; done
            ;;
        2)
            hyprctl clients -j | jq -r '.[] | select(.class | test("obsidian"; "i")) | .address' | \
                while read -r addr; do hyprctl dispatch movetoworkspacesilent "2,address:$addr" 2>/dev/null; done
            ;;
        3)
            hyprctl clients -j | jq -r '.[] | select(.class | test("wezterm|code|alacritty|kitty"; "i")) | .address' | \
                while read -r addr; do hyprctl dispatch movetoworkspacesilent "3,address:$addr" 2>/dev/null; done
            ;;
        5)
            hyprctl clients -j | jq -r '.[] | select(.class | test("evince|zathura|okular"; "i")) | .address' | \
                while read -r addr; do hyprctl dispatch movetoworkspacesilent "5,address:$addr" 2>/dev/null; done
            ;;
        6)
            hyprctl clients -j | jq -r '.[] | select(.class | test("raindrop"; "i")) | .address' | \
                while read -r addr; do hyprctl dispatch movetoworkspacesilent "6,address:$addr" 2>/dev/null; done
            ;;
        7)
            hyprctl clients -j | jq -r '.[] | select(.class | test("spotify"; "i")) | .address' | \
                while read -r addr; do hyprctl dispatch movetoworkspacesilent "7,address:$addr" 2>/dev/null; done
            ;;
        8)
            hyprctl clients -j | jq -r '.[] | select(.class | test("libreoffice|soffice"; "i")) | .address' | \
                while read -r addr; do hyprctl dispatch movetoworkspacesilent "8,address:$addr" 2>/dev/null; done
            ;;
        9)
            hyprctl clients -j | jq -r '.[] | select(.class | test("slack|discord|thunderbird|telegram"; "i")) | .address' | \
                while read -r addr; do hyprctl dispatch movetoworkspacesilent "9,address:$addr" 2>/dev/null; done
            ;;
        10)
            hyprctl clients -j | jq -r '.[] | select(.class | test("claude"; "i")) | .address' | \
                while read -r addr; do hyprctl dispatch movetoworkspacesilent "10,address:$addr" 2>/dev/null; done
            ;;
        *)
            log_info "No gather action for workspace $current_ws"
            ;;
    esac
    ok "Windows gathered"
}

is_macos && gather_macos || gather_linux
EOF

    } > "$out"
    
    chmod +x "$out"
    ok "Generated: $out"
}

# ==============================================================================
# Main
# ==============================================================================
gen_all() {
    log_info "Generating all configs..."
    ensure_registry
    
    if is_macos; then
        gen_skhd
        gen_yabai
    else
        gen_hyprland
    fi
    gen_gather
    
    echo ""
    ok "All configs generated"
    echo ""
    
    # Check if hardware profile exists
    if ! has_profile; then
        warn "No hardware profile found!"
        info "Run 'uke profile' to configure machine-specific settings"
        info "Then run 'uke apply' to generate hardware configs"
    fi
}

case "${1:-all}" in
    skhd)     ensure_registry; gen_skhd ;;
    yabai)    ensure_registry; gen_yabai ;;
    hyprland) ensure_registry; gen_hyprland ;;
    gather)   gen_gather ;;
    all)      gen_all ;;
    *)        log_fatal "Unknown target: $1. Use: skhd|yabai|hyprland|gather|all" ;;
esac



################################################################################
FILE PATH: uke/lib/wm.sh
################################################################################

#!/usr/bin/env bash
# ==============================================================================
# UKE Window Manager Abstraction v7.0
# ==============================================================================

[[ -n "${_UKE_WM_LOADED:-}" ]] && return 0
readonly _UKE_WM_LOADED=1

source "${UKE_LIB:-$(dirname "$0")/../lib}/core.sh"

# ==============================================================================
# Status
# ==============================================================================
wm_name() {
    is_macos && echo "yabai" || echo "hyprland"
}

wm_running() {
    if is_macos; then
        pgrep -q yabai
    else
        [[ -n "${HYPRLAND_INSTANCE_SIGNATURE:-}" ]]
    fi
}

# ==============================================================================
# Focus
# ==============================================================================
wm_focus() {
    local dir="$1"
    if is_macos; then
        case "$dir" in
            left)  yabai -m window --focus west ;;
            down)  yabai -m window --focus south ;;
            up)    yabai -m window --focus north ;;
            right) yabai -m window --focus east ;;
        esac
    else
        local d; case "$dir" in left) d=l;; down) d=d;; up) d=u;; right) d=r;; esac
        hyprctl dispatch movefocus "$d"
    fi
}

# ==============================================================================
# Move Window
# ==============================================================================
wm_move() {
    local dir="$1"
    if is_macos; then
        case "$dir" in
            left)  yabai -m window --warp west ;;
            down)  yabai -m window --warp south ;;
            up)    yabai -m window --warp north ;;
            right) yabai -m window --warp east ;;
        esac
    else
        local d; case "$dir" in left) d=l;; down) d=d;; up) d=u;; right) d=r;; esac
        hyprctl dispatch movewindow "$d"
    fi
}

# ==============================================================================
# Resize
# ==============================================================================
wm_resize() {
    local dir="$1" amt="${2:-50}"
    if is_macos; then
        case "$dir" in
            left)  yabai -m window --resize left:-${amt}:0 ;;
            down)  yabai -m window --resize bottom:0:${amt} ;;
            up)    yabai -m window --resize top:0:-${amt} ;;
            right) yabai -m window --resize right:${amt}:0 ;;
        esac
    else
        case "$dir" in
            left)  hyprctl dispatch resizeactive -${amt} 0 ;;
            down)  hyprctl dispatch resizeactive 0 ${amt} ;;
            up)    hyprctl dispatch resizeactive 0 -${amt} ;;
            right) hyprctl dispatch resizeactive ${amt} 0 ;;
        esac
    fi
}

# ==============================================================================
# Workspace
# ==============================================================================
wm_workspace() {
    local ws="$1"
    is_macos && yabai -m space --focus "$ws" || hyprctl dispatch workspace "$ws"
}

wm_move_to_workspace() {
    local ws="$1" follow="${2:-1}"
    if is_macos; then
        [[ "$follow" == "1" ]] && yabai -m window --space "$ws" --focus || yabai -m window --space "$ws"
    else
        [[ "$follow" == "1" ]] && hyprctl dispatch movetoworkspace "$ws" || hyprctl dispatch movetoworkspacesilent "$ws"
    fi
}

wm_current_workspace() {
    if is_macos; then
        yabai -m query --spaces --space 2>/dev/null | grep -o '"index":[0-9]*' | cut -d: -f2
    else
        hyprctl activeworkspace -j 2>/dev/null | grep -o '"id":[0-9]*' | cut -d: -f2
    fi
}

# ==============================================================================
# Window Controls
# ==============================================================================
wm_fullscreen() { is_macos && yabai -m window --toggle zoom-fullscreen || hyprctl dispatch fullscreen 0; }
wm_float()      { is_macos && yabai -m window --toggle float || hyprctl dispatch togglefloating; }
wm_split()      { is_macos && yabai -m window --toggle split || hyprctl dispatch togglesplit; }
wm_rotate()     { is_macos && yabai -m space --rotate 90 || hyprctl dispatch layoutmsg orientationcycle; }
wm_balance()    { is_macos && yabai -m space --balance; }
wm_close()      { is_macos && yabai -m window --close || hyprctl dispatch killactive; }

# ==============================================================================
# Query
# ==============================================================================
wm_windows() {
    local ws="${1:-}"
    if is_macos; then
        [[ -n "$ws" ]] && yabai -m query --windows --space "$ws" || yabai -m query --windows
    else
        local all; all="$(hyprctl clients -j)"
        [[ -n "$ws" ]] && echo "$all" | jq "[.[] | select(.workspace.id == $ws)]" || echo "$all"
    fi
}

# ==============================================================================
# Service Management
# ==============================================================================
wm_reload() {
    log_info "Reloading window manager..."
    if is_macos; then
        yabai --restart-service 2>/dev/null && ok "yabai restarted"
        skhd --restart-service 2>/dev/null && ok "skhd restarted"
    else
        hyprctl reload 2>/dev/null && ok "hyprland reloaded"
    fi
}



################################################################################
FILE PATH: uke/lib/core.sh
################################################################################

#!/usr/bin/env bash
# ==============================================================================
# UKE Core Library v7.0
# ==============================================================================
# Foundation library with cloud path support and hardware profile integration.
# ==============================================================================
set -euo pipefail

[[ -n "${_UKE_CORE_LOADED:-}" ]] && return 0
readonly _UKE_CORE_LOADED=1

# ==============================================================================
# Path Resolution
# ==============================================================================
_resolve_uke_root() {
    local src="${BASH_SOURCE[1]:-${BASH_SOURCE[0]}}"
    while [[ -L "$src" ]]; do
        local dir="$(cd -P "$(dirname "$src")" && pwd)"
        src="$(readlink "$src")"
        [[ "$src" != /* ]] && src="$dir/$src"
    done
    cd -P "$(dirname "$src")/.." && pwd
}

export UKE_ROOT="${UKE_ROOT:-$(_resolve_uke_root)}"
export UKE_VERSION="7.2.0"

# ==============================================================================
# Cloud Path Support
# ==============================================================================
# If UKE_CLOUD_PATH is set, use it as the config source instead of UKE_ROOT
# Example: UKE_CLOUD_PATH="$HOME/Dropbox/uke-config"
#          UKE_CLOUD_PATH="$HOME/iCloud/uke-config"
#          UKE_CLOUD_PATH="$HOME/Google Drive/uke-config"
resolve_config_path() {
    if [[ -n "${UKE_CLOUD_PATH:-}" ]] && [[ -d "${UKE_CLOUD_PATH}" ]]; then
        echo "${UKE_CLOUD_PATH}"
    else
        echo "${UKE_ROOT}"
    fi
}

export UKE_CONFIG_SOURCE="$(resolve_config_path)"

# ==============================================================================
# Directory Structure
# ==============================================================================
# Code directories (from repo)
export UKE_LIB="$UKE_ROOT/lib"
export UKE_BIN="$UKE_ROOT/bin"
export UKE_SCRIPTS="$UKE_ROOT/scripts"
export UKE_STOW="$UKE_ROOT/stow"
export UKE_BUNCHES="$UKE_ROOT/bunches"
export UKE_DOCS="$UKE_ROOT/docs"
export UKE_TEMPLATES="$UKE_ROOT/templates"

# Config source (may be cloud or local)
export UKE_CONFIG="$UKE_CONFIG_SOURCE/config"

# Generated output (always local)
export UKE_GEN="$UKE_ROOT/gen"

# State (always local, machine-specific)
export UKE_STATE="${XDG_STATE_HOME:-$HOME/.local/state}/uke"
[[ -d "$UKE_STATE" ]] || mkdir -p "$UKE_STATE" 2>/dev/null
export UKE_LOG_FILE="$UKE_STATE/uke.log"

# Hardware profile (the "ghost file")
export UKE_PROFILE_FILE="$UKE_STATE/machine.profile"

# Ensure directories exist
mkdir -p "$UKE_STATE" 2>/dev/null || true
mkdir -p "$UKE_GEN"/{skhd,yabai,hyprland} 2>/dev/null || true

# ==============================================================================
# Platform Detection
# ==============================================================================
case "$(uname -s)" in
    Darwin) export UKE_OS="macos" ;;
    Linux)  export UKE_OS="linux" ;;
    *)      export UKE_OS="unknown" ;;
esac

# Distro detection (Linux only)
if [[ "$UKE_OS" == "linux" ]]; then
    if [[ -f /etc/arch-release ]]; then
        export UKE_DISTRO="arch"
    elif [[ -f /etc/debian_version ]]; then
        export UKE_DISTRO="debian"
    elif [[ -f /etc/fedora-release ]]; then
        export UKE_DISTRO="fedora"
    else
        export UKE_DISTRO="unknown"
    fi
else
    export UKE_DISTRO=""
fi

is_macos() { [[ "$UKE_OS" == "macos" ]]; }
is_linux() { [[ "$UKE_OS" == "linux" ]]; }

# ==============================================================================
# Hardware Profile Loading
# ==============================================================================
# Load machine-specific settings if profile exists
load_hardware_profile() {
    if [[ -f "$UKE_PROFILE_FILE" ]]; then
        # shellcheck source=/dev/null
        source "$UKE_PROFILE_FILE"
        return 0
    fi
    return 1
}

# Get profile value with fallback
get_profile() {
    local var="UKE_$1"
    local default="${2:-}"
    echo "${!var:-$default}"
}

# Check if profile exists
has_profile() {
    [[ -f "$UKE_PROFILE_FILE" ]]
}

# ==============================================================================
# Colors
# ==============================================================================
if [[ -t 1 ]]; then
    C_RED=$'\e[31m' C_GREEN=$'\e[32m' C_YELLOW=$'\e[33m'
    C_BLUE=$'\e[34m' C_MAGENTA=$'\e[35m' C_CYAN=$'\e[36m'
    C_BOLD=$'\e[1m' C_DIM=$'\e[2m' C_RESET=$'\e[0m'
else
    C_RED='' C_GREEN='' C_YELLOW='' C_BLUE='' C_MAGENTA='' C_CYAN=''
    C_BOLD='' C_DIM='' C_RESET=''
fi

# ==============================================================================
# Logging
# ==============================================================================
_log() {
    local level="$1" color="$2"; shift 2
    local ts="$(date '+%H:%M:%S')"
    printf "%s[%s]%s %s%s%s %s\n" "$C_DIM" "$ts" "$C_RESET" "$color" "$level" "$C_RESET" "$*" >&2
    [[ -w "$UKE_STATE" ]] && printf "[%s] [%s] %s\n" "$(date '+%Y-%m-%d %H:%M:%S')" "$level" "$*" >> "$UKE_LOG_FILE"
}

log_debug() { [[ -n "${UKE_DEBUG:-}" ]] && _log "DEBUG" "$C_BLUE" "$@"; }
log_info()  { _log "INFO " "$C_GREEN" "$@"; }
log_warn()  { _log "WARN " "$C_YELLOW" "$@"; }
log_error() { _log "ERROR" "$C_RED" "$@"; }
log_fatal() { _log "FATAL" "$C_RED" "$@"; exit 1; }

ok()   { printf "%sâœ“%s %s\n" "$C_GREEN" "$C_RESET" "$*"; }
fail() { printf "%sâœ—%s %s\n" "$C_RED" "$C_RESET" "$*"; }
warn() { printf "%s!%s %s\n" "$C_YELLOW" "$C_RESET" "$*"; }
info() { printf "%sâ†’%s %s\n" "$C_BLUE" "$C_RESET" "$*"; }

# ==============================================================================
# Utilities
# ==============================================================================
require_cmd() {
    for cmd in "$@"; do
        command -v "$cmd" &>/dev/null || log_fatal "Required command not found: $cmd"
    done
}

require_file() {
    for f in "$@"; do
        [[ -f "$f" ]] || log_fatal "Required file not found: $f"
    done
}

run() {
    log_debug "exec: $*"
    if [[ -n "${UKE_DRY_RUN:-}" ]]; then
        log_info "[dry-run] $*"
        return 0
    fi
    "$@"
}

# Atomic file write
write_file() {
    local dest="$1"
    local content
    content=$(cat)
    
    mkdir -p "$(dirname "$dest")"
    local temp_file
    temp_file=$(mktemp)
    printf "%s\n" "$content" > "$temp_file"
    mv "$temp_file" "$dest"
}

# ==============================================================================
# YAML Helpers (requires yq)
# ==============================================================================
yaml_get() {
    local file="$1"
    local path="$2"
    local default="${3:-}"
    
    if command -v yq &>/dev/null; then
        local result
        result=$(yq -r "$path | select(. != null)" "$file" 2>/dev/null) || true
        echo "${result:-$default}"
    else
        echo "$default"
    fi
}

yaml_keys() {
    local file="$1"
    local path="$2"
    
    if command -v yq &>/dev/null; then
        yq -r "$path | keys | .[]" "$file" 2>/dev/null || true
    fi
}

yaml_array() {
    local file="$1"
    local path="$2"
    
    if command -v yq &>/dev/null; then
        yq -r "$path | .[]" "$file" 2>/dev/null || true
    fi
}

# ==============================================================================
# Permission Fix - Ensure state dir is user-owned
# ==============================================================================
if [[ -d "$UKE_STATE" ]] && [[ ! -w "$UKE_STATE" ]]; then
    sudo chown -R "$USER" "$UKE_STATE" 2>/dev/null || true
fi



################################################################################
FILE PATH: uke/templates/.gitkeep
################################################################################




